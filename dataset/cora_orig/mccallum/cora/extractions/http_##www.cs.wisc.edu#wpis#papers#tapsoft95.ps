URL: http://www.cs.wisc.edu/wpis/papers/tapsoft95.ps
Refering-URL: http://www.cs.wisc.edu/~reps/
Root-URL: 
Email: horwitzg@cs.wisc.edu  
Title: Precise Interprocedural Dataflow Analysis with Applications to Constant Propagation 1  
Author: Mooly Sagiv, Thomas Reps, and Susan Horwitz 
Note: Electronic mail: fsagiv, reps,  
Address: 1210 West Dayton Street, Madison, WI 53706 USA  
Affiliation: Computer Sciences Department, University of Wisconsin-Madison  
Abstract: This paper concerns interprocedural dataflow-analysis problems in which the dataflow information at a program point is represented by an environment (i.e., a mapping from symbols to values), and the effect of a program operation is represented by a distributive environment transformer. We present an efficient dynamic-programming algorithm that produces precise solutions. The method is applied to solve precisely and efficiently two (decidable) variants of the interprocedural constant-propagation problem: copy constant propagation and linear constant propagation. The former interprets program statements of the form x := 7 and x := y. The latter also interprets statements of the form x := 5 fl y + 17.
Abstract-found: 1
Intro-found: 1
Reference: [Cal88] <author> D. Callahan. </author> <title> The program summary graph and flow-sensitive interprocedural data flow analysis. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 47-56, </pages> <year> 1988. </year>
Reference-contexts: In contrast with intraprocedural dataflow analysis, where "precise" means "meet-over-all-paths" [Kil73], a precise inter procedural dataflow-analysis algorithm must provide the "meet-over-all-valid-paths" solution. (A path is valid if it respects the fact that when a procedure finishes it returns to the site of the most recent call <ref> [SP81, Cal88, LR91, KS92, Rep94, RSH94, RHS95] </ref>.) In this paper, we show how to find the meet-over-all-valid-paths solution for a certain class of dataflow problems in which the dataflow facts are maps ("envi-ronments") from some finite set of symbols D to some (possibly infinite) set of values L (i.e., the dataflow
Reference: [CCKT86] <author> D. Callahan, K.D. Cooper, K. Kennedy, and L. Torczon. </author> <title> Interprocedural constant prop agation. </title> <booktitle> In SIGPLAN Symposium on Compiler Construction, </booktitle> <pages> pages 152-161, </pages> <year> 1986. </year>
Reference-contexts: The algorithms obtained in this way improve on the well-known constant-propagation work from Rice <ref> [CCKT86, GT93] </ref> in two ways: * The Rice algorithm is not precise for recursive programs. (In fact, it may fall into an infinite loop when applied to recursive programs). * Because of limitations in the way "return jump functions" are generated, the Rice algorithm does not even yield precise answers for <p> For both copy constant propagation and linear constant propagation, there are several antecedents. A version of interprocedural copy constant propagation was developed at Rice and has been in use for many years. The algorithm is described in <ref> [CCKT86] </ref>, and studies of how the algorithm performs in practice on Fortran programs were carried out by Grove and Torczon [GT93].
Reference: [DGS95] <author> E. Duesterwald, R. Gupta, </author> <title> and M.L. Soffa. Demand-driven computation of interproce dural data flow. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 37-48, </pages> <year> 1995. </year>
Reference-contexts: A different approach to obtaining demand versions of interprocedural dataflow-analysis algorithms has been investigated by Duesterwald, Gupta, and Soffa <ref> [DGS95] </ref>. In their approach, for each query a set of dataflow equations is set up on the flow graph (but as if all edges were reversed). The flow functions on the reverse graph are the (approximate) inverses of the forward flow functions.
Reference: [FL88] <author> C.N. Fischer and R.J. LeBlanc. </author> <title> Crafting a Compiler. </title> <publisher> Benjamin/Cummings Publishing Company, Inc., </publisher> <address> Menlo Park, CA, </address> <year> 1988. </year>
Reference-contexts: However, we identify a subset of IDE problems for which the algorithm does terminate and runs in time O (ED 3 ), where E is the number of edges in the program's control-flow graph. * We study two natural variants of the constant-propagation problem: copy-constant propagation <ref> [FL88] </ref> and linear-constant propagation, which extends copy constant propagation by interpreting statements of the form x = a fl y + b, where a and b are 1 This work was supported in part by a David and Lucile Packard Fellowship for Science and Engineering, by the National Science Foundation under
Reference: [GT93] <author> D. Grove and L. Torczon. </author> <title> A study of jump function implementations. </title> <booktitle> In SIGPLAN Conference on Programming Languages Design and Implementation, </booktitle> <pages> pages 90-99, </pages> <year> 1993. </year>
Reference-contexts: The algorithms obtained in this way improve on the well-known constant-propagation work from Rice <ref> [CCKT86, GT93] </ref> in two ways: * The Rice algorithm is not precise for recursive programs. (In fact, it may fall into an infinite loop when applied to recursive programs). * Because of limitations in the way "return jump functions" are generated, the Rice algorithm does not even yield precise answers for <p> A version of interprocedural copy constant propagation was developed at Rice and has been in use for many years. The algorithm is described in [CCKT86], and studies of how the algorithm performs in practice on Fortran programs were carried out by Grove and Torczon <ref> [GT93] </ref>. <p> We have also shown in this paper how to solve linear constant-propagation problems, which in general find a superset of the instances of constant variables found by copy constant propagation. Several others have also examined classes of constant-propagation problems more general than copy constant propagation <ref> [Kar76, SK91, GT93, MS93] </ref>. 8 Demand Dataflow Analysis We have developed and implemented a demand algorithm for the IDE framework. The demand algorithm finds the value of a given symbol d 2 D at a given control flow graph node n 2 N fl .
Reference: [HRS95] <author> S. Horwitz, T. Reps, and M. Sagiv. </author> <title> Demand interprocedural dataflow analysis. </title> <address> Unpub lished manuscript, </address> <year> 1995. </year>
Reference-contexts: The relationship between the demand algorithm and the algorithm of Section 5 is similar to the relationship that holds for IFDS problems between the demand algorithm of <ref> [RSH94, HRS95] </ref> and the exhaustive algorithm of [RSH94, RHS95]. A different approach to obtaining demand versions of interprocedural dataflow-analysis algorithms has been investigated by Duesterwald, Gupta, and Soffa [DGS95].
Reference: [JM86] <author> N.D. Jones and A. Mycroft. </author> <title> Data flow analysis of applicative programs using minimal function graphs. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 296-306, </pages> <year> 1986. </year>
Reference-contexts: On each iteration of the main loop, the algorithm determines better approximations to path and summary functions. To reduce the amount of work performed, ComputePathFunctions uses an idea similar to the "minimal-function-graph" approach <ref> [JM86] </ref>: Only after a path function for a path from a node of the form hs p ; d 1 i to a node of the form hc; d 2 i has been processed, where c is a call on procedure q, will a path from hs q ; d 3
Reference: [Kar76] <author> M. Karr. </author> <title> Affine relationship among variables of a program. </title> <journal> Acta Inf., </journal> <volume> 6 </volume> <pages> 133-151, </pages> <year> 1976. </year>
Reference-contexts: We have also shown in this paper how to solve linear constant-propagation problems, which in general find a superset of the instances of constant variables found by copy constant propagation. Several others have also examined classes of constant-propagation problems more general than copy constant propagation <ref> [Kar76, SK91, GT93, MS93] </ref>. 8 Demand Dataflow Analysis We have developed and implemented a demand algorithm for the IDE framework. The demand algorithm finds the value of a given symbol d 2 D at a given control flow graph node n 2 N fl .
Reference: [Kil73] <author> G.A. Kildall. </author> <title> A unified approach to global program optimization. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 194-206, </pages> <year> 1973. </year>
Reference-contexts: Of the problems to which our techniques apply, several variants of the interprocedural constant-propagation problem stand out as being of particular importance. In contrast with intraprocedural dataflow analysis, where "precise" means "meet-over-all-paths" <ref> [Kil73] </ref>, a precise inter procedural dataflow-analysis algorithm must provide the "meet-over-all-valid-paths" solution. (A path is valid if it respects the fact that when a procedure finishes it returns to the site of the most recent call [SP81, Cal88, LR91, KS92, Rep94, RSH94, RHS95].) In this paper, we show how to find
Reference: [KS92] <author> J. Knoop and B. Steffen. </author> <title> The interprocedural coincidence theorem. </title> <booktitle> In International Conference on Compiler Construction, </booktitle> <pages> pages 125-140, </pages> <year> 1992. </year>
Reference-contexts: In contrast with intraprocedural dataflow analysis, where "precise" means "meet-over-all-paths" [Kil73], a precise inter procedural dataflow-analysis algorithm must provide the "meet-over-all-valid-paths" solution. (A path is valid if it respects the fact that when a procedure finishes it returns to the site of the most recent call <ref> [SP81, Cal88, LR91, KS92, Rep94, RSH94, RHS95] </ref>.) In this paper, we show how to find the meet-over-all-valid-paths solution for a certain class of dataflow problems in which the dataflow facts are maps ("envi-ronments") from some finite set of symbols D to some (possibly infinite) set of values L (i.e., the dataflow <p> labeled "Con-stants" indicate the number of right-hand-side variable uses that were found to be constant. "Lines/sec." indicates the number of lines of source code processed per second. 7 Related Work The IDE framework is based on earlier interprocedural dataflow-analysis frameworks defined by Sharir and Pnueli [SP81] and Knoop and Steffen <ref> [KS92] </ref>, as well as the interprocedural, finite, distributive, subset framework (or IFDS framework, for short) that we proposed earlier [RSH94, RHS95]. <p> Condition (iii), however, generalizes the Sharir-Pnueli framework and permits it to cover programming languages in which recursive procedures have local variables and parameters (which the Sharir-Pnueli framework does not). A different generalization to handle recursive procedures with local variables and parameters was proposed by Knoop and Steffen <ref> [KS92] </ref>. The IDE framework is a strict generalization of the IFDS framework proposed in [RSH94, RHS95].
Reference: [LR91] <author> W. Landi and B.G. Ryder. </author> <title> Pointer induced aliasing: A problem classification. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 93-103, </pages> <year> 1991. </year>
Reference-contexts: In contrast with intraprocedural dataflow analysis, where "precise" means "meet-over-all-paths" [Kil73], a precise inter procedural dataflow-analysis algorithm must provide the "meet-over-all-valid-paths" solution. (A path is valid if it respects the fact that when a procedure finishes it returns to the site of the most recent call <ref> [SP81, Cal88, LR91, KS92, Rep94, RSH94, RHS95] </ref>.) In this paper, we show how to find the meet-over-all-valid-paths solution for a certain class of dataflow problems in which the dataflow facts are maps ("envi-ronments") from some finite set of symbols D to some (possibly infinite) set of values L (i.e., the dataflow
Reference: [MS93] <author> R. Metzger and S. Stroud. </author> <title> Interprocedural constant propagation: An empirical study. </title> <journal> ACM Letters on Programming Languages and Systems, </journal> <volume> 2, </volume> <year> 1993. </year>
Reference-contexts: We have also shown in this paper how to solve linear constant-propagation problems, which in general find a superset of the instances of constant variables found by copy constant propagation. Several others have also examined classes of constant-propagation problems more general than copy constant propagation <ref> [Kar76, SK91, GT93, MS93] </ref>. 8 Demand Dataflow Analysis We have developed and implemented a demand algorithm for the IDE framework. The demand algorithm finds the value of a given symbol d 2 D at a given control flow graph node n 2 N fl .
Reference: [Rep94] <author> T. Reps. </author> <title> Solving demand versions of interprocedural analysis problems. </title> <booktitle> In International Conference on Compiler Construction, </booktitle> <pages> pages 389-403, </pages> <year> 1994. </year>
Reference-contexts: In contrast with intraprocedural dataflow analysis, where "precise" means "meet-over-all-paths" [Kil73], a precise inter procedural dataflow-analysis algorithm must provide the "meet-over-all-valid-paths" solution. (A path is valid if it respects the fact that when a procedure finishes it returns to the site of the most recent call <ref> [SP81, Cal88, LR91, KS92, Rep94, RSH94, RHS95] </ref>.) In this paper, we show how to find the meet-over-all-valid-paths solution for a certain class of dataflow problems in which the dataflow facts are maps ("envi-ronments") from some finite set of symbols D to some (possibly infinite) set of values L (i.e., the dataflow
Reference: [RHS95] <author> T. Reps, S. Horwitz, and M. Sagiv. </author> <title> Precise interprocedural dataflow analysis via graph reachability. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 49-61, </pages> <year> 1995. </year>
Reference-contexts: In contrast with intraprocedural dataflow analysis, where "precise" means "meet-over-all-paths" [Kil73], a precise inter procedural dataflow-analysis algorithm must provide the "meet-over-all-valid-paths" solution. (A path is valid if it respects the fact that when a procedure finishes it returns to the site of the most recent call <ref> [SP81, Cal88, LR91, KS92, Rep94, RSH94, RHS95] </ref>.) In this paper, we show how to find the meet-over-all-valid-paths solution for a certain class of dataflow problems in which the dataflow facts are maps ("envi-ronments") from some finite set of symbols D to some (possibly infinite) set of values L (i.e., the dataflow <p> of lines of source code processed per second. 7 Related Work The IDE framework is based on earlier interprocedural dataflow-analysis frameworks defined by Sharir and Pnueli [SP81] and Knoop and Steffen [KS92], as well as the interprocedural, finite, distributive, subset framework (or IFDS framework, for short) that we proposed earlier <ref> [RSH94, RHS95] </ref>. <p> A different generalization to handle recursive procedures with local variables and parameters was proposed by Knoop and Steffen [KS92]. The IDE framework is a strict generalization of the IFDS framework proposed in <ref> [RSH94, RHS95] </ref>. In IFDS problems, the set of dataflow facts D is a finite set and the dataflow functions (which are in 2 D ! 2 D ) distribute over the meet operator (either union or intersection, depending on the problem). <p> The relationship between the demand algorithm and the algorithm of Section 5 is similar to the relationship that holds for IFDS problems between the demand algorithm of [RSH94, HRS95] and the exhaustive algorithm of <ref> [RSH94, RHS95] </ref>. A different approach to obtaining demand versions of interprocedural dataflow-analysis algorithms has been investigated by Duesterwald, Gupta, and Soffa [DGS95]. In their approach, for each query a set of dataflow equations is set up on the flow graph (but as if all edges were reversed).
Reference: [RSH94] <author> T. Reps, M. Sagiv, and S. Horwitz. </author> <title> Interprocedural dataflow analysis via graph reacha bility. </title> <type> Technical Report TR 94-14, </type> <institution> Datalogisk Institut, University of Copenhagen, </institution> <year> 1994. </year>
Reference-contexts: In contrast with intraprocedural dataflow analysis, where "precise" means "meet-over-all-paths" [Kil73], a precise inter procedural dataflow-analysis algorithm must provide the "meet-over-all-valid-paths" solution. (A path is valid if it respects the fact that when a procedure finishes it returns to the site of the most recent call <ref> [SP81, Cal88, LR91, KS92, Rep94, RSH94, RHS95] </ref>.) In this paper, we show how to find the meet-over-all-valid-paths solution for a certain class of dataflow problems in which the dataflow facts are maps ("envi-ronments") from some finite set of symbols D to some (possibly infinite) set of values L (i.e., the dataflow <p> of lines of source code processed per second. 7 Related Work The IDE framework is based on earlier interprocedural dataflow-analysis frameworks defined by Sharir and Pnueli [SP81] and Knoop and Steffen [KS92], as well as the interprocedural, finite, distributive, subset framework (or IFDS framework, for short) that we proposed earlier <ref> [RSH94, RHS95] </ref>. <p> A different generalization to handle recursive procedures with local variables and parameters was proposed by Knoop and Steffen [KS92]. The IDE framework is a strict generalization of the IFDS framework proposed in <ref> [RSH94, RHS95] </ref>. In IFDS problems, the set of dataflow facts D is a finite set and the dataflow functions (which are in 2 D ! 2 D ) distribute over the meet operator (either union or intersection, depending on the problem). <p> The relationship between the demand algorithm and the algorithm of Section 5 is similar to the relationship that holds for IFDS problems between the demand algorithm of <ref> [RSH94, HRS95] </ref> and the exhaustive algorithm of [RSH94, RHS95]. A different approach to obtaining demand versions of interprocedural dataflow-analysis algorithms has been investigated by Duesterwald, Gupta, and Soffa [DGS95]. <p> The relationship between the demand algorithm and the algorithm of Section 5 is similar to the relationship that holds for IFDS problems between the demand algorithm of [RSH94, HRS95] and the exhaustive algorithm of <ref> [RSH94, RHS95] </ref>. A different approach to obtaining demand versions of interprocedural dataflow-analysis algorithms has been investigated by Duesterwald, Gupta, and Soffa [DGS95]. In their approach, for each query a set of dataflow equations is set up on the flow graph (but as if all edges were reversed).
Reference: [SK91] <author> B. Steffen and J. Knoop. </author> <title> Finite constants: Characterizations of a new decidable set of constants. </title> <journal> Theoretical Computer Science, </journal> <volume> 80(2) </volume> <pages> 303-318, </pages> <year> 1991. </year>
Reference-contexts: We have also shown in this paper how to solve linear constant-propagation problems, which in general find a superset of the instances of constant variables found by copy constant propagation. Several others have also examined classes of constant-propagation problems more general than copy constant propagation <ref> [Kar76, SK91, GT93, MS93] </ref>. 8 Demand Dataflow Analysis We have developed and implemented a demand algorithm for the IDE framework. The demand algorithm finds the value of a given symbol d 2 D at a given control flow graph node n 2 N fl .
Reference: [SP81] <author> M. Sharir and A. Pnueli. </author> <title> Two approaches for interprocedural data flow analysis. </title> <editor> In S.S. Muchnick and N.D. Jones, editors, </editor> <title> Program Flow Analysis: </title> <journal> Theory and Applications, </journal> <volume> chapter 7, </volume> <pages> pages 189-234. </pages> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: In contrast with intraprocedural dataflow analysis, where "precise" means "meet-over-all-paths" [Kil73], a precise inter procedural dataflow-analysis algorithm must provide the "meet-over-all-valid-paths" solution. (A path is valid if it respects the fact that when a procedure finishes it returns to the site of the most recent call <ref> [SP81, Cal88, LR91, KS92, Rep94, RSH94, RHS95] </ref>.) In this paper, we show how to find the meet-over-all-valid-paths solution for a certain class of dataflow problems in which the dataflow facts are maps ("envi-ronments") from some finite set of symbols D to some (possibly infinite) set of values L (i.e., the dataflow <p> however, it does terminate for all copy constant-propagation problems, all linear constant-propagation problems, and, in general, for all problems for which the space F of value-transformer functions contains no infinite decreasing chains. (Note that it is possible to construct infinite decreasing chains even in certain distributive variants of constant propagation <ref> [SP81, page 206] </ref>.) 11 The cost of the algorithm is dominated by the cost of Phase I. This phase can be carried out particularly efficiently if there exists a way of representing the functions such that the functional operations can be computed in unit-time. <p> The columns labeled "Con-stants" indicate the number of right-hand-side variable uses that were found to be constant. "Lines/sec." indicates the number of lines of source code processed per second. 7 Related Work The IDE framework is based on earlier interprocedural dataflow-analysis frameworks defined by Sharir and Pnueli <ref> [SP81] </ref> and Knoop and Steffen [KS92], as well as the interprocedural, finite, distributive, subset framework (or IFDS framework, for short) that we proposed earlier [RSH94, RHS95].
Reference: [SPE92] <institution> SPEC Component CPU Integer Release 2/1992 (Cint92). Standard Performance Evalu ation Corporation (SPEC), Fairfax, VA, </institution> <year> 1992. </year>
Reference-contexts: integer linear constant-propagation problem. (Pointers were handled conservatively; every assignment through a pointer was considered to kill all variables to which the "&" operator is applied somewhere in the program; all uses through pointers were considered non-constant.) The study used five C programs taken from the SPEC integer benchmark suite <ref> [SPE92] </ref>.
References-found: 18

