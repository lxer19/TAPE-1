URL: ftp://ftp.pmg.lcs.mit.edu/pub/andru/thesis.ps.gz
Refering-URL: http://www.pmg.lcs.mit.edu/papers/bidirectional/node21.html
Root-URL: 
Title: Fast Object Operations in a Persistent Programming System  
Author: by Andrew C. Myers Barbara Liskov 
Degree: Submitted to the Department of Electrical Engineering and Computer Science in partial fulfillment of the requirements for the degree of Master of Science at the  All rights reserved. Author  Certified by  Professor of Software Science and Engineering Thesis Supervisor Accepted by Frederic R. Morgenthaler Chairman, Committee on Graduate Students  
Date: January 1994  April 15, 1994  
Affiliation: MASSACHUSETTS INSTITUTE OF TECHNOLOGY  c Massachusetts Institute of Technology 1994.  Department of Electrical Engineering and Computer Science  NEC  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> P.S. Canning, W. R. Cook, W. L. Hill, and W. G. Olthoff. </author> <title> Interfaces for strongly-typed object-oriented programming. </title> <booktitle> In OOPSLA '89 Conference Proceedings, </booktitle> <pages> pages 457-467, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: Inheritance, on the other hand, is a useful mechanism for producing classes that implement these interfaces. The class inheritance mechanism in most object-oriented languages is very powerful. Two distinct major uses of inheritance have been identified <ref> [1] </ref>: interface inheritance, and implementation inheritance. Interface inheritance is identical to subtyping that is, interface A inherits from interface B if the type A is a subtype of B. Thus, interface inheritance is a relation between types.
Reference: [2] <author> Luca Cardelli, James Donahue, Lucille Glassman, Mick Jordan, Bill Kalsow, and Greg Nelson. </author> <title> Language definition. </title> <editor> In Greg Nelson, editor, </editor> <booktitle> Systems Programming in Modula-3, chapter 2. </booktitle> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Unfortunately, most persistent programming languages do not perform as well as statically-compiled, non-persistent systems, limiting their general acceptance. Because persistent objects may exist for a long time, performance decisions may need to be revisited. In programming languages like C++ [12] or Modula-3 <ref> [2] </ref>, programmers may increase performance by limiting the extensibility of programs | for example, by exposing some implementation details of the types used. These limitations are unacceptable in an evolving, persistent system. The goal of this thesis is to show how good performance can be achieved without sacrificing extensibility.
Reference: [3] <author> Craig Chambers. </author> <title> Private communication. </title>
Reference-contexts: Mapping the old stack frame layout into the new layout is tricky, especially in the face of arbitrary optimizations and inlining. This technique is used in Self, but creates significant implementation problems <ref> [3] </ref>. Using this technique in Thor would make it less portable, since rewriting the stack usually depends on details of the machine architecture. Another approach is to abort the current computation (erasing its effects) and restart it from scratch.
Reference: [4] <author> Craig Chambers. </author> <title> The Design and Implementation of the Self Compiler, an Optimizing Compiler for Object-Oriented Programming Languages. </title> <type> PhD thesis, </type> <institution> Stanford University Department of Computer Science, Stanford, </institution> <address> CA, </address> <month> March </month> <year> 1992. </year>
Reference-contexts: Non-virtual methods can even be inlined in C++, although the programmer is again required to indicate this explicitly. The use of non-virtual and inlined non-virtual methods in C++ can provide a significant performance improvement. For example, the Richards benchmark <ref> [4] </ref> runs 50% faster when inlined non-virtual methods are used. The data from this simple experiment, which was performed on a DEC AXP 3000/400 system, are shown in 14 Virtual methods 201 ms Non-virtual methods 104 ms cxx, with optimization. <p> Some concern has been voiced about the impact of embedded objects in a garbage-collected language, since finding the outermost object (with which the garbage collector is concerned) becomes more difficult <ref> [4] </ref>. However, this difficulty can be easily resolved by including the offset to the outermost object directly in the dispatch table. <p> In Self, inherited methods are customized for each of the inheriting classes | essentially recompiling the inherited code for each inheriting environment <ref> [4, 5] </ref>. Within the customized version of each method, the implementation of the receiver object is known | it must be the class for which the method is being customized. <p> The idea is that different callers use different versions of the code, depending on which of their arguments are known not to be surrogates. The idea of automatically customizing on procedure argument types has been suggested as an extension to customization in Self <ref> [4] </ref>, although the idea was not seriously explored there. Considerably more work needs to be done here to understand the time/space tradeoffs and the additional runtime bookkeeping. Avoiding the problem with object fields is more problematic.
Reference: [5] <author> Craig Chambers, David Ungar, and Elgin Lee. </author> <title> An efficient implementation of self, a dynamically-typed object-oriented language based on prototypes. </title> <booktitle> In OOPSLA '89 Conference Proceedings, </booktitle> <pages> pages 49-70, </pages> <address> New Orleans, LA, </address> <month> October </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October, </month> <year> 1989. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year>
Reference-contexts: Dynamically-Typed Object-oriented programming languages are divided into two major camps: statically typed vs. dynamically typed. In the former camp are languages such as C++ [12], Modula-3 [18], and Trellis/Owl [22]. In the latter are Smalltalk [13], Self <ref> [5] </ref>, and Objective C [8]. Dynamically-typed languages provide greater polymorphism, since there is no type system to limit the kind of object that can be provided as a method argument. However, these languages do not have the advantages of compile-time type-checking. <p> In Self, inherited methods are customized for each of the inheriting classes | essentially recompiling the inherited code for each inheriting environment <ref> [4, 5] </ref>. Within the customized version of each method, the implementation of the receiver object is known | it must be the class for which the method is being customized.
Reference: [6] <author> J. Bradley Chen and Brian N. Bershad. </author> <title> The impact of operating system structure on memory system performance. </title> <booktitle> In Proceedings of the 14th ACM Symposium on Operating System Principles, </booktitle> <month> December </month> <year> 1993. </year> <note> To appear. </note>
Reference-contexts: If the application's data locality is poorer, cache misses result. On the Decstation 5000/200, using a MIPS R3000, a cache miss causes a 15 cycle delay while a new cache line is fetched <ref> [6] </ref>. At the next level, TLB misses can add another 9 cycles or so. Finally, a thrashing application will experience very large values of L as pages are swapped between primary and secondary storage. <p> As more objects contend for the data cache, the cost of this extra load could increase. The Decstation 5000/200 is equipped with a 64K direct-mapped cache, with a line size of 4 words, and a cache 49 miss penalty is 15 cycles <ref> [6] </ref>. The data for the experiment are shown in Figure 2-19. This graph compares four different procedure-call mechanisms, of which two are full dispatches. The lower two curves represent the overhead of a procedure call, and of inlining the procedure body.
Reference: [7] <institution> Digital Equipment Corporation. Alpha Architecture Handbook. </institution> <year> 1992. </year>
Reference-contexts: + 1 + J Cast Up L or 1 or 0 1 or 0 0 Class Field Access L L L SI Superclass Field Access L L L MI Superclass Field Access 2L L L indirect jump is certainly larger than 1, and may be as large as 10 cycles <ref> [7] </ref>. The third column in Figure 2-18 represents a hypothetical system that assigns both methods and fields indices in such a way that all dispatch tables can be merged. This condition yields the performance of the early, single-inheritance versions of C++.
Reference: [8] <author> The StepStone Corporation. </author> <title> The Objective-C Reference Manual. </title> <type> Sandy Hook, </type> <institution> CT, </institution> <year> 1990. </year>
Reference-contexts: Dynamically-Typed Object-oriented programming languages are divided into two major camps: statically typed vs. dynamically typed. In the former camp are languages such as C++ [12], Modula-3 [18], and Trellis/Owl [22]. In the latter are Smalltalk [13], Self [5], and Objective C <ref> [8] </ref>. Dynamically-typed languages provide greater polymorphism, since there is no type system to limit the kind of object that can be provided as a method argument. However, these languages do not have the advantages of compile-time type-checking. Performing method dispatch is a more complex process in dynamically-typed languages.
Reference: [9] <author> Mark Day, Robert Gruber, Barbara Liskov, and Andrew C. Myers. </author> <title> Theta refer-ence manual. </title> <type> Technical report, </type> <year> 1994. </year> <note> To appear as memo of the Programming Methodology Group, </note> <institution> Laboratory for Computer Science, MIT. </institution>
Reference-contexts: The limitations of static typing are ameliorated in Theta through parametric poly-morphism and more expensive mechanisms like casting down and class evolution | topics beyond the scope of this thesis. At the time of this writing, Theta has not been completely specified; however, a reference manual is forthcoming <ref> [9] </ref>. 1.2.1 Types and Classes Theta is an object-oriented language, with multiple supertypes and single inheritance. A type specifies an interface: a set of methods that can be performed on objects of that type. However, types do not specify the implementations of those methods.
Reference: [10] <author> L. Peter Deutsch and Allan M. Schiffman. </author> <title> Efficient implementation of the Smalltalk-80 system. </title> <booktitle> In Conference Record of the Eleventh Annual ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 297-302, </pages> <address> Salt Lake City, UT, </address> <month> January </month> <year> 1984. </year>
Reference-contexts: This increase in code size can reduce VM performance and instruction cache performance. To reduce the effect of code duplication, Self also uses dynamic translation, originated in the Deutch/Schiffman implementation of Smalltalk-80 <ref> [10] </ref>. Dynamic translation means that code is stored in a compact intermediate form and, when needed, translated on the fly into an efficiently executable form such as machine code. In Self, customized code generation is performed on methods only when those methods are actually called using a new class.
Reference: [11] <author> R. Dixon, T. McKee, P. Schweitzer, and M. Vaughan. </author> <title> A fast method dispatcher for compiled languages with multiple inheritance. </title> <booktitle> In OOPSLA '89 Conference Proceedings, </booktitle> <pages> pages 211-214, </pages> <address> New Orleans, LA, </address> <month> October </month> <year> 1989. </year> <note> Published as SIG-PLAN Notices 24(10), </note> <month> October, </month> <year> 1989. </year>
Reference-contexts: Most fast dispatching schemes share a table or set of tables among all objects of a class. Some researchers have been concerned about making these tables as small as possible <ref> [11, 20] </ref>. However, since dispatch tables are shared, they consume a small fraction of memory, assuming that there are a reasonable number of objects per dispatch table. <p> The limit of merging is a system in which every two types can be merged. This approach requires assigning method indices based on a global analysis of the type hierarchy <ref> [11] </ref>. Unfortunately, the problem of allocating method indices for all classes while minimizing the wasted dispatch table space is NP-hard [21]. Heuristics for index assignment have been developed that reduce the wasted space to about 6%, using two-directional record layout [20].
Reference: [12] <author> Margaret A. Ellis and Bjarne Stroustrup. </author> <title> The Annotated C++ Reference Manual. </title> <publisher> Addison-Wesley, </publisher> <year> 1990. </year>
Reference-contexts: Unfortunately, most persistent programming languages do not perform as well as statically-compiled, non-persistent systems, limiting their general acceptance. Because persistent objects may exist for a long time, performance decisions may need to be revisited. In programming languages like C++ <ref> [12] </ref> or Modula-3 [2], programmers may increase performance by limiting the extensibility of programs | for example, by exposing some implementation details of the types used. These limitations are unacceptable in an evolving, persistent system. <p> Dynamically-Typed Object-oriented programming languages are divided into two major camps: statically typed vs. dynamically typed. In the former camp are languages such as C++ <ref> [12] </ref>, Modula-3 [18], and Trellis/Owl [22]. In the latter are Smalltalk [13], Self [5], and Objective C [8]. Dynamically-typed languages provide greater polymorphism, since there is no type system to limit the kind of object that can be provided as a method argument.
Reference: [13] <author> Adele Goldberg and David Robson. </author> <title> Smalltalk-80: The Language and its Implementation. </title> <publisher> Addison-Wesley, </publisher> <year> 1983. </year>
Reference-contexts: Dynamically-Typed Object-oriented programming languages are divided into two major camps: statically typed vs. dynamically typed. In the former camp are languages such as C++ [12], Modula-3 [18], and Trellis/Owl [22]. In the latter are Smalltalk <ref> [13] </ref>, Self [5], and Objective C [8]. Dynamically-typed languages provide greater polymorphism, since there is no type system to limit the kind of object that can be provided as a method argument. However, these languages do not have the advantages of compile-time type-checking.
Reference: [14] <author> Urs Holzle, Bay-Wei Chang, Craig Chambers, Ole Agesen, and David Ungar. </author> <title> The Self Manual, </title> <note> Version 1.1, February 1991. Unpublished manual. </note>
Reference-contexts: I explain how the Theta runtime system makes this optimization possible. 3.1 Related Work The technique of customization was pioneered in the language Self <ref> [26, 14, 25] </ref> to avoid the cost of dispatch entirely in many situations. The idea of customization is to generate multiple versions of the same piece of code, depending on the environment in which the code is needed.
Reference: [15] <editor> Douglas Lea. Customization in C++. </editor> <booktitle> In Proceedings of the 1990 Usenix C++ Conference, </booktitle> <pages> pages 301-314, </pages> <address> San Francisco, CA, </address> <month> April </month> <year> 1990. </year>
Reference-contexts: Because of the limited performance gains expected and the code duplication of the Self customization approach, it does not seem directly applicable to Theta. 3.1.2 Customization in C++ Douglas Lea has proposed that customization can be used as an extension to C++, a statically-typed and separately-compiled language <ref> [15] </ref>, by adding static user annotations to C++ class definitions. While his proposal is a form of customization intended to avoid method dispatches, it is quite different from the Self customiza 54 tion strategy. Unlike Self, his proposal has not been implemented, so performance results are not available.
Reference: [16] <author> B. Liskov and et al. </author> <title> CLU Reference Manual. </title> <publisher> Springer-Verlag, </publisher> <year> 1984. </year>
Reference-contexts: This implementation of Theta objects is written in C and runs on both Alpha-based and MIPS-based workstations from DEC. It supports dispatching on parameterized types <ref> [22, 16] </ref> as well as on the ordinary object types described here. To test the performance model described in Section 2.5.8, I measured the overhead incurred on the MIPS R3000 when using each of the standard method call mechanisms discussed here.
Reference: [17] <author> Barbara Liskov, Mark Day, and Liuba Shrira. </author> <title> Distributed object management in Thor. </title> <editor> In Tamer Ozsu, Umesh Dayal, and Patrick Valduriez, editors, </editor> <booktitle> Distributed Object Management, </booktitle> <pages> pages 79-91. </pages> <publisher> Morgan Kaufmann, </publisher> <year> 1993. </year>
Reference-contexts: The bookkeeping of assumptions and dependencies, and the techniques for recovering from invalidation, apply to other optimizations as well. To implement orthogonal persistence, Thor uses surrogate objects <ref> [17] </ref>. A surrogate object exists only at the FE, as a placeholder for a real, persistent object. It is able to accept method calls, like the object that it represents, but it does not contain the real object's data. <p> Ultimately, references to the surrogate are patched by the garbage collector, redirecting them to the true object. Surrogates can be also be created by the FE when memory is scarce | the FE shrinks objects, replacing them with surrogates <ref> [17] </ref>. Surrogate checks are a performance problem unique to persistent languages. But in many contexts, an object is known not to be a surrogate. For example, the re 75 ceiver object of a method is never a surrogate, nor is an object just produced by a constructor.
Reference: [18] <author> Greg Nelson, </author> <title> editor. Systems Programming with Modula-3. </title> <publisher> Prentice-Hall, </publisher> <year> 1991. </year>
Reference-contexts: Casting up can be performed by offsetting a pointer by a fixed constant. The details of this scheme will be examined in Chapter 2. A fifth object operation is provided by some object-oriented programming languages, such as Trellis/Owl [22, 23] and Modula-3 <ref> [18] </ref>. This is the operation of casting down the type hierarchy, sometimes provided as a typecase, and sometimes as a simple cast that is allowed to fail when the object is not of the desired type. <p> Dynamically-Typed Object-oriented programming languages are divided into two major camps: statically typed vs. dynamically typed. In the former camp are languages such as C++ [12], Modula-3 <ref> [18] </ref>, and Trellis/Owl [22]. In the latter are Smalltalk [13], Self [5], and Objective C [8]. Dynamically-typed languages provide greater polymorphism, since there is no type system to limit the kind of object that can be provided as a method argument.
Reference: [19] <author> John Plevyak and Andrew A. Chien. </author> <title> Incremental inference of concrete types. </title> <type> Technical Report UIUCDCS-R-93-1829, </type> <institution> Dept. of Computer Science, University of Illinois Urbana-Champagne, </institution> <year> 1993. </year>
Reference-contexts: A variable of an exact class must refer to an object of exactly that class, and not of any subclass. Knowledge about exact types can be propagated using dataflow techniques similar to those in the Illinois Concert compiler <ref> [19] </ref>. The source of knowledge about exact types is objects produced by constructors, where the precise implementation returned is known. However, this knowledge is lost as soon as control passes a method-dispatch boundary. Knowledge about exact types can be preserved only by customizing called procedures for different call sites.
Reference: [20] <author> William Pugh and Grant Weddell. </author> <title> Two-directional record layout for multiple inheritance. </title> <booktitle> In Proceedings of the SIGPLAN '90 Conference on Programming 80 Language Design and Implementation, </booktitle> <pages> pages 85-91, </pages> <address> White Plains, NY, </address> <month> June </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(6), </note> <month> June, </month> <year> 1990. </year>
Reference-contexts: Most fast dispatching schemes share a table or set of tables among all objects of a class. Some researchers have been concerned about making these tables as small as possible <ref> [11, 20] </ref>. However, since dispatch tables are shared, they consume a small fraction of memory, assuming that there are a reasonable number of objects per dispatch table. <p> Unfortunately, the problem of allocating method indices for all classes while minimizing the wasted dispatch table space is NP-hard [21]. Heuristics for index assignment have been developed that reduce the wasted space to about 6%, using two-directional record layout <ref> [20] </ref>. The wasted space in the object layout is less important than the dependency of the method assignments on the entire type hierarchy. This dependency may be acceptable when considered as a kind of global optimization in a small, non-extensible program.
Reference: [21] <author> William Pugh and Grant E. Weddell. </author> <title> On object layout for multiple inheritance. </title> ??, <month> pages ??-??, </month> <year> 1993. </year>
Reference-contexts: This approach requires assigning method indices based on a global analysis of the type hierarchy [11]. Unfortunately, the problem of allocating method indices for all classes while minimizing the wasted dispatch table space is NP-hard <ref> [21] </ref>. Heuristics for index assignment have been developed that reduce the wasted space to about 6%, using two-directional record layout [20]. The wasted space in the object layout is less important than the dependency of the method assignments on the entire type hierarchy.
Reference: [22] <author> Craig Schaffert, Topher Cooper, Bruce Bullis, Mike Kilian, and Carrie Wilpolt. </author> <title> An introduction to Trellis/Owl. </title> <booktitle> In OOPSLA '86 Conference Proceedings, </booktitle> <pages> pages 9-16, </pages> <address> Portland, OR, </address> <month> September </month> <year> 1986. </year>
Reference-contexts: Casting up can be performed by offsetting a pointer by a fixed constant. The details of this scheme will be examined in Chapter 2. A fifth object operation is provided by some object-oriented programming languages, such as Trellis/Owl <ref> [22, 23] </ref> and Modula-3 [18]. This is the operation of casting down the type hierarchy, sometimes provided as a typecase, and sometimes as a simple cast that is allowed to fail when the object is not of the desired type. <p> Dynamically-Typed Object-oriented programming languages are divided into two major camps: statically typed vs. dynamically typed. In the former camp are languages such as C++ [12], Modula-3 [18], and Trellis/Owl <ref> [22] </ref>. In the latter are Smalltalk [13], Self [5], and Objective C [8]. Dynamically-typed languages provide greater polymorphism, since there is no type system to limit the kind of object that can be provided as a method argument. However, these languages do not have the advantages of compile-time type-checking. <p> This implementation of Theta objects is written in C and runs on both Alpha-based and MIPS-based workstations from DEC. It supports dispatching on parameterized types <ref> [22, 16] </ref> as well as on the ordinary object types described here. To test the performance model described in Section 2.5.8, I measured the overhead incurred on the MIPS R3000 when using each of the standard method call mechanisms discussed here.
Reference: [23] <author> Craig Schaffert, Topher Cooper, and Carrie Wilpolt. </author> <title> Trellis object-based environment, language reference manual. </title> <type> Technical Report DEC-TR-372, </type> <institution> Digital Equipment Corporation, </institution> <month> November </month> <year> 1985. </year> <note> Published as SIGPLAN Notices 21(11), </note> <month> November, </month> <year> 1986. </year>
Reference-contexts: Casting up can be performed by offsetting a pointer by a fixed constant. The details of this scheme will be examined in Chapter 2. A fifth object operation is provided by some object-oriented programming languages, such as Trellis/Owl <ref> [22, 23] </ref> and Modula-3 [18]. This is the operation of casting down the type hierarchy, sometimes provided as a typecase, and sometimes as a simple cast that is allowed to fail when the object is not of the desired type.
Reference: [24] <author> Bjarne Stroustrup. </author> <title> Multiple inheritance for C++. </title> <booktitle> In Proceedings of the Spring '87 European Unix Systems Users's Group Conference, </booktitle> <address> Helsinki, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: In a system with multiple inheritance and method renaming, casting up must have some cost, as it changes the interface though which the object is viewed. Implementations of C++ have shown that allowing this operation to have a one-instruction cost can yield significant speedup in dispatching 17 <ref> [24] </ref>. An object reference can be represented as any of a number of distinct memory pointers, depending on the declared type of the object. Casting up can be performed by offsetting a pointer by a fixed constant. The details of this scheme will be examined in Chapter 2. <p> Dense assignment of method indices is desirable in order to make dispatch tables compact. 2.4.1 Embedded Objects and Pointer Offsets The dispatch table technique can be extended to solve the problem of colliding method indices by using multiple dispatch tables <ref> [24] </ref>. This is the technique used in the AT&T C++ 2.0 compiler and other C++ compilers. The basic idea is to embed superclass objects within the subclass format.
Reference: [25] <author> David Ungar, Craig Chambers, Bay-Wei Chang, and Urs Holzle. </author> <title> Organizing programs without classes. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 4(3), </volume> <month> June </month> <year> 1991. </year>
Reference-contexts: I explain how the Theta runtime system makes this optimization possible. 3.1 Related Work The technique of customization was pioneered in the language Self <ref> [26, 14, 25] </ref> to avoid the cost of dispatch entirely in many situations. The idea of customization is to generate multiple versions of the same piece of code, depending on the environment in which the code is needed.
Reference: [26] <author> David Ungar and Randall B. Smith. </author> <title> Self: The power of simplicity. </title> <booktitle> In OOPSLA '87 Conference Proceedings, </booktitle> <pages> pages 227-241, </pages> <address> Orlando, FL, </address> <month> October </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December, </month> <year> 1987. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June, </month> <year> 1991. </year> <month> 81 </month>
Reference-contexts: I explain how the Theta runtime system makes this optimization possible. 3.1 Related Work The technique of customization was pioneered in the language Self <ref> [26, 14, 25] </ref> to avoid the cost of dispatch entirely in many situations. The idea of customization is to generate multiple versions of the same piece of code, depending on the environment in which the code is needed.
References-found: 26

