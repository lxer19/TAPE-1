URL: http://www.cs.ucsb.edu/TRs/techreports/TRCS95-04.ps
Refering-URL: http://www.cs.ucsb.edu/TRs/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Title: Type Feedback vs. Concrete Type Inference: A Comparison of Optimization Techniques for Object-Oriented Languages  
Author: Ole Agesen Urs Hlzle 
Abstract: Two promising optimization techniques for object-oriented languages are type feedback (dynamic) and concrete type inference (static). We directly compare the two techniques, evaluating their effectiveness on a suite of 23 SELF programs while keeping other factors constant. Our results show that both systems inline &gt;95% of all sends and deliver similar overall performance with one exception: SELFs automatic coercion of machine integers to arbitrary-precision integers upon overow confounds type inference and slows down arithmetic-intensive benchmarks. We discuss several other issues which, given the comparable run-time performance, may inuence the choice between type feedback and type inference. 
Abstract-found: 1
Intro-found: 1
Reference: [Age94a] <author> Ole Agesen. </author> <title> Constraint-Based Type Inference and Parametric Polymorphism. </title> <booktitle> In SAS94, First International Static Analysis Symposium, </booktitle> <address> Namur, Belgium, </address> <month> September </month> <year> 1994. </year> <note> Springer-Verlag (LNCS 864). </note>
Reference-contexts: Expressed in terms of templates, polyvariance means that several templates may be created for a single method, with different sends invoking the method being routed to different templates. Several polyvariance strategies, varying widely in precision and efficiency, have been proposed; see <ref> [Age94a] </ref> for an overview. The strategy used in this paper, the Cartesian product algorithm, computes the Cartesian product of the actual argument types and analyzes each combination separately.
Reference: [Age94b] <author> Ole Agesen and David Ungar. </author> <title> Sifting Out the Gold: Delivering Compact Applications from an Object-Oriented Exploratory Programming Environment. </title> <booktitle> In OOPSLA'94, Object-Oriented Programming Systems, Languages and Applications, </booktitle> <address> Portland, OR, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: The interface between the two systems is a snapshot (image) containing a type-annotated benchmark program. We first modified the application extractor, described in <ref> [Age94b] </ref>, to output benchmark programs together with their type information. The normal functionality of the extractor is to identify a set of methods and objects that are sufficient to run a given application and write them out as SELF source code. <p> Since so many different aspects inuence space usage, we are not convinced that either system is inherently more space-efficient. Of course, type inference can significantly reduce program size through its use in program extraction <ref> [Age94b] </ref>. However, program extraction is performed in a separate step and can easily be used for application delivery with a type feedback based system (in fact, this is what our experimental implementation does). Source code protection.
Reference: [Age95] <author> Ole Agesen. </author> <title> The Cartesian Product Algorithm: Simple and Precise Type Inference of Parametric Polymor-phism. </title> <note> To be published at ECOOP95. </note>
Reference-contexts: The latter kind of type, though theoretically equivalent to -unknown-, is used by type feedback for reasons that will become clear shortly. The remainder of this section briey reviews type feedback and type inference; both systems have been described in more detail elsewhere ([Age94a], <ref> [Age95] </ref>, [HU94a], [Hl94]). 3 2.3 Type feedback The key idea of type feedback is to extract type information from previous executions and feed it back to the compiler (Figure 1). <p> Several polyvariance strategies, varying widely in precision and efficiency, have been proposed; see [Age94a] for an overview. The strategy used in this paper, the Cartesian product algorithm, computes the Cartesian product of the actual argument types and analyzes each combination separately. Details can be found in <ref> [Age95] </ref>. 2.5 Summary and Comparison Both type feedback and type inference operate with types that are sets of classes, and both systems produce types that are approximations. However, the approximations differ in nature. <p> Using the template array and several auxiliary arrays, the compiler searches for applicable method templates whenever it compiles a particular source method. In general, the type inferencer may generate more than one template per method, each of them for a particular combination of receiver or argument types <ref> [Age95] </ref>. Using its internal type information about the methods receiver and arguments, the compiler discards all templates that do not match (e.g., because they specify an incompatible receiver or argument type). <p> Obviously, inserting a global analysis into the edit-compile-run loop (or the edit-continue loop of the SELF system) will not go unnoticed by the programmer. The SELF type inference system supports incremental recomputation of the types when a previously analyzed program is modified locally <ref> [Age95] </ref>. <p> Traditional data-ow analysis techniques cannot be straightforwardly applied to object-oriented languages because the existence of a control-ow graph is assumed prior to analysis. The strength of the analyses mentioned above ([PS91], [PC94a], [PR94], and <ref> [Age95] </ref>) is that they acknowledge this problem up-front and solve a combined control-ow and data-ow problem.
Reference: [APS93] <author> Ole Agesen, Jens Palsberg, and Michael I. Schwartzbach. </author> <title> Type Inference of SELF: Analysis of Objects with Dynamic and Multiple Inheritance. </title> <booktitle> In ECOOP 93 Conference Proceedings, p. </booktitle> <pages> 247-267. </pages> <address> Kaiserslautern, Germany, </address> <month> July </month> <year> 1993. </year>
Reference: [CGZ94] <author> Brad Calder, Dirk Grunwald, and Benjamin Zorn. </author> <title> Quantifying Behavioral Differences Between C and C++ Programs. </title> <type> Technical Report CU-CS-698-94, </type> <institution> University of Colorado, Boulder, </institution> <month> January </month> <year> 1994. </year>
Reference: [CUL89] <author> Craig Chambers, David Ungar, and Elgin Lee. </author> <title> An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes. </title> <booktitle> In OOPSLA 89 Conference Proceedings, p. </booktitle> <pages> 49-70, </pages> <address> New Orleans, LA, </address> <month> October </month> <year> 1989. </year> <note> Published as SIGPLAN Notices 24(10), </note> <month> October </month> <year> 1989. </year>
Reference-contexts: Thus, the type inferencer benefits from the same local analysis that the standard system uses, so that the two can be fairly compared. The current SELF implementation requires that all methods be customized to their receiver <ref> [CUL89] </ref>, and thus methods will be customized to a specific receiver even if the type inferencer does not require it. Similarly, the run-time system does not support multiple dispatch, so that the compiler may have to merge some method templates that differ only in their argument types. <p> In contrast, type feedback requires a dispatch test even if it predicts a I.e., sends that do not require any dispatch. Examples include sends where type inference determined a single receiver class (but did not inline the send), or implicit-self sends (which require no dispatch because of customization <ref> [CUL89] </ref>). For example, the system using type feedback compiles methods in different order (since it adaptively optimizes the program [Hl94]) and thus generates a different set of methods. This graphs shows that all systems are very successful at inlining message sends; often, less than 5% of the original calls remain. <p> SELF compilers were the first ones to use type feedback for object-oriented programs [HCU91], [HU94a]. Other systems have used some form of runtime type information for optimization. For example, Mitchells system [Mit70] specialized arithmetic operations to the run-time types of the operands (similar to SELF-89s customization <ref> [CUL89] </ref>). Similarly, several APL compilers created specialized code for certain expressions (e.g. [Joh79], [Dyk77], [GW78]). The HP APL compiler [Dyk77] specialized compiled code according to the specific operand types (number of dimensions, size of each dimension, element type, etc.).
Reference: [CU90] <author> Craig Chambers and David Ungar. </author> <title> Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs. </title> <booktitle> In Proceedings of the SIGPLAN 90 Conference on Programming Language Design and Implementation, p. </booktitle> <pages> 150-164, </pages> <address> White Plains, NY, </address> <month> June </month> <year> 1990. </year> <note> Published as SIGPLAN Notices 25(6), </note> <month> June </month> <year> 1990. </year>
Reference-contexts: What is going on? The reason for the additional dispatch tests is subtle and requires a discussion of some details of the SELF-93 optimizing compiler. One of the optimizations it performs is message splitting <ref> [CU90] </ref>. Splitting avoids dispatches by copying parts of the control ow graph. In the code shown in the left half of Figure 7, the send of area requires a dispatch since its receiver could be either a circle or a square. <p> However, no data was given about the effectiveness of this approach. The SELF-91 compiler used iterative type analysis to eliminate dispatches <ref> [CU90] </ref>. Like the SELF-93 compiler used here, its analysis was local, i.e., restricted to a single method and the methods already inlined into it. However, its analysis was significantly more powerful than the simple analysis used in SELF-93.
Reference: [DGC94] <author> Jeffrey Dean, David Grove, and Craig Chambers. </author> <title> Optimization of object-oriented programs using static class hierarchy analysis. </title> <type> Technical Report CSE TR-94-12-01, </type> <institution> University of Washington, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: Whether or not it is advantageous to exploit such an opportunity is a non-trivial question (for an extensive discussion see <ref> [DGC94] </ref>). In SELF, as in Smalltalk, if statements are conceptually implemented by message sends. <p> If the code was invoked with incompatible types, a new version with less restrictive assumptions was generated (so-called soft code). Garrett et al. [Gar94] describe a compiler for the object-oriented language Cecil that uses type feedback in combination with static compilation to eliminate dynamically-dispatched calls. Dean et al. <ref> [DGC94] </ref> eliminate dynamic dispatch with a simple class hierarchy analysis that detects situations where a method has no overriding definition in any subclass of the sending method holder. <p> We have presented a detailed comparison of these two techniques. To our knowledge, this is the first in-depth comparison of a static and a dynamic optimization technique for object-oriented programs. Our comparison is particularly interesting for two reasons: The only exception being section 3.3 of <ref> [DGC94] </ref> which contains some quantitative data of a comparison of type feedback and class hierarchy analysis. 19 First, it is direct, because we eliminated other effects by using two identical compilers except for their source of receiver class information. Second, it is realistic, since the compared systems are high-quality implementations.
Reference: [DS84] <author> L. Peter Deutsch and Alan Schiffman. </author> <title> Efficient Implementation of the Smalltalk-80 System. </title> <booktitle> Proceedings of the 11th Symposium on the Principles of Programming Languages, </booktitle> <address> Salt Lake City, UT, </address> <year> 1984. </year>
Reference-contexts: Since optimized code usually 17 represents a fairly thorough obfuscation of the original source code, an application is well protected against reverse engineering or source code theft. A type feedback system (or any other system based on dynamic compilation <ref> [DS84] </ref>) needs a source code equivalent to execute new cases as they occur. Since typical byte codes are fairly high-level, an approximation of the original source code can be generated easily, and thus source code isnt as well protected. Generality.
Reference: [Dyk77] <author> Eric J. Van Dyke. </author> <title> A dynamic incremental compiler for an interpretative language. </title> <journal> HP Journal, </journal> <volume> p. </volume> <pages> 17-24, </pages> <month> July </month> <year> 1977. </year>
Reference-contexts: Other systems have used some form of runtime type information for optimization. For example, Mitchells system [Mit70] specialized arithmetic operations to the run-time types of the operands (similar to SELF-89s customization [CUL89]). Similarly, several APL compilers created specialized code for certain expressions (e.g. [Joh79], <ref> [Dyk77] </ref>, [GW78]). The HP APL compiler [Dyk77] specialized compiled code according to the specific operand types (number of dimensions, size of each dimension, element type, etc.). <p> For example, Mitchells system [Mit70] specialized arithmetic operations to the run-time types of the operands (similar to SELF-89s customization [CUL89]). Similarly, several APL compilers created specialized code for certain expressions (e.g. [Joh79], <ref> [Dyk77] </ref>, [GW78]). The HP APL compiler [Dyk77] specialized compiled code according to the specific operand types (number of dimensions, size of each dimension, element type, etc.). This so-called hard code could execute much more efficiently than more general versions since the cost of an APL operator varies greatly depending on the actual argument types.
Reference: [Gar94] <author> Charles D. Garrett, Jeffrey Dean, David Grove, and Craig Chambers. </author> <title> Measurement and Application of Dynamic Receiver Class Distributions. </title> <type> Technical Report CSE-TR-94-03-05, </type> <institution> University of Washington, </institution> <month> February </month> <year> 1994. </year>
Reference-contexts: If the code was invoked with incompatible types, a new version with less restrictive assumptions was generated (so-called soft code). Garrett et al. <ref> [Gar94] </ref> describe a compiler for the object-oriented language Cecil that uses type feedback in combination with static compilation to eliminate dynamically-dispatched calls.
Reference: [GW78] <author> Leo J. Guibas and Douglas K. Wyatt. </author> <title> Compilation and Delayed Evaluation in APL. </title> <booktitle> In Fifth Annual ACM Symposium on Principles of Programming Languages, p. </booktitle> <pages> 1-8, </pages> <year> 1978. </year>
Reference-contexts: Other systems have used some form of runtime type information for optimization. For example, Mitchells system [Mit70] specialized arithmetic operations to the run-time types of the operands (similar to SELF-89s customization [CUL89]). Similarly, several APL compilers created specialized code for certain expressions (e.g. [Joh79], [Dyk77], <ref> [GW78] </ref>). The HP APL compiler [Dyk77] specialized compiled code according to the specific operand types (number of dimensions, size of each dimension, element type, etc.).
Reference: [HCU91] <author> Urs Hlzle, Craig Chambers, and David Ungar. </author> <title> Optimizing Dynamically-Typed Object-Oriented Languages with Polymorphic Inline Caches. </title> <booktitle> In ECOOP91 Conference Proceedings, Geneva, 1991. Published as Springer Verlag Lecture Notes in Computer Science 512, </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: We include both inlined and non-inlined dispatches because both introduce similar overhead. The SELF system implements all dispatches via type test sequences which sequentially compare the receiver against predicted classes. For non-inlined sends, the type test is part of an inline cache or polymorphic inline cache <ref> [HCU91] </ref>, and for inlined sends it surrounds the inlined code (see Section 2.3). Type inference can determine the exact receiver class for many sends. Since such sends no longer require a dispatch, the overall number of dispatches is reduced. <p> However, its analysis was significantly more powerful than the simple analysis used in SELF-93. SELF compilers were the first ones to use type feedback for object-oriented programs <ref> [HCU91] </ref>, [HU94a]. Other systems have used some form of runtime type information for optimization. For example, Mitchells system [Mit70] specialized arithmetic operations to the run-time types of the operands (similar to SELF-89s customization [CUL89]). Similarly, several APL compilers created specialized code for certain expressions (e.g. [Joh79], [Dyk77], [GW78]).
Reference: [Hl94] <author> Urs Hlzle. </author> <title> Adaptive Optimization in SELF: Reconciling High Performance with Exploratory Programming. </title> <type> Ph.D. Thesis, </type> <institution> Department of Computer Science, Stanford University, </institution> <year> 1994. </year> <note> (Available via ftp/http from self.stanford.edu.) </note>
Reference-contexts: The latter kind of type, though theoretically equivalent to -unknown-, is used by type feedback for reasons that will become clear shortly. The remainder of this section briey reviews type feedback and type inference; both systems have been described in more detail elsewhere ([Age94a], [Age95], [HU94a], <ref> [Hl94] </ref>). 3 2.3 Type feedback The key idea of type feedback is to extract type information from previous executions and feed it back to the compiler (Figure 1). This feedback can happen dynamically (i.e., while the program is running) or statically (after execution completed, as in traditional profile-based optimization). <p> Systems used in the study 8 As we will see later (in section 3.5), TI usually removes more dispatches than TF, and that is the main reason for TIs reduced execution time. SELF programs typically spend about 15% of their execution time in type tests implementing message dispatch <ref> [Hl94] </ref> which agrees well with the speedups measured here. Of course, other factors may also contribute to performance differences (e.g., instruction cache misses) but a detailed analysis is beyond the scope of this paper. Although execution speed is important, it only summarizes the final outcome of many interacting processes. <p> Examples include sends where type inference determined a single receiver class (but did not inline the send), or implicit-self sends (which require no dispatch because of customization [CUL89]). For example, the system using type feedback compiles methods in different order (since it adaptively optimizes the program <ref> [Hl94] </ref>) and thus generates a different set of methods. This graphs shows that all systems are very successful at inlining message sends; often, less than 5% of the original calls remain. The graph exaggerates the differences between the systems somewhat since the absolute number of calls is often small. <p> Type feedback based systems, in contrast, contain code only for paths that were actually executed, i.e., for only a subset of all possible program executions. (Programs do include additional checks and trap instructions to cover unexpected cases <ref> [Hl94] </ref>, but this code contributes little to the overall code size.) To cover all other executions, a type feedback system needs to include an interpreter or compiler at an additional space cost of as little as 20 Kbytes for a Smalltalk byte-code interpreter [Kra83] or as much as 800 Kbytes for <p> contributes little to the overall code size.) To cover all other executions, a type feedback system needs to include an interpreter or compiler at an additional space cost of as little as 20 Kbytes for a Smalltalk byte-code interpreter [Kra83] or as much as 800 Kbytes for an optimizing compiler <ref> [Hl94] </ref>. For smaller applications, the fixed cost of the interpreter or compiler will tilt the scales toward type inference, whereas larger applications will tend to favor type feedback. Since so many different aspects inuence space usage, we are not convinced that either system is inherently more space-efficient.
Reference: [HU94a] <author> Urs Hlzle and David Ungar. </author> <title> Optimizing Dynamically-Dispatched Calls with Run-Time Type Feedback. </title> <booktitle> In Proceedings of the SIGPLAN 94 Conference on Programming Language Design and Implementation, p. </booktitle> <pages> 326-336. </pages> <note> Published as SIGPLAN Notices 29(6), </note> <month> June </month> <year> 1994. </year>
Reference-contexts: Type inference may generate better code because it can completely eliminate dispatch for many message sends. Previous studies have reported the effectiveness of type inference and type feedback (e.g., [PC94a] and <ref> [HU94a] </ref>) but direct comparisons have been impossible because important other factors were different, including programming language, compiler technology, and choice of benchmarks. <p> same compiler back end, use the same run-time system, and execute the same suite of benchmarks in both cases; and realistic, because both the type feedback system and the type inferencer represent high-quality implementations of these concepts (the underlying SELF-93 system has been shown to significantly outperform commercial Smalltalk implementations <ref> [HU94a] </ref>). In the remainder of this paper, we briey summarize the two techniques (section 2), quantitatively compare them step by step (section 3), and qualitatively discuss their relative strengths and weaknesses (section 4). We then review related work (section 5) and finally offer our conclusions (section 6). 2. <p> The latter kind of type, though theoretically equivalent to -unknown-, is used by type feedback for reasons that will become clear shortly. The remainder of this section briey reviews type feedback and type inference; both systems have been described in more detail elsewhere ([Age94a], [Age95], <ref> [HU94a] </ref>, [Hl94]). 3 2.3 Type feedback The key idea of type feedback is to extract type information from previous executions and feed it back to the compiler (Figure 1). This feedback can happen dynamically (i.e., while the program is running) or statically (after execution completed, as in traditional profile-based optimization). <p> Inlining the moveTo method not only eliminates the calling overhead but also enables the compiler to optimize the inlined code using dataow information particular to this call site. The implementation of type feedback in the SELF-93 optimizing compiler has been described elsewhere ([Hl94], <ref> [HU94a] </ref>). With type feedback, the SELF-93 compiler can inline more message sends and achieve better performance than previous compilers [HU94a]. For example, SELF-93 executes a suite of three medium-sized (400-1,100 lines) and six large (4,000-15,000 lines) programs 1.5 times faster than the SELF-91 compiler [HU94a]. <p> The implementation of type feedback in the SELF-93 optimizing compiler has been described elsewhere ([Hl94], <ref> [HU94a] </ref>). With type feedback, the SELF-93 compiler can inline more message sends and achieve better performance than previous compilers [HU94a]. For example, SELF-93 executes a suite of three medium-sized (400-1,100 lines) and six large (4,000-15,000 lines) programs 1.5 times faster than the SELF-91 compiler [HU94a]. For two medium-sized programs that are also available in Smalltalk, SELF-93 is about three times faster than ParcPlace Smalltalk. <p> compiler has been described elsewhere ([Hl94], <ref> [HU94a] </ref>). With type feedback, the SELF-93 compiler can inline more message sends and achieve better performance than previous compilers [HU94a]. For example, SELF-93 executes a suite of three medium-sized (400-1,100 lines) and six large (4,000-15,000 lines) programs 1.5 times faster than the SELF-91 compiler [HU94a]. For two medium-sized programs that are also available in Smalltalk, SELF-93 is about three times faster than ParcPlace Smalltalk. In contrast to a type inference system (and to previous SELF systems), SELF-93 performs very little dataow (or type-ow) analysis in an effort to keep the compiler small and fast. <p> Similarly, the run-time system does not support multiple dispatch, so that the compiler may have to merge some method templates that differ only in their argument types. To evaluate type feedback, we used an essentially unmodified version of the current SELF system which is based on the SELF-93 compiler <ref> [HU94a] </ref>. <p> However, its analysis was significantly more powerful than the simple analysis used in SELF-93. SELF compilers were the first ones to use type feedback for object-oriented programs [HCU91], <ref> [HU94a] </ref>. Other systems have used some form of runtime type information for optimization. For example, Mitchells system [Mit70] specialized arithmetic operations to the run-time types of the operands (similar to SELF-89s customization [CUL89]). Similarly, several APL compilers created specialized code for certain expressions (e.g. [Joh79], [Dyk77], [GW78]). <p> Second, it is realistic, since the compared systems are high-quality implementations. Both are based on the SELF-93 system which has been shown to provide excellent performance compared to a commercial Smalltalk implementation <ref> [HU94a] </ref>. Finally, although the quantitative results are of course specific to SELF, they may nevertheless be interesting to implementors of other languages.
Reference: [HU94b] <author> Urs Hlzle and David Ungar. </author> <title> A Third-Generation SELF Implementation: Reconciling Responsiveness with Performance. </title> <booktitle> OOPSLA 94 Conference Proceedings, p. </booktitle> <pages> 229-243, </pages> <address> Portland, OR, </address> <month> October </month> <year> 1994. </year> <note> Published as SIGPLAN Notices 29(10), </note> <month> October </month> <year> 1994. </year>
Reference-contexts: The goal was met largely due to the incremental nature of type feedback: type information is computed gradually and methods can be compiled one at a time (after inline expansion, of course) <ref> [HU94b] </ref>. On the other hand, the style of type inference used in this work is fundamentally a global analysis: the unit analyzed is an entire program. Obviously, inserting a global analysis into the edit-compile-run loop (or the edit-continue loop of the SELF system) will not go unnoticed by the programmer.
Reference: [JGZ88] <author> Ralph Johnson, Justin Graver, and Lawrence Zurawski. </author> <title> TS: An optimizing compiler for Smalltalk. </title> <booktitle> In OOPSLA 88 Conference Proceedings, </booktitle> <address> San Diego, CA, </address> <month> October </month> <year> 1988. </year> <month> 21 </month>
Reference-contexts: Unfortunately, Suzuki was unable to fully implement his system within the limited heap space of Smalltalk-76 and only managed to test a simplified version of the inference algorithm on some of the number classes. The Typed Smalltalk project <ref> [JGZ88] </ref> incorporated a type inferencer for Smalltalk which relied on explicit type declarations inserted by the programmer; these types were specified as sets of classes. (A second, more abstract kind of type was provided for type checking but was not used by the compiler).
Reference: [Joh79] <author> Ronald L. Johnston. </author> <title> The Dynamic Incremental Compiler of APL"3000. In Proceedings of the APL 79 Conference. </title> <note> Published as APL Quote Quad 9(4), </note> <author> p. </author> <month> 82-87, </month> <year> 1979. </year>
Reference-contexts: Other systems have used some form of runtime type information for optimization. For example, Mitchells system [Mit70] specialized arithmetic operations to the run-time types of the operands (similar to SELF-89s customization [CUL89]). Similarly, several APL compilers created specialized code for certain expressions (e.g. <ref> [Joh79] </ref>, [Dyk77], [GW78]). The HP APL compiler [Dyk77] specialized compiled code according to the specific operand types (number of dimensions, size of each dimension, element type, etc.).
Reference: [Kra83] <author> Glenn Krasner, ed., </author> <title> Smalltalk-80: Bits of History and Words of Advice. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1983. </year>
Reference-contexts: and trap instructions to cover unexpected cases [Hl94], but this code contributes little to the overall code size.) To cover all other executions, a type feedback system needs to include an interpreter or compiler at an additional space cost of as little as 20 Kbytes for a Smalltalk byte-code interpreter <ref> [Kra83] </ref> or as much as 800 Kbytes for an optimizing compiler [Hl94]. For smaller applications, the fixed cost of the interpreter or compiler will tilt the scales toward type inference, whereas larger applications will tend to favor type feedback.
Reference: [Mit70] <author> J. G. Mitchell, </author> <title> Design and Construction of Flexible and Efficient Interactive Programming Systems. </title> <type> Ph.D. Thesis, </type> <institution> Carnegie-Mellon University, </institution> <year> 1970. </year>
Reference-contexts: However, its analysis was significantly more powerful than the simple analysis used in SELF-93. SELF compilers were the first ones to use type feedback for object-oriented programs [HCU91], [HU94a]. Other systems have used some form of runtime type information for optimization. For example, Mitchells system <ref> [Mit70] </ref> specialized arithmetic operations to the run-time types of the operands (similar to SELF-89s customization [CUL89]). Similarly, several APL compilers created specialized code for certain expressions (e.g. [Joh79], [Dyk77], [GW78]).
Reference: [OPS92] <author> Nicholas Oxhj, Jens Palsberg and Michael I. Schwartzbach. </author> <title> Making Type Inference Practical. </title> <booktitle> In ECOOP92 Conference Proceedings, Utrecht, The Netherlands, 1991. Published as Springer Verlag Lecture Notes in Computer Science 615, </booktitle> <publisher> Springer Verlag, </publisher> <address> Berlin, </address> <year> 1991. </year>
Reference-contexts: Unfortunately, the system was not completed and the only published performance data concerned very small integer programs similar to our Tiny benchmark set. More recently, Palsberg and Schwartzbach described a constraint-based analysis system for a Smalltalk-like toy language [PS91], which was improved and implemented in cooperation with Oxhj <ref> [OPS92] </ref>. Palsberg and Schwartz-bach suggested the use of their types for optimization but did not implement such a system. The type inferencer used here is a further development of the ideas originally proposed by Palsberg and Schwartzbach.
Reference: [PS91] <author> Jens Palsberg and Michael I. Schwartzbach. </author> <title> Object-Oriented Type Inference. </title> <booktitle> In OOPSLA'91, ACM SIGPLAN Sixth Annual Conference on Object-Oriented Programming Systems, Languages and Applications, </booktitle> <address> Phoenix, Arizona, </address> <month> October </month> <year> 1991. </year>
Reference-contexts: Unfortunately, the system was not completed and the only published performance data concerned very small integer programs similar to our Tiny benchmark set. More recently, Palsberg and Schwartzbach described a constraint-based analysis system for a Smalltalk-like toy language <ref> [PS91] </ref>, which was improved and implemented in cooperation with Oxhj [OPS92]. Palsberg and Schwartz-bach suggested the use of their types for optimization but did not implement such a system. The type inferencer used here is a further development of the ideas originally proposed by Palsberg and Schwartzbach.
Reference: [PR94] <author> Hemant D. Pande and Barbara G. Ryder. </author> <title> Static Type Determination and Aliasing for C++. </title> <type> Technical Report LCSR-TR-236, </type> <institution> Rutgers University, </institution> <month> December </month> <year> 1994. </year>
Reference-contexts: Recently, Pande and Ryder have made progress in extending data-ow techniques to C++ <ref> [PR94] </ref>. The main goal of their work is to extend dataow analysis techniques to solve static analysis problems for C++. <p> On the other hand, C++ does not have user-defined control structures, closures, or dynamic inheritance. Preliminary results indicate that their technique can eliminate a significant fraction of dispatches in small C++ programs containing a few dozen call sites <ref> [PR94] </ref>. Traditional data-ow analysis techniques cannot be straightforwardly applied to object-oriented languages because the existence of a control-ow graph is assumed prior to analysis. The strength of the analyses mentioned above ([PS91], [PC94a], [PR94], and [Age95]) is that they acknowledge this problem up-front and solve a combined control-ow and data-ow problem. <p> can eliminate a significant fraction of dispatches in small C++ programs containing a few dozen call sites <ref> [PR94] </ref>. Traditional data-ow analysis techniques cannot be straightforwardly applied to object-oriented languages because the existence of a control-ow graph is assumed prior to analysis. The strength of the analyses mentioned above ([PS91], [PC94a], [PR94], and [Age95]) is that they acknowledge this problem up-front and solve a combined control-ow and data-ow problem.
Reference: [PC94a] <author> John B. Plevyak and Andrew A. Chien. </author> <title> Precise Concrete Type Inference for Object-Oriented Languages. </title> <booktitle> In OOPSLA'94, Object-Oriented Programming Systems, Languages and Applications, </booktitle> <address> Portland, OR, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: Type inference may generate better code because it can completely eliminate dispatch for many message sends. Previous studies have reported the effectiveness of type inference and type feedback (e.g., <ref> [PC94a] </ref> and [HU94a]) but direct comparisons have been impossible because important other factors were different, including programming language, compiler technology, and choice of benchmarks. <p> The type inferencer used here is a further development of the ideas originally proposed by Palsberg and Schwartzbach. Plevyak and Chien independently improved Palsberg and Schwartzbachs algorithm for Concurrent Aggregates (CA), a concurrent, single-inheritance, dynamically-typed object-oriented language <ref> [PC94a] </ref>. Their system employs an iterative analysis which in each iteration uses the types from the previous iteration to guide the analysis.The inference algorithm can clone classes during analysis to obtain high precision on code with data polymorphism. (Our algorithm is less precise in this regard. <p> Traditional data-ow analysis techniques cannot be straightforwardly applied to object-oriented languages because the existence of a control-ow graph is assumed prior to analysis. The strength of the analyses mentioned above ([PS91], <ref> [PC94a] </ref>, [PR94], and [Age95]) is that they acknowledge this problem up-front and solve a combined control-ow and data-ow problem.
Reference: [PC94b] <author> John B. Plevyak and Andrew A. Chien. </author> <title> Precise Concrete Type Inference and its Use in Program Optimization. </title> <type> Unpublished report, </type> <month> October </month> <year> 1994. </year>
Reference: [PC94c] <author> John B. Plevyak and Andrew A. Chien. </author> <title> Efficient cloning to eliminate dynamic dispatch in object-oriented languages. </title> <type> Unpublished report, </type> <month> December </month> <year> 1994. </year>
Reference: [PZC95] <author> John B. Plevyak, Xingbin Zhang, and Andrew A. Chien. </author> <title> Obtaining sequential efficiency for concurrent object-oriented languages. </title> <booktitle> In Proceedings of the 22nd Symposium on Principles of Programming Languages, </booktitle> <address> San Francisco, CA, </address> <month> January </month> <year> 1995. </year>
Reference-contexts: It only clones classes based on observing initial values of their instances). Plevyak and Chiens type inferencer has been used in the CA compiler to eliminate dispatches in the (non-object-oriented) Livermore Loops <ref> [PZC95] </ref> and in object-oriented CA programs [PC94b][PC94c]. In the latter two studies, the compiler was able to completely eliminate dynamic dispatch in six of the nine benchmark programs.
Reference: [Suz81] <author> Norihisa Suzuki. </author> <title> Inferring Types in Smalltalk. </title> <booktitle> In Conference Record of the Eighth Annual ACM Symposium on Principles of Programming Languages, p. </booktitle> <pages> 227-241, </pages> <year> 1981. </year>
Reference-contexts: Adapting concrete type inference to work in such an environment remains a major technical challenge. 5. Related work Type inference for dynamically-typed object-oriented languages has been an active field since the early eighties. Suzuki pioneered the field in the Smalltalk community <ref> [Suz81] </ref>. He also used sets of classes as his basic types and had the same goal of eliminating dynamic dispatch to improve execution efficiency.
Reference: [US87] <author> David Ungar and Randall B. Smith. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings, p. </booktitle> <pages> 227-241, </pages> <address> Orlando, FL, </address> <month> October </month> <year> 1987. </year> <note> Published as SIGPLAN Notices 22(12), </note> <month> December </month> <year> 1987. </year> <title> Also published in Lisp and Symbolic Computation 4(3), </title> <publisher> Kluwer Academic Publishers, </publisher> <month> June </month> <year> 1991. </year>
Reference-contexts: We then review related work (section 5) and finally offer our conclusions (section 6). 2. Background 2.1 SELF SELF <ref> [US87] </ref> is a pure object-oriented language: all data are objects, and all computation is performed via dynamically-bound message sends (including all instance variable accesses, integer arithmetic, and control structures like if and while).
Reference: [VHU92] <author> Jan Vitek, R. Nigel Horspool and James S. Uhl. </author> <title> Compile-time Analysis of Object-Oriented Programs. </title> <booktitle> In Proceedings of CC92, 4th International Conference on Compiler Construction, Paderborn, Germany, </booktitle> <pages> pages 236-250. </pages> <publisher> Springer-Verlag (LNCS 641), </publisher> <year> 1992. </year> <month> 22 </month>
Reference-contexts: The strength of the analyses mentioned above ([PS91], [PC94a], [PR94], and [Age95]) is that they acknowledge this problem up-front and solve a combined control-ow and data-ow problem. Vitek et al. demonstrated that this can also be achieved in a data-ow framework <ref> [VHU92] </ref>: for each program point, they computed an abstract object graph, a sufficiently detailed approximation of the full program heap to allow simulation of lookups. However, no data was given about the effectiveness of this approach. The SELF-91 compiler used iterative type analysis to eliminate dispatches [CU90].
References-found: 30

