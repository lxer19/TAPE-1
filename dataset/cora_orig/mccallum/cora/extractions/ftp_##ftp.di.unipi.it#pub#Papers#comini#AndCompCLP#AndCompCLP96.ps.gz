URL: ftp://ftp.di.unipi.it/pub/Papers/comini/AndCompCLP/AndCompCLP96.ps.gz
Refering-URL: http://www.di.unipi.it/di/groups/lp/papers.html
Root-URL: 
Email: fbagnara;comini;scozzari;zaffanelg@di:unipi:it  
Title: The AND-compositionality of CLP computed answer constraints.  
Author: Roberto Bagnara, Marco Comini, Francesca Scozzari and Enea Zaffanella 
Address: Corso Italia 40, 56125 Pisa, Italy  
Affiliation: Dipartimento di Informatica, Universita di Pisa,  
Abstract: We present a semantic characterization of CLP languages for the class of quick-checking systems. We define a semantics of computed answer constraints which is AND-compositional, does not loose the distinction between active and passive constraints in the answers and has both a top-down and a bottom-up characterization. We also show that an incrementality property we impose on the constraint solver is essential in order to define an AND-compositional atom-based semantics. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Bagnara. </author> <title> A hierarchy of constraint systems for data-flow analysis of constraint logic-based languages. </title> <type> Technical Report TR-96-10, </type> <institution> Dipartimento di Informatica, Universita di Pisa, </institution> <year> 1996. </year> <note> To appear on a special issue of "Science of Computer Programming". </note>
Reference-contexts: The semantic treatment presented in this paper is not the only way to characterize CLP systems employing incomplete constraint solvers. For instance, the delay mechanism can be captured at the constraint system level, instead of carrying over a distinguished set of delayed (or passive) constraints in the semantics. In <ref> [1] </ref> a class of constraint systems is introduced, where constraints are cc agents [8].
Reference: [2] <author> A. Bossi, M. Gabbrielli, G. Levi, and M. Martelli. </author> <title> The s-semantics approach: </title> <journal> Theory and applications. Journal of Logic Programming, </journal> <volume> 19-20:149-197, </volume> <year> 1994. </year>
Reference-contexts: The availability of such a mechanism is the well-known AND -compositionality property of the semantics. Hence, the top-down semantics can be defined using the s-semantics atom-based style <ref> [2] </ref>. Definition 3.1 Let P be a fixed program, p range over the set of predicate symbols and x be a tuple of distinct variables.
Reference: [3] <author> M. Comini and G. Levi. </author> <title> An algebraic theory of observables. </title> <editor> In M. Bruynooghe, editor, </editor> <booktitle> Proceedings of the 1994 Int'l Symposium on Logic Programming, </booktitle> <pages> pages 172-186. </pages> <publisher> The MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1994. </year>
Reference-contexts: If we are interested in complete constraint solvers only, then the semantics defined in [6] boils down to the CLP version of the s-semantics [4]. In this case the AND - compositionality problem has been deeply studied, even with respect to a much more concrete semantics, yielding stronger results <ref> [3] </ref>.
Reference: [4] <author> M. Gabbrielli, G. M. Dore, and G. Levi. </author> <title> Observable semantics for constraint logic programs. </title> <journal> J. Logic Computation, </journal> <volume> 5(2) </volume> <pages> 133-171, </pages> <year> 1995. </year>
Reference-contexts: For instance, the arithmetic solver employed in the CLP (R) system [7] deals only with linear constraints, whereas non-linear ones are delayed. The languages truly implemented by these "real systems" are not captured by standard semantics constructions such as the original one of [5] and its refinements <ref> [4] </ref>. These semantics, indeed, refer to the ideal domain of computation, thus pretending that the system is endowed with a complete solver. <p> If we are interested in complete constraint solvers only, then the semantics defined in [6] boils down to the CLP version of the s-semantics <ref> [4] </ref>. In this case the AND - compositionality problem has been deeply studied, even with respect to a much more concrete semantics, yielding stronger results [3].
Reference: [5] <author> J. Jaffar and J. L. Lassez. </author> <title> Constraint Logic Programming. </title> <booktitle> In Proc. Fourteenth Annual ACM Symp. on Principles of Programming Languages, </booktitle> <pages> pages 111-119. </pages> <publisher> ACM, </publisher> <year> 1987. </year>
Reference-contexts: For instance, the arithmetic solver employed in the CLP (R) system [7] deals only with linear constraints, whereas non-linear ones are delayed. The languages truly implemented by these "real systems" are not captured by standard semantics constructions such as the original one of <ref> [5] </ref> and its refinements [4]. These semantics, indeed, refer to the ideal domain of computation, thus pretending that the system is endowed with a complete solver.
Reference: [6] <author> J. Jaffar and M. J. Maher. </author> <title> Constraint logic programming: A survey. </title> <journal> Journal of Logic Programming, </journal> <volume> 19-20:503-581, </volume> <year> 1994. </year>
Reference-contexts: 1 Introduction The semantics of CLP languages presented in <ref> [6] </ref> is (at least in its intentions) very general. Real CLP systems, in fact, are often equipped with incomplete constraint solvers and delay mechanisms. For instance, the arithmetic solver employed in the CLP (R) system [7] deals only with linear constraints, whereas non-linear ones are delayed. <p> These semantics, indeed, refer to the ideal domain of computation, thus pretending that the system is endowed with a complete solver. The idea of <ref> [6] </ref> consists in parameterizing the semantics construction with respect to the constraint system and two functions modeling the inferential power of the system's constraint solver and the delay mechanisms employed. <p> The consistent function models the solver's ability of detecting the unsatis-fiability of the constraint store. Despite this nice idea, the semantics of <ref> [6] </ref> has several drawbacks: * The semantics is defined only for most-general atomic goals. However, it is not clear how it can be used to recover the computed answers for general goals. Indeed, this is not possible in the setting of [6] since the constraint solver is not assumed to be <p> Despite this nice idea, the semantics of <ref> [6] </ref> has several drawbacks: * The semantics is defined only for most-general atomic goals. However, it is not clear how it can be used to recover the computed answers for general goals. Indeed, this is not possible in the setting of [6] since the constraint solver is not assumed to be incremental. <p> Indeed, they exhibit a quite different behavior: in response to the query ?- p (Y) the first one yields the answer Y = 2 whereas, for the second one, the system's answer is Y*Y =4 Maybe, indicating that the constraint is still passive. Moreover, the operational semantics of <ref> [6] </ref> makes use also of the logical-truth relation on the (idealized) constraint domain, which is undesirable. * The bottom-up characterization of computed answers is given only for the ideal systems (i.e., those endowed with a complete constraint solver). <p> In this work we present a semantic characterization of CLP languages which overcomes the limitations of the one given in <ref> [6] </ref>. <p> We also show that the incrementality assumption on the constraint solver is so reasonable that it is impossible, without it, to define an atom-based semantics which is both AND -compositional and independent from the computation rule. 2 Preliminaries In this section, following <ref> [6] </ref>, we briefly review the basic syntax and semantics of constraint systems and CLP languages. A signature is a set of function and predicate symbols with arities. A -formula is built from variables, function and predicate symbols in by using the classical first order logical connectives and quantifiers. <p> This is made possible by parameterizing the semantic construction with respect to functions which model the behavior of the actual constraint solver employed. This idea is due to <ref> [6] </ref>. However, the semantics presented in [6] suffers from several drawbacks. We have overcome these limitations, presenting a semantics for quick-checking systems which is AND -compositional (under the assumption of incre-mentality of the constraint solver), captures both active and passive constraints, and has natural top-down and bottom-up construction processes. <p> This is made possible by parameterizing the semantic construction with respect to functions which model the behavior of the actual constraint solver employed. This idea is due to <ref> [6] </ref>. However, the semantics presented in [6] suffers from several drawbacks. We have overcome these limitations, presenting a semantics for quick-checking systems which is AND -compositional (under the assumption of incre-mentality of the constraint solver), captures both active and passive constraints, and has natural top-down and bottom-up construction processes. Our incrementality assumption (which is missing in [6]) <p> <ref> [6] </ref> suffers from several drawbacks. We have overcome these limitations, presenting a semantics for quick-checking systems which is AND -compositional (under the assumption of incre-mentality of the constraint solver), captures both active and passive constraints, and has natural top-down and bottom-up construction processes. Our incrementality assumption (which is missing in [6]) does not exclude any reasonable system. Moreover, we have shown that if the incrementality assumption does not hold then no atom-based semantics can be both AND -compositional and independent from the computation rule. <p> If we are interested in complete constraint solvers only, then the semantics defined in <ref> [6] </ref> boils down to the CLP version of the s-semantics [4]. In this case the AND - compositionality problem has been deeply studied, even with respect to a much more concrete semantics, yielding stronger results [3].
Reference: [7] <author> J. Jaffar, S. Michaylov, P. Stuckey, and R. Yap. </author> <title> The CLP(R) Language and System. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 14(3) </volume> <pages> 339-395, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction The semantics of CLP languages presented in [6] is (at least in its intentions) very general. Real CLP systems, in fact, are often equipped with incomplete constraint solvers and delay mechanisms. For instance, the arithmetic solver employed in the CLP (R) system <ref> [7] </ref> deals only with linear constraints, whereas non-linear ones are delayed. The languages truly implemented by these "real systems" are not captured by standard semantics constructions such as the original one of [5] and its refinements [4].
Reference: [8] <author> V. A. Saraswat. </author> <title> Concurrent Constraint Programming. </title> <publisher> MIT Press, </publisher> <address> Cambridge, Mass., </address> <year> 1993. </year>
Reference-contexts: For instance, the delay mechanism can be captured at the constraint system level, instead of carrying over a distinguished set of delayed (or passive) constraints in the semantics. In [1] a class of constraint systems is introduced, where constraints are cc agents <ref> [8] </ref>.
References-found: 8

