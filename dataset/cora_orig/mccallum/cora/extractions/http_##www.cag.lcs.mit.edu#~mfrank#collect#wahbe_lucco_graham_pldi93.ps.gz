URL: http://www.cag.lcs.mit.edu/~mfrank/collect/wahbe_lucco_graham_pldi93.ps.gz
Refering-URL: http://www.cag.lcs.mit.edu/compiler/topics.april.7.html
Root-URL: 
Email: Email: frwahbe, lucco, grahamg@cs.berkeley.edu  
Title: Practical Data Breakpoints: Design and Implementation tion using a segmented bitmap achieved an average overhead
Author: Robert Wahbe Steven Lucco Susan L. Graham 
Date: June 23-25 1993.  
Note: This research was sponsored in part by the Defense Advanced Research Projects Agency under grant MDA972-92-J-1028 and contract DABT63-92-C-0026. The content of the paper does not necessarily reflect the position or the policy of the Government and no official endorsement should be inferred.  To appear in Proceedings of the ACM SIGPLAN'93 Symposium on Programming Language Design and Implementation, Albuquerque, NM,  to 25%.  
Address: 571 Evans Hall UC Berkeley, Berkeley CA, 94720  
Affiliation: Computer Science Division,  
Abstract: A data breakpoint associates debugging actions with programmer-specified conditions on the memory state of an executing program. Data breakpoints provide a means for discovering program bugs that are tedious or impossible to isolate using control breakpoints alone. In practice, programmers rarely use data break-points, because they are either unimplemented or prohibitively slow in available debugging software. In this paper, we present the design and implementation of a practical data breakpoint facility. A data breakpoint facility must monitor all memory updates performed by the program being debugged. We implemented and evaluated two complementary techniques for reducing the overhead of monitoring memory updates. First, we checked write instructions by inserting checking code directly into the program being debugged. The checks use a segmented bitmap data structure that minimizes address lookup complexity. Second, we developed data flow algorithms that eliminate checks on some classes of write instructions but may increase the complexity of the remaining checks. We evaluated these techniques on the Sparc using the spec benchmarks. Checking each write instruc 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. Adl-Tabatabai and T. Gross. </author> <title> "Detection and Recovery of Endangered Variables Caused by Instruction Scheduling,". </title> <booktitle> In Programming Language Design and Implementation, </booktitle> <year> 1993. </year>
Reference-contexts: Consider that 14% overhead represents only about 50 seconds for a program that normally runs for 6 minutes. For compute intensive applications, improving the naive compilation typically used during debugging would have more performance impact than reserving registers for segment caching <ref> [1, 2, 9] </ref>. In particular, register allocation would speed program execution, while reducing the number of write checks.
Reference: [2] <author> A. Adl-Tabatabai and T. Gross. </author> <title> "Evicted Variables and the Interaction of Global Register and Symbolic Debugging,". </title> <booktitle> In Principles of Programming Languages, </booktitle> <pages> pages 371-383, </pages> <year> 1993. </year>
Reference-contexts: Consider that 14% overhead represents only about 50 seconds for a program that normally runs for 6 minutes. For compute intensive applications, improving the naive compilation typically used during debugging would have more performance impact than reserving registers for segment caching <ref> [1, 2, 9] </ref>. In particular, register allocation would speed program execution, while reducing the number of write checks.
Reference: [3] <author> B. Beander. </author> <title> "Vax DEBUG: an Interactive, Symbolic, Multilingual Debugger,". </title> <booktitle> In Proceedings of the ACM SIGSOFT/SIGPLAN Software Engineering Symposium on High-Level Debugging, </booktitle> <pages> pages 173-179, </pages> <month> August </month> <year> 1983. </year> <note> Appeared as SIGPLAN Notices 18(8). </note>
Reference-contexts: Due to context switch and trap costs, this approach incurs very high overhead. We measured the overhead of dbx to be a factor of 85,000, independent of the program being debugged. VAX DEBUG provides data breakpoints using virtual memory page protection <ref> [3] </ref>. Like gdb and dbx, VAX DEBUG assumes that all instructions are unsafe. However, rather than check each instruction, VAX DEBUG protects each virtual memory page containing data that is part of a data break condition.
Reference: [4] <author> T. Cargill and B. Locanthi. </author> <title> "Cheap Hardware Support for Software Debugging and Profiling,". </title> <booktitle> In Proceedings of the Second International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 82-83, </pages> <month> October </month> <year> 1987. </year> <note> Appeared as SIGPLAN Notices 22(10). </note>
Reference-contexts: This functionality is implemented by inserting checks during compilation. Magpie does not support monitoring of heap objects. To this date, no performance information has been reported for Magpie or for VAX DEBUG. Several authors have speculated that efficient data breakpoints require special-purpose hardware <ref> [4, 11, 15] </ref>. To quantify the differences among data breakpoint implementation strategies, Wahbe [19] compared facilities based on specialized processor support, virtual memory page protection, checking the destination address of machine instructions via an operating system trap, and checking the destination address of machine instructions via a procedure call.
Reference: [5] <author> R. Cytron, J. Ferrante, B. K. Rosen, M. N. Weg-man, and F. K. Zadeck. </author> <title> "Efficiently Computing Static Single Assignment Form and the Control Dependence Graph,". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 13(4) </volume> <pages> 451-490, </pages> <month> October </month> <year> 1991. </year>
Reference-contexts: It then converts this sequence into an intermediate representation (IR) which is defined as a set of 3-address codes. In addition, the analysis tool converts symbol table entries (e.g. STAB) into IR form. The optimizer takes as input the IR, and converts it to static single assignment (SSA) form <ref> [5] </ref>. It then performs several IR transformations that eliminate checks on the target addresses of individual write instructions. 4.2 Symbol Table Pattern Matching The first pass of the optimizer identifies known write instructions through symbol table pattern matching.
Reference: [6] <author> N. M. Delisle, D. E. Menicosy, and M. D. Schwartz. </author> <title> "Viewing a Programming Environment As a Single Tool,". </title> <booktitle> In Proceedings of the ACM SIG-SOFT/SIGPLAN Software Engineering Symposium on Practical Software Development Environments, </booktitle> <pages> pages 49-56, </pages> <month> May </month> <year> 1984. </year> <note> Appeared as SIGPLAN Notices 19(5). </note>
Reference-contexts: However, rather than check each instruction, VAX DEBUG protects each virtual memory page containing data that is part of a data break condition. Magpie is a programming environment for Pascal that allows debugging actions to be associated with variable updates <ref> [6] </ref>. This functionality is implemented by inserting checks during compilation. Magpie does not support monitoring of heap objects. To this date, no performance information has been reported for Magpie or for VAX DEBUG. Several authors have speculated that efficient data breakpoints require special-purpose hardware [4, 11, 15].
Reference: [7] <author> A. Dinning and E. Schonberg. </author> <title> "An Empirical Comparison of Monitoring Algorithms for Access Anomaly Detection,". </title> <booktitle> In ACM Symposium on Principles and Practice of Parallel Programming, </booktitle> <pages> pages 1-10, </pages> <year> 1990. </year>
Reference-contexts: On processor architectures such as the i386, the dynamic count of write instructions will be far greater relative to the total instruction count than on RISC architectures such as the Sparc. Further, some applications of data breakpoints, such as detecting access anomalies <ref> [7] </ref> in parallel programs, require the monitoring of read instructions as well as write instructions. Since the dynamic count of read instructions is typically two to three times that of write instructions, the overhead of monitoring every read and write can be significant.
Reference: [8] <author> S. L. Graham, P. B. Kessler, and M. K. McKu-sick. </author> <title> "An Execution Profiler for Modular Programs,". </title> <journal> Software-Practice & Experience, </journal> <volume> 13 </volume> <pages> 671-685, </pages> <month> August </month> <year> 1983. </year>
Reference-contexts: The column labeled is explained below. All routines were carefully hand coded in Sparc assembly code. The standard libraries were not patched for these experiments; using gprof <ref> [8] </ref>, we measured the percentage of time spent in library routines to be an average of 2.6% for C programs and 1.6% for Fortran programs, excluding the Sparc library routines for integer multiplication and division which do not update memory. 3.3.1 Cache Effects Our measurements show a number of interesting anomalies.
Reference: [9] <author> J. L. Hennessy. </author> <title> "Symbolic Debugging of Optimized Code,". </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 4(3) </volume> <pages> 323-344, </pages> <month> July </month> <year> 1982. </year>
Reference-contexts: Consider that 14% overhead represents only about 50 seconds for a program that normally runs for 6 minutes. For compute intensive applications, improving the naive compilation typically used during debugging would have more performance impact than reserving registers for segment caching <ref> [1, 2, 9] </ref>. In particular, register allocation would speed program execution, while reducing the number of write checks.
Reference: [10] <institution> Intel Corporation, Santa Clara, California. </institution> <note> Intel 80386 Programmer's Reference Manual, </note> <year> 1986. </year>
Reference-contexts: If any data breakpoint is active, all unknown write instructions must be considered unsafe, and must be checked at runtime. Implementation Strategies Some commercially available processors provide direct support for data breakpoints. Examples include the Intel i386 <ref> [10] </ref>, the MIPS R4000 [12], and the Sparc [16]. Special-purpose hardware can monitor memory efficiently. Unfortunately, the hardware approach inherently limits the number of data words simultaneously monitored. The Intel i386 can monitor four words; the MIPS R4000 and the Sparc can only monitor a single word. <p> We can take advantage of this situation by reserving registers for use by the MRS. Optimizations based on reserved registers are less applicable to architectures, such as the i386, which have small register sets <ref> [10] </ref>. Also, as compilation for debugging incorporates more sophisticated register allocation, there will be a tradeoff between freeing an additional register for the compiler, and reserving that register for the MRS. On the Sparc we found two techniques that can benefit from reserved registers.
Reference: [11] <author> M. S. Johnson. </author> <title> "Some Requirements for Architectural Support of Software Debugging,". </title> <booktitle> In Symposium on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 140-148, </pages> <month> April </month> <year> 1982. </year> <note> Appeared as SIGPLAN Notices 17(4). </note>
Reference-contexts: This functionality is implemented by inserting checks during compilation. Magpie does not support monitoring of heap objects. To this date, no performance information has been reported for Magpie or for VAX DEBUG. Several authors have speculated that efficient data breakpoints require special-purpose hardware <ref> [4, 11, 15] </ref>. To quantify the differences among data breakpoint implementation strategies, Wahbe [19] compared facilities based on specialized processor support, virtual memory page protection, checking the destination address of machine instructions via an operating system trap, and checking the destination address of machine instructions via a procedure call.
Reference: [12] <author> G. Kane and J. Heinrich. </author> <title> MIPS RISC ARCHITECTURE. </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1992. </year>
Reference-contexts: If any data breakpoint is active, all unknown write instructions must be considered unsafe, and must be checked at runtime. Implementation Strategies Some commercially available processors provide direct support for data breakpoints. Examples include the Intel i386 [10], the MIPS R4000 <ref> [12] </ref>, and the Sparc [16]. Special-purpose hardware can monitor memory efficiently. Unfortunately, the hardware approach inherently limits the number of data words simultaneously monitored. The Intel i386 can monitor four words; the MIPS R4000 and the Sparc can only monitor a single word.
Reference: [13] <author> P. B. Kessler. </author> <title> "Fast Breakpoints: </title> <booktitle> Design and Implementation,". In Proceedings of the ACM SIG-PLAN'90 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 78-84, </pages> <address> White Plains, New York, </address> <month> June </month> <year> 1990. </year> <note> Appeared as SIGPLAN Notices 25(6). </note>
Reference-contexts: Given this information, it can arrange for the MRS to check, on loop entry, whether the range of memory locations to be updated intersects any monitored regions. If this range check succeeds, the MRS can dynamically reinsert the eliminated write check on w l . Kessler <ref> [13] </ref> describes a method for dynamically patching a running program. To insert a check before an instruction, the instruction is replaced with a branch to a write check patch. The write check patch, in addition to checking for a monitor hit, is responsible for executing the displaced instruction.
Reference: [14] <author> M. A. Linton. </author> <title> "The Evolution of Dbx,". </title> <booktitle> In Proceedings of the 1990 Usenix Summer Conference, </booktitle> <pages> pages 211-220, </pages> <address> Anaheim, CA, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: Special-purpose hardware can monitor memory efficiently. Unfortunately, the hardware approach inherently limits the number of data words simultaneously monitored. The Intel i386 can monitor four words; the MIPS R4000 and the Sparc can only monitor a single word. The UNIX debuggers gdb [17] and dbx <ref> [14, 18] </ref> provide data breakpoints. Both systems conservatively assume all instructions are unsafe. The possible side-effects of each instruction are checked through dynamically inserted trap instructions. Due to context switch and trap costs, this approach incurs very high overhead.
Reference: [15] <author> J. M. Mellor-Crummey and T. J. LeBlanc. </author> <title> "A Software Instruction Counter,". </title> <booktitle> In Proceedings of the Third International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 78-86, </pages> <month> April </month> <year> 1989. </year> <note> Appeared as SIGPLAN Notices 24(Special Issue). </note>
Reference-contexts: This functionality is implemented by inserting checks during compilation. Magpie does not support monitoring of heap objects. To this date, no performance information has been reported for Magpie or for VAX DEBUG. Several authors have speculated that efficient data breakpoints require special-purpose hardware <ref> [4, 11, 15] </ref>. To quantify the differences among data breakpoint implementation strategies, Wahbe [19] compared facilities based on specialized processor support, virtual memory page protection, checking the destination address of machine instructions via an operating system trap, and checking the destination address of machine instructions via a procedure call.
Reference: [16] <author> Sparc International. </author> <title> The Sparc Architecture Manual. </title> <publisher> Prentice-Hall, Inc., </publisher> <address> Menlo Park, CA, </address> <note> version 8 edition, </note> <year> 1992. </year>
Reference-contexts: If any data breakpoint is active, all unknown write instructions must be considered unsafe, and must be checked at runtime. Implementation Strategies Some commercially available processors provide direct support for data breakpoints. Examples include the Intel i386 [10], the MIPS R4000 [12], and the Sparc <ref> [16] </ref>. Special-purpose hardware can monitor memory efficiently. Unfortunately, the hardware approach inherently limits the number of data words simultaneously monitored. The Intel i386 can monitor four words; the MIPS R4000 and the Sparc can only monitor a single word.
Reference: [17] <author> R. M. Stallman and R. H. Pesch. </author> <title> A Guide to the GNU Source-Level Debugger. Free Software Foundation, </title> <address> 4.01 revision 2.77 edition, </address> <month> January </month> <year> 1992. </year>
Reference-contexts: Special-purpose hardware can monitor memory efficiently. Unfortunately, the hardware approach inherently limits the number of data words simultaneously monitored. The Intel i386 can monitor four words; the MIPS R4000 and the Sparc can only monitor a single word. The UNIX debuggers gdb <ref> [17] </ref> and dbx [14, 18] provide data breakpoints. Both systems conservatively assume all instructions are unsafe. The possible side-effects of each instruction are checked through dynamically inserted trap instructions. Due to context switch and trap costs, this approach incurs very high overhead.
Reference: [18] <author> Sun Microsystems, Inc. </author> <title> Programmer's Language Guide, revision a edition, </title> <month> March </month> <year> 1990. </year> <title> Part Number: </title> <publisher> 800-3844-10. </publisher>
Reference-contexts: Special-purpose hardware can monitor memory efficiently. Unfortunately, the hardware approach inherently limits the number of data words simultaneously monitored. The Intel i386 can monitor four words; the MIPS R4000 and the Sparc can only monitor a single word. The UNIX debuggers gdb [17] and dbx <ref> [14, 18] </ref> provide data breakpoints. Both systems conservatively assume all instructions are unsafe. The possible side-effects of each instruction are checked through dynamically inserted trap instructions. Due to context switch and trap costs, this approach incurs very high overhead.
Reference: [19] <author> R. Wahbe. </author> <title> "Efficient Data Breakpoints,". </title> <booktitle> In Fifth International Conference on Architectural Support for Programming Languages and Operating Systems, </booktitle> <pages> pages 200-212, </pages> <month> October </month> <year> 1992. </year> <note> Appeared as SIGPLAN Notices 27(9). </note>
Reference-contexts: Magpie does not support monitoring of heap objects. To this date, no performance information has been reported for Magpie or for VAX DEBUG. Several authors have speculated that efficient data breakpoints require special-purpose hardware [4, 11, 15]. To quantify the differences among data breakpoint implementation strategies, Wahbe <ref> [19] </ref> compared facilities based on specialized processor support, virtual memory page protection, checking the destination address of machine instructions via an operating system trap, and checking the destination address of machine instructions via a procedure call. <p> We call this operation address lookup. We found that the best strategy for implementing efficient address lookup is to mini mize the average number of memory accesses required. The write checks tested in Wahbe's pilot study of data breakpoint implementations used a hash table for address lookup <ref> [19] </ref>. This data structure uses memory efficiently, consuming space proportional to the number of monitored regions. However, it requires several memory accesses for each address lookup.
References-found: 19

