URL: http://www.cs.vt.edu/~irchen/ps/cj95.4.ps
Refering-URL: http://www.cs.vt.edu/~irchen/
Root-URL: http://www.cs.vt.edu
Title: Stochastic Petri Net Analysis of Deadlock Detection Algorithms in Transaction Database Systems with Dynamic Locking  
Author: Ing-Ray Chen 
Date: November 8, 1995  
Abstract: We develop stochastic Petri net (SPN) models to analyze the best time interval between two consecutive executions of periodic deadlock detection algorithms for two-phase locking database systems with dynamic locking. Our models can accurately estimate "wait time per lock conflict" automatically and allow the best time interval to be determined as a function of workload intensities and database characteristics. A system designer can apply the SPN tools developed in the paper to choose the best deadlock detection strategy, continuous or periodic, to optimize system performance, when given a set of system characteristics. Index Terms | Deadlock detection, transaction database systems, two-phase locking, stochas tic Petri net, performance analysis.
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> R. Agrawal, M.J. Carey, and L.W. McVoy, </author> <title> "The performance of alternative strategies for dealing with deadlocks in database management systems," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 13, No. 12, </volume> <month> Dec. </month> <year> 1987, </year> <pages> pp. 1348-1363. </pages>
Reference-contexts: If the blocked transaction is involved in a deadlock cycle, then one transaction in the cycle is aborted to break the deadlock. Otherwise, the transaction waits until it gets its lock. This method is termed "continuous deadlock detection" in the literature <ref> [1] </ref>. To model the behavior of such a transaction database system with continuous deadlock detection, previous models [13, 19, 23, 25, 26] require several parameters to be estimated a priori. One parameter is the probability of lock conflict per lock request. <p> Kumar [14] in his simulation study concluded that in dynamic locking, deadlocks need not be detected at each blocking and the response time can be improved by periodic rather than continuous deadlock detection. Agrawal et al. <ref> [1] </ref> also compared the performance of continuous and periodic deadlock detection by means of simulation. <p> The result is that they can be used as an analysis tool in providing guidelines for selecting a deadlock detection strategy. With respect to the simulation model in <ref> [1, 14] </ref>, our Petri net model, being an analytical tool, is much easier to construct and evaluate. The rest of the paper is organized as follows.
Reference: [2] <author> C. Beeri, and R. Obermarck, </author> <title> "A resource independent deadlock detection algorithm," </title> <booktitle> 7th Int. Conf. Very Large Data Bases, </booktitle> <year> 1981, </year> <pages> pp. 166-178. </pages>
Reference: [3] <author> P.A. Bernstein, D.W. Shipman, and D.W. Wong, </author> <title> "Formal aspects of serializability in database con-currency control," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 5, No. 3, </volume> <month> May </month> <year> 1979, </year> <pages> pp. 203-216. </pages>
Reference-contexts: 1 Introduction Many existing transaction database systems such as IBM's DB2 and RTI's INGRES ensure serial-izable executions <ref> [3, 4] </ref> by running a version of two-phase locking (2PL) [7] in which a transaction consisting of a sequence of access operations should obtain a lock before accessing a data item controlled by the lock and should release all of the locks it owns together when it terminates.
Reference: [4] <author> P.A. Bernstein, V. Hadzilacos, and N. Goodman, </author> <title> Concurrency Control and Recovery in Database Systems, 1987, </title> <publisher> Addison-Wesley. </publisher>
Reference-contexts: 1 Introduction Many existing transaction database systems such as IBM's DB2 and RTI's INGRES ensure serial-izable executions <ref> [3, 4] </ref> by running a version of two-phase locking (2PL) [7] in which a transaction consisting of a sequence of access operations should obtain a lock before accessing a data item controlled by the lock and should release all of the locks it owns together when it terminates. <p> Various 2PL lock conflict resolution methods have been proposed in the literature in the past, including those that can cause deadlocks, e.g., general waiting <ref> [4] </ref>, and those that are deadlock-free (due to selective transaction aborts), e.g., running priority [8, 9], cautious waiting [12] and wait-depth limited methods [9, 10].
Reference: [5] <author> G. Ciardo, J.K. Muppala, and K.S. Trivedi, "SPNP: </author> <title> stochastic Petri net package," </title> <booktitle> Proc. 3rd Int. Workshop Petri Nets and Performance Models, </booktitle> <address> Kyoto, Japan, </address> <month> Dec. </month> <year> 1989, </year> <pages> pp. 142-151. </pages>
Reference-contexts: Second, two separate Petri net models are constructed separately to evaluate the system performance of continuous and periodic deadlock detection algorithms. These SPN models can be solved easily by using a commercial software package such as Stochastic Petri Net Package (SPNP) <ref> [5, 17] </ref>. Previous performance models based on queueing network [13, 19, 24] are non-trivial and difficult to apply. For example, in [13, 19, 24], it involves the concept of changing the customer class of a transaction during the transaction's life time as the transaction requests, acquires, and releases locks. <p> However, unlike the queueing network model in [19], our iterative Petri net model does not require any special solution technique. A software package such as SPNP <ref> [5] </ref> can solve it. N LO in this case is approximated as a constant as in [19], i.e., N LO = min (N; bN L=2c In Section 4, we then develop a non-iterative Petri net model to eliminate imprecise and error-prone methods for estimating N LO and D lock . <p> Table 5 gives the transition probabilities associated with immediate transitions. To simplify our analysis, the firing times of timed transitions are assumed to be exponentially distributed, thus rendering the Petri net stochastic in nature and susceptible to solution techniques provided by SPNP <ref> [5, 17] </ref>. The approach described here can be easily extended to Extended Stochastic Petri Net (ESPN) [6] models in which firing times are general distributions. Table 3. Meanings of Places With Respect to A Transaction. <p> It should be noted that we only need to specify the reward rate assignments as part of the SPN description <ref> [5] </ref>.
Reference: [6] <editor> J.B. Dugan et al., </editor> <title> "Extended stochastic Petri nets: applications and analysis," Performance 84, </title> <editor> E. Gelenbe, ed., </editor> <publisher> Elsevier Science Publishers </publisher>
Reference-contexts: To simplify our analysis, the firing times of timed transitions are assumed to be exponentially distributed, thus rendering the Petri net stochastic in nature and susceptible to solution techniques provided by SPNP [5, 17]. The approach described here can be easily extended to Extended Stochastic Petri Net (ESPN) <ref> [6] </ref> models in which firing times are general distributions. Table 3. Meanings of Places With Respect to A Transaction.
Reference: [7] <author> K.P. Eswaran, J.N. Gray, R.A. Lorie, </author> <title> and I.L. Traiger, "The notions of consistency and predicate locks in a database system," </title> <journal> Comm. ACM, </journal> <volume> Vol. 19, No. 11, </volume> <month> Nov. </month> <year> 1976. </year>
Reference-contexts: 1 Introduction Many existing transaction database systems such as IBM's DB2 and RTI's INGRES ensure serial-izable executions [3, 4] by running a version of two-phase locking (2PL) <ref> [7] </ref> in which a transaction consisting of a sequence of access operations should obtain a lock before accessing a data item controlled by the lock and should release all of the locks it owns together when it terminates.
Reference: [8] <author> P.A. Franaszek, and J.T. Robinson, </author> <title> "Limitations of concurrency in transaction processing," </title> <journal> ACM Trans. Database Syst., </journal> <volume> Vol 10, No. 1, </volume> <month> March </month> <year> 1985, </year> <pages> pp. 1-28. </pages>
Reference-contexts: Various 2PL lock conflict resolution methods have been proposed in the literature in the past, including those that can cause deadlocks, e.g., general waiting [4], and those that are deadlock-free (due to selective transaction aborts), e.g., running priority <ref> [8, 9] </ref>, cautious waiting [12] and wait-depth limited methods [9, 10]. If the system allows fl Institute of Information Engineering; National Cheng Kung University; No.1, University; Tainan, Taiwan. 1 deadlocks to exist, it requires the use of a deadlock detection algorithm.
Reference: [9] <author> P.A. Franaszek, J.T. Robinson and A. Thomasian, </author> <title> "Concurrency control for high contention environment," </title> <journal> ACM Trans. Database Syst., </journal> <volume> Vol 17, No. 2, </volume> <month> June </month> <year> 1992, </year> <pages> pp. 304-345. </pages>
Reference-contexts: Various 2PL lock conflict resolution methods have been proposed in the literature in the past, including those that can cause deadlocks, e.g., general waiting [4], and those that are deadlock-free (due to selective transaction aborts), e.g., running priority <ref> [8, 9] </ref>, cautious waiting [12] and wait-depth limited methods [9, 10]. If the system allows fl Institute of Information Engineering; National Cheng Kung University; No.1, University; Tainan, Taiwan. 1 deadlocks to exist, it requires the use of a deadlock detection algorithm. <p> Various 2PL lock conflict resolution methods have been proposed in the literature in the past, including those that can cause deadlocks, e.g., general waiting [4], and those that are deadlock-free (due to selective transaction aborts), e.g., running priority [8, 9], cautious waiting [12] and wait-depth limited methods <ref> [9, 10] </ref>. If the system allows fl Institute of Information Engineering; National Cheng Kung University; No.1, University; Tainan, Taiwan. 1 deadlocks to exist, it requires the use of a deadlock detection algorithm. One common strategy is to check the wait-for-graph (WFG) whenever a transaction is blocked.
Reference: [10] <author> P.A. Franaszek, J.R. Haritsa, J.T. Robinson and A. Thomasian, </author> <title> "distributed concurrency control based on limited wait depth," </title> <journal> IEEE Trans. Parallel and Distributed Systems, </journal> <volume> Vol. 4, No. 11, </volume> <month> Nov. </month> <year> 1993, </year> <pages> pp. 246-264. </pages>
Reference-contexts: Various 2PL lock conflict resolution methods have been proposed in the literature in the past, including those that can cause deadlocks, e.g., general waiting [4], and those that are deadlock-free (due to selective transaction aborts), e.g., running priority [8, 9], cautious waiting [12] and wait-depth limited methods <ref> [9, 10] </ref>. If the system allows fl Institute of Information Engineering; National Cheng Kung University; No.1, University; Tainan, Taiwan. 1 deadlocks to exist, it requires the use of a deadlock detection algorithm. One common strategy is to check the wait-for-graph (WFG) whenever a transaction is blocked.
Reference: [11] <author> C.S. Hartzman, </author> <title> "The delay due to two-phase locking," </title> <journal> IEEE Trans. Soft. Eng., </journal> <volume> Vol. 15, No. 1, </volume> <month> Jan. </month> <year> 1989, </year> <pages> pp. 72-82. </pages>
Reference-contexts: Another parameter needed is the wait time for a lock by a blocked transaction. This "wait time per lock conflict" parameter is difficult to estimate accurately and existing methods for estimating it are often controversial <ref> [11] </ref>. For example, Irani and Lin suggested that simulation or empirical measurements be used to estimate its value [13]. Pun and Belford estimated it as a function of the throughputs of aborted and terminated transactions, which by themselves are model outputs [19]. <p> As a result, an iterative solution technique is used to repeatedly execute the model until this wait time parameter converges. Hartzman derived an analytical solution for this parameter in an open database system <ref> [11] </ref>. However, it is obtained based on the dubious assumption that deadlocks never occur and it is not apparent how that approach can be applied to a closed database system for which the population of transactions is fixed. <p> the probability of deadlock be calculated as model inputs based on system characteristics, unlike previous analytical modeling studies, it does not require the "wait time per lock conflict" parameter be calculated a priori as an input, thus reducing the potential 3 inaccuracy associated with estimating the value of this parameter <ref> [11] </ref>. In our approach we implicitly model the behavior of a blocked (but not deadlocked) transaction by a Petri net description such that the blocked transaction can simply migrate from one place to another in the net when certain enabling conditions are satisfied.
Reference: [12] <author> M. Hsu and B. Zhang, </author> <title> "Performance evaluation of cautious waiting," </title> <journal> ACM Trans. Database Syst., </journal> <volume> Vol 17, No. 3, </volume> <month> Sept. </month> <year> 1992, </year> <pages> pp. 477-512. 32 </pages>
Reference-contexts: Various 2PL lock conflict resolution methods have been proposed in the literature in the past, including those that can cause deadlocks, e.g., general waiting [4], and those that are deadlock-free (due to selective transaction aborts), e.g., running priority [8, 9], cautious waiting <ref> [12] </ref> and wait-depth limited methods [9, 10]. If the system allows fl Institute of Information Engineering; National Cheng Kung University; No.1, University; Tainan, Taiwan. 1 deadlocks to exist, it requires the use of a deadlock detection algorithm.
Reference: [13] <author> K.B. Irani, and H.-L. Lin, </author> <title> "Queueing network models for concurrent transaction processing in a database system," </title> <booktitle> Proc. ACM SIGMOD Int. Conf. Management of Data, </booktitle> <month> May </month> <year> 1979, </year> <pages> pp. 134-142. </pages>
Reference-contexts: Otherwise, the transaction waits until it gets its lock. This method is termed "continuous deadlock detection" in the literature [1]. To model the behavior of such a transaction database system with continuous deadlock detection, previous models <ref> [13, 19, 23, 25, 26] </ref> require several parameters to be estimated a priori. One parameter is the probability of lock conflict per lock request. Another parameter is the probability that a transaction is deadlocked with other transactions when a subsequent lock request is not granted. <p> These two parameters in theory can be estimated fairly accurately by first estimating the number of locks owned by active transactions in the system and then computing the probability that each event can occur <ref> [13, 19, 23, 25] </ref>. Another parameter needed is the wait time for a lock by a blocked transaction. This "wait time per lock conflict" parameter is difficult to estimate accurately and existing methods for estimating it are often controversial [11]. <p> This "wait time per lock conflict" parameter is difficult to estimate accurately and existing methods for estimating it are often controversial [11]. For example, Irani and Lin suggested that simulation or empirical measurements be used to estimate its value <ref> [13] </ref>. Pun and Belford estimated it as a function of the throughputs of aborted and terminated transactions, which by themselves are model outputs [19]. As a result, an iterative solution technique is used to repeatedly execute the model until this wait time parameter converges. <p> These SPN models can be solved easily by using a commercial software package such as Stochastic Petri Net Package (SPNP) [5, 17]. Previous performance models based on queueing network <ref> [13, 19, 24] </ref> are non-trivial and difficult to apply. For example, in [13, 19, 24], it involves the concept of changing the customer class of a transaction during the transaction's life time as the transaction requests, acquires, and releases locks. <p> These SPN models can be solved easily by using a commercial software package such as Stochastic Petri Net Package (SPNP) [5, 17]. Previous performance models based on queueing network <ref> [13, 19, 24] </ref> are non-trivial and difficult to apply. For example, in [13, 19, 24], it involves the concept of changing the customer class of a transaction during the transaction's life time as the transaction requests, acquires, and releases locks. Consequently, a special solution technique is used to solve their queueing network models. <p> The requirement of using special solution techniques, rather than using a commercial software package (e.g., SHARPE [21]), limits the general applicability of these queueing network models. Although our SPN model involves the concept of changing a transaction's class during a transaction's life time as in <ref> [13, 19] </ref>, the change of customer classes is explicitly modeled by the migration of a transaction from one place to another in the net. Consequently, no special solution method is required to solve the model.
Reference: [14] <author> V. Kumar, </author> <title> "Performance comparison of database concurrency control mechanisms based on two-phase locking, timestamping and mixed approaches," </title> <journal> Information Sciences, </journal> <volume> Vol. 51, No. 3, </volume> <month> Aug. </month> <year> 1990, </year> <pages> pp. 221-261. </pages>
Reference-contexts: On the other hand, for systems in which deadlocks rarely occur (which is more typical), deadlocks can be checked only periodically after a few edges have been added to the WFG so that the overhead associated with deadlock detection can be minimized. Kumar <ref> [14] </ref> in his simulation study concluded that in dynamic locking, deadlocks need not be detected at each blocking and the response time can be improved by periodic rather than continuous deadlock detection. Agrawal et al. [1] also compared the performance of continuous and periodic deadlock detection by means of simulation. <p> The result is that they can be used as an analysis tool in providing guidelines for selecting a deadlock detection strategy. With respect to the simulation model in <ref> [1, 14] </ref>, our Petri net model, being an analytical tool, is much easier to construct and evaluate. The rest of the paper is organized as follows.
Reference: [15] <author> E.D. Lazowska, J. Zahorjan, G.S. Graham, and K. C. Sevcik, </author> <title> Quantitative System Performance: Computer System Analysis Using Queueing Network Models., </title> <publisher> Prentice Hall, </publisher> <year> 1984. </year>
Reference-contexts: Here, P g1 , P g2 and P d are estimated as suggested in [19]. Once D lock is known, we can use an infinite service center with no queueing and a service time of D lock to hold all blocked transactions <ref> [15] </ref>. As stated before, methods for estimating D lock are often controversial. <p> The second modeling concept concerns the fact that places p1 through p7 all request the service of the cpu. Since the extent of cpu sharing is reflected by the number of tokens in these places, we model this cpu sharing concept <ref> [15] </ref> by defining the transition rates of t1 through t7 as shown in Table 4 where #(p1) means the number of tokens (transactions) in place 1 and #(p1+p2+p3+p4+p5+p6+p7) means the total number of tokens in places p1 through p7. <p> Once X is obtained, the average response time of terminating transactions can be computed based on Little's law <ref> [15] </ref>, i.e., R = N=X where M P L is the multiprogramming level of the system. * U cpu : The useful cpu utilization of the database system can be computed as a model output by assigning a reward of #(p7)/#(p1+p2+p3+p4+p5+p6+p7) to those markings in which place p7 is nonempty, and
Reference: [16] <author> D. Mitra and P.J. Weinberger, </author> <title> "Probabilistic models of database locking: solutions, computational algorithms and asymptotics," </title> <journal> J. ACM, </journal> <volume> Vol. 31, No. 4, </volume> <year> 1984, </year> <pages> pp. 855-878. </pages>
Reference: [17] <author> J.K. Muppala, </author> <title> S.P. Woolet and K.S. Trivedi, "Real-time systems performance in the presence of failures", </title> <booktitle> IEEE Computer, </booktitle> <month> May, </month> <year> 1991, </year> <pages> pp. 37-47. </pages>
Reference-contexts: Second, two separate Petri net models are constructed separately to evaluate the system performance of continuous and periodic deadlock detection algorithms. These SPN models can be solved easily by using a commercial software package such as Stochastic Petri Net Package (SPNP) <ref> [5, 17] </ref>. Previous performance models based on queueing network [13, 19, 24] are non-trivial and difficult to apply. For example, in [13, 19, 24], it involves the concept of changing the customer class of a transaction during the transaction's life time as the transaction requests, acquires, and releases locks. <p> Table 5 gives the transition probabilities associated with immediate transitions. To simplify our analysis, the firing times of timed transitions are assumed to be exponentially distributed, thus rendering the Petri net stochastic in nature and susceptible to solution techniques provided by SPNP <ref> [5, 17] </ref>. The approach described here can be easily extended to Extended Stochastic Petri Net (ESPN) [6] models in which firing times are general distributions. Table 3. Meanings of Places With Respect to A Transaction. <p> Eventually, a steady state is established in which there exists a finite number of states each having a steady state probability. Calculations of Performance Measures In the following, we describe how to compute system performance measures by applying the concept of reward rate assignments <ref> [17] </ref>. * X and T int : The time interval between which a transaction terminates or aborts, T int , can be computed as in [19] by the reciprocal of the sum of the throughputs of terminating and aborting transactions, i.e., T int = X + X abort where X and <p> fl T int sec * MP L = 6 (Iterative SPN) ffi MP L = 6 (Queueing) fi MP L = 4 (Iterative SPN) ? MP L = 4 (Queueing) MP L = 2 (Iterative SPN) fl MP L = 2 (Queueing) Petri net description into a continuous Markov chain <ref> [17] </ref> and then solves the Markov chain numerically.
Reference: [18] <author> J.L Peterson, </author> <title> Petri Net Theory and the Modeling of Systems, </title> <publisher> Prentice-Hall, </publisher> <year> 1981. </year>
Reference-contexts: To achieve the goal, we develop our analytical model based on stochastic Petri net (SPN) <ref> [18] </ref>. There are two salient features in our SPN model.
Reference: [19] <author> K.H. Pun, and G.G. Belford, </author> <title> "Performance study of two phase locking in single-site database systems," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 13, No. 12, </volume> <month> Dec. </month> <year> 1987, </year> <pages> pp. 1311-1328. </pages>
Reference-contexts: Otherwise, the transaction waits until it gets its lock. This method is termed "continuous deadlock detection" in the literature [1]. To model the behavior of such a transaction database system with continuous deadlock detection, previous models <ref> [13, 19, 23, 25, 26] </ref> require several parameters to be estimated a priori. One parameter is the probability of lock conflict per lock request. Another parameter is the probability that a transaction is deadlocked with other transactions when a subsequent lock request is not granted. <p> These two parameters in theory can be estimated fairly accurately by first estimating the number of locks owned by active transactions in the system and then computing the probability that each event can occur <ref> [13, 19, 23, 25] </ref>. Another parameter needed is the wait time for a lock by a blocked transaction. This "wait time per lock conflict" parameter is difficult to estimate accurately and existing methods for estimating it are often controversial [11]. <p> For example, Irani and Lin suggested that simulation or empirical measurements be used to estimate its value [13]. Pun and Belford estimated it as a function of the throughputs of aborted and terminated transactions, which by themselves are model outputs <ref> [19] </ref>. As a result, an iterative solution technique is used to repeatedly execute the model until this wait time parameter converges. Hartzman derived an analytical solution for this parameter in an open database system [11]. <p> To achieve this, we differentiate blocked, non-lock-owner transactions from blocked, lock-owner ones in constructing our Petri net model to provide a more precise information on the number of lock owners in the system as the system evolves over time. As a result, unlike the queueing network models proposed in <ref> [19, 24] </ref>, our Petri net model can be solved noniteratively and efficiently. Second, two separate Petri net models are constructed separately to evaluate the system performance of continuous and periodic deadlock detection algorithms. <p> These SPN models can be solved easily by using a commercial software package such as Stochastic Petri Net Package (SPNP) [5, 17]. Previous performance models based on queueing network <ref> [13, 19, 24] </ref> are non-trivial and difficult to apply. For example, in [13, 19, 24], it involves the concept of changing the customer class of a transaction during the transaction's life time as the transaction requests, acquires, and releases locks. <p> These SPN models can be solved easily by using a commercial software package such as Stochastic Petri Net Package (SPNP) [5, 17]. Previous performance models based on queueing network <ref> [13, 19, 24] </ref> are non-trivial and difficult to apply. For example, in [13, 19, 24], it involves the concept of changing the customer class of a transaction during the transaction's life time as the transaction requests, acquires, and releases locks. Consequently, a special solution technique is used to solve their queueing network models. <p> For example, in [13, 19, 24], it involves the concept of changing the customer class of a transaction during the transaction's life time as the transaction requests, acquires, and releases locks. Consequently, a special solution technique is used to solve their queueing network models. In <ref> [19, 24] </ref>, an iterative solution technique is also used to solve their models. The requirement of using special solution techniques, rather than using a commercial software package (e.g., SHARPE [21]), limits the general applicability of these queueing network models. <p> The requirement of using special solution techniques, rather than using a commercial software package (e.g., SHARPE [21]), limits the general applicability of these queueing network models. Although our SPN model involves the concept of changing a transaction's class during a transaction's life time as in <ref> [13, 19] </ref>, the change of customer classes is explicitly modeled by the migration of a transaction from one place to another in the net. Consequently, no special solution method is required to solve the model. <p> Possible database environment variables which must be considered in performance assessment are defined. Section 3 develops an iterative SPN model for 2PL databases with continuous deadlock detection; it also requires the wait time for a lock as a model input as in <ref> [19] </ref>, thus requiring the SPN model to be iteratively solved by SPNP in multiple runs until the wait time converges. A technique for modeling a processor-sharing cpu in the SPN model is described. <p> A technique for modeling a processor-sharing cpu in the SPN model is described. The validity of the iterative SPN model is demonstrated by comparing the model's outputs in several database environment settings with the results based on a queueing model <ref> [19] </ref>. In Section 4, modifications to the iterative SPN description are made with the goal of removing the wait time for a lock as a model input. We demonstrate that the new SPN model can greatly improve solution efficiency with a potential of improving solution accuracy. <p> requested by a transaction, denoted by N L, is given by N L = d SZ lock e (1) We concentrate on well-placed instead of other transaction accessing patterns such as worst-placed and random 1 because performance data for well-placed accessing pattern under continuous deadlock detection are available for comparison <ref> [19] </ref>. Other transaction assessing patterns can be analyzed in a similar way by our SPN model except a different equation needs to be used for computing N L. 2. The system has one cpu and one data manager. <p> Every lock owner is assumed to own dN L=2e locks. This assumption is introduced to avoid state space explosion and is also used in previous models. However, we do not assume the number of lock owners, N LO, as a constant as in <ref> [19, 24] </ref>. In our (noniterative) Petri net model, N LO is computed dynamically as the system evolves. Table 1 shows the list of input parameters to our model. 1 Worst placement is the opposite of well placement: each transaction requires the maximum number of granules possible. <p> In this case, NL = minimum (SZ tr ; SZ db =SZ lock ). Random placement means that a transaction will access the database randomly, with each data item being referenced with equal probability. The expression of NL for random placement can be found in <ref> [19] </ref>. 6 Table 1. Input Parameters. <p> Other than N LO and D lock , all state-dependent parameters can be estimated accurately by using simple probability arguments. Here, P g1 , P g2 and P d are estimated as suggested in <ref> [19] </ref>. Once D lock is known, we can use an infinite service center with no queueing and a service time of D lock to hold all blocked transactions [15]. As stated before, methods for estimating D lock are often controversial. One way to estimate D lock [19] is based on the <p> estimated as suggested in <ref> [19] </ref>. Once D lock is known, we can use an infinite service center with no queueing and a service time of D lock to hold all blocked transactions [15]. As stated before, methods for estimating D lock are often controversial. One way to estimate D lock [19] is based on the observation that in the steady state, when a transaction terminates or aborts, a blocked transaction will be unblocked so that the number of lock owners in the system remains the same. <p> Since the response time is also a model output, an iterative solution technique is again required. 9 In Section 3, we develop an iterative Petri net model that adopts the same method for estimating D lock as in <ref> [19] </ref>, thus requiring T int to be solved iteratively until it converges. However, unlike the queueing network model in [19], our iterative Petri net model does not require any special solution technique. A software package such as SPNP [5] can solve it. <p> model output, an iterative solution technique is again required. 9 In Section 3, we develop an iterative Petri net model that adopts the same method for estimating D lock as in <ref> [19] </ref>, thus requiring T int to be solved iteratively until it converges. However, unlike the queueing network model in [19], our iterative Petri net model does not require any special solution technique. A software package such as SPNP [5] can solve it. N LO in this case is approximated as a constant as in [19], i.e., N LO = min (N; bN L=2c In Section 4, we then develop a <p> However, unlike the queueing network model in <ref> [19] </ref>, our iterative Petri net model does not require any special solution technique. A software package such as SPNP [5] can solve it. N LO in this case is approximated as a constant as in [19], i.e., N LO = min (N; bN L=2c In Section 4, we then develop a non-iterative Petri net model to eliminate imprecise and error-prone methods for estimating N LO and D lock . <p> Table 2 defines the performance metrics considered in the paper. They can be computed by assigning reward rates to "states" in an SPN model. One performance metric, U cpu , is as defined in <ref> [19] </ref> and is used in the paper only for validating our SPN models. The other performance metric, the system throughput X, is used by the paper as a basis for evaluating system performance. Table 2. Performance Measurements. <p> Calculations of Performance Measures In the following, we describe how to compute system performance measures by applying the concept of reward rate assignments [17]. * X and T int : The time interval between which a transaction terminates or aborts, T int , can be computed as in <ref> [19] </ref> by the reciprocal of the sum of the throughputs of terminating and aborting transactions, i.e., T int = X + X abort where X and X abort represent the throughputs of terminating and aborting transactions, respectively. <p> These Figures match remarkably well with the data reported in <ref> [19] </ref> (labeled with "Queueing" in the Figure). There are two results implied in Figures 2 and 3. The first result concerns the effect of locking on system performance. <p> when there are only a few locks for the entire database (far left), due to a higher level of transaction concurrency. 4 Noniterative Petri Net: Removing D lock as Input In the last section, we developed an iterative Petri net model with a computational procedure similar to that used in <ref> [19] </ref> for their queueing network model. Namely, D lock is required as a model input. The difference is that our model does not require any special solution technique - SPNP was the software package used for generating the data in Figures 2 and 3. <p> In this section, we further refine our iterative SPN model so that D lock is no longer required as a model input. The assumption used for computing D lock in our iterative SPN model (adopted from <ref> [19] </ref>) is 2 MPL from 2 to 6 is chosen to allow comparison to the result reported in [19] 17 - 10 0 10 1 10 2 10 3 5 fi 10 3 0 40 80 * * fi fi ffi ffi ? ? ? fl fl fl Number of Locks <p> The assumption used for computing D lock in our iterative SPN model (adopted from <ref> [19] </ref>) is 2 MPL from 2 to 6 is chosen to allow comparison to the result reported in [19] 17 - 10 0 10 1 10 2 10 3 5 fi 10 3 0 40 80 * * fi fi ffi ffi ? ? ? fl fl fl Number of Locks in the System (N L db = SZ db =SZ lock ) U cpu C U t l <p> It replaces Table 6. Again, all other arcs in the modified SPN have multiplicity of 1. respectively, when its outputs are compared with those by a queueing network model <ref> [19] </ref>. The time needed to generate a data point in these figures is reduced by a factor of about 5 when compared with the iterative SPN model developed in Section 3. <p> We have demonstrated that this saving in computation time in our non-iterative SPN model (for 2PL with continuous deadlock detection) does not compromise solution accuracy by comparing its outputs with those reported in <ref> [19] </ref> based on a queueing model. Furthermore, because our SPN model computes the unblocking probability of a blocked transaction dynamically as a function of the system state without making any ad hoc assumption, it is likely that the behavior of a blocked transaction can be modeled more precisely.
Reference: [20] <author> D.R. Ries and M. Stonebraker, </author> <title> "Locking granularity revisited," </title> <journal> ACM Trans. Database Syst., </journal> <volume> Vol 4, No. 2, </volume> <month> June </month> <year> 1979, </year> <pages> pp. 210-227. </pages>
Reference-contexts: The database is in a closed system in which the multigramming level is M P L. The database contains SZ db data items. Each transaction on the average accesses SZ tr data items. The unit of physical lock is called a granule <ref> [20] </ref> which contains SZ lock data items. If a transaction locks a granule then it essentially locks all the data items contained in the granule. <p> Not placing a separate lock on a data item may be desirable for performance reasons for certain transaction accessing patterns described below. The database system being modeled is characterized by dynamic locking policy and well-placed transaction accessing pattern <ref> [20] </ref>. "Dynamic" locking means that locks are requested one at a time by a transaction as they are needed and there is no pre-determined sequence on the locks. "Well-placed accessing" means that the data items referenced by a transaction are packed into as few granules as possible.
Reference: [21] <author> R.A. Sahner and K.S. Trivedi, </author> <title> SHARPE Language Description, </title> <institution> Duke University, </institution> <year> 1991. </year>
Reference-contexts: Consequently, a special solution technique is used to solve their queueing network models. In [19, 24], an iterative solution technique is also used to solve their models. The requirement of using special solution techniques, rather than using a commercial software package (e.g., SHARPE <ref> [21] </ref>), limits the general applicability of these queueing network models.
Reference: [22] <author> R. Sedgewick, </author> <title> Algorithms, 2nd Ed., </title> <publisher> Addison Wesley, </publisher> <year> 1988. </year>
Reference-contexts: checks deadlocks only periodically and, when it does so, it detects and breaks all deadlocks. 5.1 Model we illustrate these concepts by explaining the differences between the periodic and continuous SPN models. * The cpu time required to execute a periodic deadlock detection algorithm (e.g., Warshall algorithm for transitive closure <ref> [22] </ref>) is of complexity O (N 2 ), rather than just O (N ) as in the continuous case.
Reference: [23] <author> Y.C. Tay, N. Goodman, and R. Suri, </author> <title> "locking performance in centralized databases," </title> <journal> ACM Trans. Database Syst., </journal> <volume> Vol. 10, No. 4, </volume> <month> Dec. </month> <year> 1985, </year> <pages> pp. 415-462. </pages>
Reference-contexts: Otherwise, the transaction waits until it gets its lock. This method is termed "continuous deadlock detection" in the literature [1]. To model the behavior of such a transaction database system with continuous deadlock detection, previous models <ref> [13, 19, 23, 25, 26] </ref> require several parameters to be estimated a priori. One parameter is the probability of lock conflict per lock request. Another parameter is the probability that a transaction is deadlocked with other transactions when a subsequent lock request is not granted. <p> These two parameters in theory can be estimated fairly accurately by first estimating the number of locks owned by active transactions in the system and then computing the probability that each event can occur <ref> [13, 19, 23, 25] </ref>. Another parameter needed is the wait time for a lock by a blocked transaction. This "wait time per lock conflict" parameter is difficult to estimate accurately and existing methods for estimating it are often controversial [11].
Reference: [24] <author> A. Thomasian, </author> <title> "An iterative solution to the queueing network model of a DBMS with dynamic locking," </title> <booktitle> Proc. 13th Computer Measurement Group Conf., </booktitle> <month> Dec. </month> <year> 1982, </year> <pages> pp. 252-261. </pages>
Reference-contexts: To achieve this, we differentiate blocked, non-lock-owner transactions from blocked, lock-owner ones in constructing our Petri net model to provide a more precise information on the number of lock owners in the system as the system evolves over time. As a result, unlike the queueing network models proposed in <ref> [19, 24] </ref>, our Petri net model can be solved noniteratively and efficiently. Second, two separate Petri net models are constructed separately to evaluate the system performance of continuous and periodic deadlock detection algorithms. <p> These SPN models can be solved easily by using a commercial software package such as Stochastic Petri Net Package (SPNP) [5, 17]. Previous performance models based on queueing network <ref> [13, 19, 24] </ref> are non-trivial and difficult to apply. For example, in [13, 19, 24], it involves the concept of changing the customer class of a transaction during the transaction's life time as the transaction requests, acquires, and releases locks. <p> These SPN models can be solved easily by using a commercial software package such as Stochastic Petri Net Package (SPNP) [5, 17]. Previous performance models based on queueing network <ref> [13, 19, 24] </ref> are non-trivial and difficult to apply. For example, in [13, 19, 24], it involves the concept of changing the customer class of a transaction during the transaction's life time as the transaction requests, acquires, and releases locks. Consequently, a special solution technique is used to solve their queueing network models. <p> For example, in [13, 19, 24], it involves the concept of changing the customer class of a transaction during the transaction's life time as the transaction requests, acquires, and releases locks. Consequently, a special solution technique is used to solve their queueing network models. In <ref> [19, 24] </ref>, an iterative solution technique is also used to solve their models. The requirement of using special solution techniques, rather than using a commercial software package (e.g., SHARPE [21]), limits the general applicability of these queueing network models. <p> Every lock owner is assumed to own dN L=2e locks. This assumption is introduced to avoid state space explosion and is also used in previous models. However, we do not assume the number of lock owners, N LO, as a constant as in <ref> [19, 24] </ref>. In our (noniterative) Petri net model, N LO is computed dynamically as the system evolves. Table 1 shows the list of input parameters to our model. 1 Worst placement is the opposite of well placement: each transaction requires the maximum number of granules possible. <p> The methods for estimating N LO will be described later. Since T int is an output of the queueing network model, this method requires T int to be solved repeatedly until it converges. Another way is to estimate D lock as a function of the transaction response time <ref> [24] </ref>.
Reference: [25] <author> A. Thomasian and I.K. Ryu, </author> <title> "Performance analysis of two-phase locking," </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. 17, No. 5, </volume> <month> May </month> <year> 1991, </year> <pages> pp. 386-402. </pages>
Reference-contexts: Otherwise, the transaction waits until it gets its lock. This method is termed "continuous deadlock detection" in the literature [1]. To model the behavior of such a transaction database system with continuous deadlock detection, previous models <ref> [13, 19, 23, 25, 26] </ref> require several parameters to be estimated a priori. One parameter is the probability of lock conflict per lock request. Another parameter is the probability that a transaction is deadlocked with other transactions when a subsequent lock request is not granted. <p> These two parameters in theory can be estimated fairly accurately by first estimating the number of locks owned by active transactions in the system and then computing the probability that each event can occur <ref> [13, 19, 23, 25] </ref>. Another parameter needed is the wait time for a lock by a blocked transaction. This "wait time per lock conflict" parameter is difficult to estimate accurately and existing methods for estimating it are often controversial [11]. <p> Recently, Thomasian and Ryu derived an approximate, noniterative analytical solution for the wait time per lock conflict parameter in closed and open 2PL systems with load control <ref> [25, 26] </ref>. <p> If a transaction locks a granule then it essentially locks all the data items contained in the granule. Of course, when SZ lock = 1 each data item is a granule itself and has its own separate lock, thus covering the special case considered in <ref> [25, 26] </ref>. Not placing a separate lock on a data item may be desirable for performance reasons for certain transaction accessing patterns described below.
Reference: [26] <author> A. Thomasian, </author> <title> "Two-phase locking performance and its thrashing behavior," </title> <journal> ACM Trans. Database Syst., </journal> <volume> Vol. 18, No. 4, </volume> <month> Dec. </month> <year> 1993, </year> <pages> pp. 579-625. 33 </pages>
Reference-contexts: Otherwise, the transaction waits until it gets its lock. This method is termed "continuous deadlock detection" in the literature [1]. To model the behavior of such a transaction database system with continuous deadlock detection, previous models <ref> [13, 19, 23, 25, 26] </ref> require several parameters to be estimated a priori. One parameter is the probability of lock conflict per lock request. Another parameter is the probability that a transaction is deadlocked with other transactions when a subsequent lock request is not granted. <p> Recently, Thomasian and Ryu derived an approximate, noniterative analytical solution for the wait time per lock conflict parameter in closed and open 2PL systems with load control <ref> [25, 26] </ref>. <p> If a transaction locks a granule then it essentially locks all the data items contained in the granule. Of course, when SZ lock = 1 each data item is a granule itself and has its own separate lock, thus covering the special case considered in <ref> [25, 26] </ref>. Not placing a separate lock on a data item may be desirable for performance reasons for certain transaction accessing patterns described below.
References-found: 26

