URL: http://www.cs.cmu.edu/afs/cs/project/able/ftp/refinement-isaw2.ps
Refering-URL: http://www.cs.cmu.edu/afs/cs/project/able/www/paper_abstracts/refinement-isaw2.html
Root-URL: 
Email: garlan@cs.cmu.edu  
Title: Style-Based Refinement for Software Architecture  
Author: David Garlan 
Address: Pittsburgh, PA 15213  
Affiliation: School of Computer Science Carnegie Mellon University  
Abstract: A question that frequently arises for architectural design is "When can I implement a design in style S 1 using a design in style S 2 ?" In this paper I propose a technique for structuring a solution to this kind of problem using the idea of sub-styles. This technique leads to a two-step process in which first, useful subsets of a family of architectures are identified, and second, refinement rules specific to these subsets are established. I will argue that this technique, in combination with an unconventional interpretation of refinement, clarifies how engineers actually carry out architectural refinement and provides a formal framework for establishing the correctness of those methods. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Gregory Abowd, Robert Allen, and David Garlan. </author> <title> Formalizing style to understand descriptions of software architecture. </title> <journal> ACM Transactions on Software Engineering and Methodology, </journal> <month> October </month> <year> 1995. </year>
Reference-contexts: In these systems each filter computes one output value for each input value that it consumes, and the overall graph is acyclic. For this substyle, we can define a simple refinement rule into a shared variable style. (For an example of a formal proof of a similar result, see <ref> [1] </ref>.) Formally, this approach can be characterized by two functions, as illustrated in Figure 1.
Reference: [2] <author> C.A.R. Hoare. </author> <title> Communicating Sequential Processes. </title> <publisher> Prentice Hall, </publisher> <year> 1985. </year>
Reference-contexts: The "classical" approach is to use the notion of behavioral substitutability. That is, the concrete representation should not produce any externally-observable behavior that the abstract representation could not have produced. This is essentially the criterion used by Rapide. It is also the criterion used by CSP <ref> [2] </ref>. But, as Moriconi and others have argued [4], behavioral substitutability may not be strong enough. In general, there may be properties other than computational equivalence that we wish to preserve in the concrete representation. Moriconi proposes that for architectures it is sufficient to impose a requirement of "conservative extension".
Reference: [3] <author> David C Luckham, Lary M. Augustin, John J. Kenney, James Veera, Doug Bryan, and Walter Mann. </author> <title> Specification and analysis of system architecture using Rapide. </title> <journal> IEEE Transactions on Software Engineering, Special Issue on Software Architecture, </journal> <volume> 21(4) </volume> <pages> 336-355, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: That is, system X 2 can be used in place of X 1 if we can find a suitable "abstraction map" from X 2 to X 1 . This is essentially the approach taken by Rapide <ref> [3] </ref>.
Reference: [4] <author> M. Moriconi, X. Qian, and R. Riemenschneider. </author> <title> Correct architecture refinement. </title> <journal> IEEE Transactions on Software Engineering, Special Issue on Software Architecture, </journal> <volume> 21(4) </volume> <pages> 356-372, </pages> <month> April </month> <year> 1995. </year>
Reference-contexts: Since the demonstration of substitutability must range over a possibly infinite collection of systems, it involves more general proof techniques. One such technique, proposed by Moriconi and his associates, is to use a set of compositional refinement patterns <ref> [4] </ref>. The patterns determine local transformations for parts of an architectural description. The patterns are constructed in such a way that the local transformations compose and, if applied systematically to a system, will result in the construction of a system in another style. <p> That is, the concrete representation should not produce any externally-observable behavior that the abstract representation could not have produced. This is essentially the criterion used by Rapide. It is also the criterion used by CSP [2]. But, as Moriconi and others have argued <ref> [4] </ref>, behavioral substitutability may not be strong enough. In general, there may be properties other than computational equivalence that we wish to preserve in the concrete representation. Moriconi proposes that for architectures it is sufficient to impose a requirement of "conservative extension".
References-found: 4

