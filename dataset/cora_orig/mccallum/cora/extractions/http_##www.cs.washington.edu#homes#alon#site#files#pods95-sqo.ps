URL: http://www.cs.washington.edu/homes/alon/site/files/pods95-sqo.ps
Refering-URL: http://www.cs.washington.edu/homes/alon/site/PaperAbstractPresentation_bib16.html
Root-URL: 
Email: levy@research.att.com  sagiv@cs.huji.ac.il  
Title: Semantic Query Optimization in Datalog Programs (Extended Abstract)  
Author: Alon Y. Levy Yehoshua Sagiv 
Address: Jerusalem  
Affiliation: AT&T Bell Laboratories  Hebrew University,  
Abstract: Semantic query optimization refers to the process of using integrity constraints (ic's) in order to optimize the evaluation of queries. The process is well understood in the case of unions of select-project-join queries (i.e., nonrecursive datalog). For arbitrary datalog programs, however, the issue has largely remained an unsolved problem. This paper studies this problem and shows when semantic query optimization can be completely done in recursive rules provided that order constraints and negated EDB subgoals appear only in the recursive rules, but not in the ic's. If either order constraints or negated EDB subgoals are introduced in ic's, then the problem of semantic query optimization becomes undecidable. Since semantic query optimization is closely related to the containment problem of a datalog program in a union of conjunctive queries, our results also imply new decidability and undecidability results for that problem when order constraints and negated EDB subgoals are used. 
Abstract-found: 1
Intro-found: 1
Reference: [CGM88] <author> U. S. Chakravarthy, John Grant, and Jack Minker. </author> <title> Foundations of semantic query optimization for deductive databases. </title> <editor> In Jack Minker, editor, </editor> <booktitle> Foundations of Deductive Databases and Logic Programming, </booktitle> <pages> pages 243-273. </pages> <publisher> Morgan Kaufmann, </publisher> <address> Los Altos, CA, </address> <year> 1988. </year>
Reference-contexts: Semantic query optimization is especially important in applications that require integrating multiple heterogeneous fl Work supported in part by BSF grant 92-00360. sources of data (e.g., [CGMH + 94, LSK95]). The topic of semantic query optimization has been investigated in many papers (e.g., <ref> [Kin81, CGM88] </ref>) and is well understood for queries that can be represented as a union of conjunctive queries. For queries involving recursion, or which cannot otherwise be translated to a union of conjunctive queries (because of aggregation or duplicates), semantic query optimization has largely remained an unsolved problem. <p> Since ic's are a special case of conjunctive queries, the containment algorithm of [CV92] can be used to determine satisfiability of recursive rules in the presence of ic's. Obviously, determining satisfiability of a set of rules is an important part of semantic query optimization. In <ref> [CGM88] </ref>, Chakravarthy et al. have shown that the core of semantic query optimization is computing residues. Intuitively, a residue is some part of an integrity constraint that cannot be mapped into the body of a rule, and therefore, its negation can be added to the rule.
Reference: [CGMH + 94] <author> Sudarshan Chawathe, Hector Garcia-Molina, Joachim Hammer, Kelly Ireland, Yannis Pa-pakonstantinon, Jeffrey Ullman, and Jennifer Widom. </author> <title> The TSIMMIS project: Integration of heterogeneous information sources. </title> <booktitle> In proceedings of IPSJ, </booktitle> <address> Tokyo, Japan, </address> <month> October </month> <year> 1994. </year>
Reference-contexts: Semantic query optimization is especially important in applications that require integrating multiple heterogeneous fl Work supported in part by BSF grant 92-00360. sources of data (e.g., <ref> [CGMH + 94, LSK95] </ref>). The topic of semantic query optimization has been investigated in many papers (e.g., [Kin81, CGM88]) and is well understood for queries that can be represented as a union of conjunctive queries.
Reference: [CV92] <author> Surajit Chaudhuri and Moshe Vardi. </author> <title> On the equivalence of recursive and nonrecursive dat-alog programs. </title> <booktitle> In The Proceedings of the Eleventh ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> San Diego, CA., </address> <pages> pages 55-66, </pages> <year> 1992. </year>
Reference-contexts: First, in [LS92, LMSS93] it was shown how to push order constraints (i.e., selections) in recursive rules. These techniques can be used directly for complete semantic query optimization if, in each ic, only one subgoal is not an order constraint. Secondly, in <ref> [CV92] </ref> it was shown how to test whether a union of conjunctive queries contains a recursive program (assuming that there are neither order constraints nor negated subgoals). Since ic's are a special case of conjunctive queries, the containment algorithm of [CV92] can be used to determine satisfiability of recursive rules in <p> Secondly, in <ref> [CV92] </ref> it was shown how to test whether a union of conjunctive queries contains a recursive program (assuming that there are neither order constraints nor negated subgoals). Since ic's are a special case of conjunctive queries, the containment algorithm of [CV92] can be used to determine satisfiability of recursive rules in the presence of ic's. Obviously, determining satisfiability of a set of rules is an important part of semantic query optimization. In [CGM88], Chakravarthy et al. have shown that the core of semantic query optimization is computing residues. <p> Our work also implies new decidability and undecidability results for the containment problem discussed in <ref> [CV92] </ref>, since we consider rules and ic's that may have order constraints and negated EDB subgoals. 2 Preliminaries A datalog program P consists of function-free Horn rules; its EDB predicates are those appearing only in bodies of rules and its IDB predicates are those appearing in heads and, possibly, in bodies <p> the ic's have those atoms.) * Is the query predicate of a datalog program satisfiable with respect to a set of ic's? When neither order atoms nor negated EDB atoms are present, containment of a datalog program in a union of conjunctive queries has doubly exponential lower and upper bounds <ref> [CV92] </ref>. By Proposition 5.1, the same is true for satisfiability of a query predicate with respect to ic's. This result can be generalized as follows. Theorem 5.1 Satisfiability of the query predicate of a f; :g-program with respect to a set of ic's has doubly exponential lower and upper bounds. <p> In the full version, however, we will show that the algorithm of [LMSS93] can be incorporated into the bottom-up and top-down phases to give an overall doubly-exponential upper bound. The lower bound follows from <ref> [CV92] </ref>. 2 It is worth noting that the complexity of testing unsatisfiability is considerably better than the general case in either one of the following cases (actually, the second case is a generalization of the first). * The program has a single IDB predicate. * We want to test whether all
Reference: [Kin81] <author> J. J. King. </author> <title> Query Optimization by Semantic Reasoning. </title> <type> PhD thesis, </type> <institution> Stanford University, Stanford, </institution> <address> CA, </address> <year> 1981. </year>
Reference-contexts: Semantic query optimization is especially important in applications that require integrating multiple heterogeneous fl Work supported in part by BSF grant 92-00360. sources of data (e.g., [CGMH + 94, LSK95]). The topic of semantic query optimization has been investigated in many papers (e.g., <ref> [Kin81, CGM88] </ref>) and is well understood for queries that can be represented as a union of conjunctive queries. For queries involving recursion, or which cannot otherwise be translated to a union of conjunctive queries (because of aggregation or duplicates), semantic query optimization has largely remained an unsolved problem.
Reference: [Klu88] <author> A. Klug. </author> <title> On conjunctive queries containing inequalities. </title> <journal> Journal of the ACM, </journal> <pages> pages 35(1): 146-160, </pages> <year> 1988. </year>
Reference-contexts: Emptiness of a f; :g-program with respect to a set of fg-ic's is P 2 -complete. 4. Emptiness of a f; :g-program with respect to a set of f; :g-ic's is in EXPSPACE. Proof The upper bounds follow from <ref> [Klu88, LS93] </ref>. The lower bounds of Parts 1 and 3 follow from [SY81] and [vdM92a], respectively. 2 In the remainder of this section, we give some undecidability results for satisfiability. First, satisfiability is undecidable if ic's have order atoms, even when only monadic recursion and 6= are used [vdM92b, LMSS93].
Reference: [LMS94] <author> Alon Y. Levy, Inderpal Singh Mumick, and Yehoshua Sagiv. </author> <title> Query optimization by predicate move-around. </title> <booktitle> In Proceedings of the 20th VLDB Conference, </booktitle> <address> Santiago, Chile, </address> <year> 1994. </year>
Reference: [LMSS93] <author> Alon Y. Levy, Inderpal Singh Mumick, Yehoshua Sagiv, and Oded Shmueli. </author> <title> Equivalence, query-reachability and satisfiability in datalog extensions. </title> <booktitle> In Proceedings of the Twelfth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> Washington D.C., </address> <year> 1993. </year>
Reference-contexts: For queries involving recursion, or which cannot otherwise be translated to a union of conjunctive queries (because of aggregation or duplicates), semantic query optimization has largely remained an unsolved problem. Recent results have shed new light on this subject. First, in <ref> [LS92, LMSS93] </ref> it was shown how to push order constraints (i.e., selections) in recursive rules. These techniques can be used directly for complete semantic query optimization if, in each ic, only one subgoal is not an order constraint. <p> We also show how to transform the program so that it does not have any sequence of rule applications that is guaranteed (by the ic's) to produce an empty result. The algorithm uses the 163 query-tree techniques first developed in [LS92] and later refined in <ref> [LMSS93] </ref>. The key idea behind the query tree algorithm is to attach a label to every node in the tree, describing the residues applicable to that node when it is part of a derivation of the query. <p> Note that in general, query reachability of p (ff 1 ; : : : ; ff n ) implies satisfiability of p, but the converse is not necessarily true. In <ref> [LMSS93] </ref>, it is shown that query reachability and satisfiability are LOGSPACE-reducible to each other. Denoting Appearance of Dense Order and Negation The presence of order atoms and negated EDB atoms increases the complexity of the problems we consider. <p> The algorithm is based on the general paradigm of constructing a query tree <ref> [LS92, LMSS93] </ref>. A query tree for a given datalog program P is a finite AND/OR tree that encodes precisely all derivations of the query predicate q from databases that satisfy the integrity constraints of C. <p> Later, we will generalize the algorithm also to some cases of f; :g-ic's. We assume that the given program P has already been processed by the algorithm of <ref> [LMSS93] </ref> for completely incorporating the constraints implied by the order atoms and negated EDB atoms that appear in the rules. Moreover, we assume that in each rule of P, we have substituted X for Y (or vice-versa) whenever the order atoms of the rule imply that X = Y . <p> Thus, P and P 0 are equivalent for all databases satisfying C. The second part of the theorem follows from the following observations. First, recall that we have assumed that the algorithm of <ref> [LMSS93] </ref> was applied to P prior to our algorithm. Consequently, every symbolic derivation tree of P can be instantiated to a derivation tree from some set of EDB facts (which does not necessarily satisfies C) by instantiating each variable to a distinct constant. <p> This result can be generalized as follows. Theorem 5.1 Satisfiability of the query predicate of a f; :g-program with respect to a set of ic's has doubly exponential lower and upper bounds. Proof As presented, the first step of the algorithm of Section 4.1 is applying the algorithm of <ref> [LMSS93] </ref>, which has an exponential upper bound, and the complexity of the following bottom-up and top-down phases is doubly exponential. In the full version, however, we will show that the algorithm of [LMSS93] can be incorporated into the bottom-up and top-down phases to give an overall doubly-exponential upper bound. <p> Proof As presented, the first step of the algorithm of Section 4.1 is applying the algorithm of <ref> [LMSS93] </ref>, which has an exponential upper bound, and the complexity of the following bottom-up and top-down phases is doubly exponential. In the full version, however, we will show that the algorithm of [LMSS93] can be incorporated into the bottom-up and top-down phases to give an overall doubly-exponential upper bound. <p> The lower bounds of Parts 1 and 3 follow from [SY81] and [vdM92a], respectively. 2 In the remainder of this section, we give some undecidability results for satisfiability. First, satisfiability is undecidable if ic's have order atoms, even when only monadic recursion and 6= are used <ref> [vdM92b, LMSS93] </ref>. In fact, the proof of [LMSS93] shows the following. Theorem 5.3 Satisfiability of the query predicate of a datalog program P with respect to a set C of f6=g-ic's is undecidable, even if P has only unary IDB predicates, one linear recursive rule and two nonrecursive rules. <p> First, satisfiability is undecidable if ic's have order atoms, even when only monadic recursion and 6= are used [vdM92b, LMSS93]. In fact, the proof of <ref> [LMSS93] </ref> shows the following. Theorem 5.3 Satisfiability of the query predicate of a datalog program P with respect to a set C of f6=g-ic's is undecidable, even if P has only unary IDB predicates, one linear recursive rule and two nonrecursive rules. <p> Proof Follows from a result of <ref> [LMSS93] </ref>. 2 6 Appendix: Proof of Theorem 5.4 Proof (Sketch) The proof of Theorem 5.3, which is given in [LMSS93], uses 6= in the ic's. We will show how to replace 6= by a binary EDB predicate neq (X; Y ). First, a few words about the proof of [LMSS93]. <p> Proof Follows from a result of <ref> [LMSS93] </ref>. 2 6 Appendix: Proof of Theorem 5.4 Proof (Sketch) The proof of Theorem 5.3, which is given in [LMSS93], uses 6= in the ic's. We will show how to replace 6= by a binary EDB predicate neq (X; Y ). First, a few words about the proof of [LMSS93]. That proof uses three EDB predicates. <p> of <ref> [LMSS93] </ref>. 2 6 Appendix: Proof of Theorem 5.4 Proof (Sketch) The proof of Theorem 5.3, which is given in [LMSS93], uses 6= in the ic's. We will show how to replace 6= by a binary EDB predicate neq (X; Y ). First, a few words about the proof of [LMSS93]. That proof uses three EDB predicates. The first two, succ (X; Y ) and zero (X), represent the successor and the zero relations, respectively. <p> These ic's are the same as in <ref> [LMSS93] </ref>.
Reference: [LS92] <author> Alon Y. Levy and Yehoshua Sagiv. </author> <title> Constraints and redundancy in Datalog. </title> <booktitle> In The Proceedings of the Eleventh ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> San Diego, CA., </address> <pages> pages 67-80, </pages> <year> 1992. </year>
Reference-contexts: For queries involving recursion, or which cannot otherwise be translated to a union of conjunctive queries (because of aggregation or duplicates), semantic query optimization has largely remained an unsolved problem. Recent results have shed new light on this subject. First, in <ref> [LS92, LMSS93] </ref> it was shown how to push order constraints (i.e., selections) in recursive rules. These techniques can be used directly for complete semantic query optimization if, in each ic, only one subgoal is not an order constraint. <p> We also show how to transform the program so that it does not have any sequence of rule applications that is guaranteed (by the ic's) to produce an empty result. The algorithm uses the 163 query-tree techniques first developed in <ref> [LS92] </ref> and later refined in [LMSS93]. The key idea behind the query tree algorithm is to attach a label to every node in the tree, describing the residues applicable to that node when it is part of a derivation of the query. <p> The algorithm is based on the general paradigm of constructing a query tree <ref> [LS92, LMSS93] </ref>. A query tree for a given datalog program P is a finite AND/OR tree that encodes precisely all derivations of the query predicate q from databases that satisfy the integrity constraints of C. <p> After creating the query tree we remove nodes that are not reachable from the EDB leaves and the root (see <ref> [LS92] </ref>). 168 The query tree created for our example is shown in to the adornments. The rules in the query tree can now be used to obtain a rewritten program that exploits the integrity constraints.
Reference: [LS93] <author> Alon Y. Levy and Yehoshua Sagiv. </author> <title> Queries independent of updates. </title> <booktitle> In Proceedings of the 19th VLDB Conference, Dublin, Ireland, </booktitle> <pages> pages 171-181, </pages> <year> 1993. </year>
Reference-contexts: Emptiness of a f; :g-program with respect to a set of fg-ic's is P 2 -complete. 4. Emptiness of a f; :g-program with respect to a set of f; :g-ic's is in EXPSPACE. Proof The upper bounds follow from <ref> [Klu88, LS93] </ref>. The lower bounds of Parts 1 and 3 follow from [SY81] and [vdM92a], respectively. 2 In the remainder of this section, we give some undecidability results for satisfiability. First, satisfiability is undecidable if ic's have order atoms, even when only monadic recursion and 6= are used [vdM92b, LMSS93].
Reference: [LSK95] <author> Alon Y. Levy, Divesh Srivastava, and Thomas Kirk. </author> <title> Data model and query evaluation in global information systems. </title> <journal> Journal of Intelligent Information Systems, </journal> <note> 1995. Special Issue on Networked Information Discovery and Retrieval (to appear). </note>
Reference-contexts: Semantic query optimization is especially important in applications that require integrating multiple heterogeneous fl Work supported in part by BSF grant 92-00360. sources of data (e.g., <ref> [CGMH + 94, LSK95] </ref>). The topic of semantic query optimization has been investigated in many papers (e.g., [Kin81, CGM88]) and is well understood for queries that can be represented as a union of conjunctive queries.
Reference: [SY81] <author> Y. Sagiv and M. Yannakakis. </author> <title> Equivalence among relational expressions with the union and difference operators. </title> <journal> In J. ACM 27:4 pp. </journal> <pages> 633-655, </pages> <year> 1981. </year>
Reference-contexts: Emptiness of a f; :g-program with respect to a set of f; :g-ic's is in EXPSPACE. Proof The upper bounds follow from [Klu88, LS93]. The lower bounds of Parts 1 and 3 follow from <ref> [SY81] </ref> and [vdM92a], respectively. 2 In the remainder of this section, we give some undecidability results for satisfiability. First, satisfiability is undecidable if ic's have order atoms, even when only monadic recursion and 6= are used [vdM92b, LMSS93]. In fact, the proof of [LMSS93] shows the following.
Reference: [Ull89] <author> Jeffrey D. Ullman. </author> <title> Principles of Database and Knowledge-base Systems, Volumes I, II. </title> <publisher> Computer Science Press, </publisher> <address> Rockville MD, </address> <year> 1989. </year>
Reference-contexts: Order atoms represent a dense order defined on the domain and they may appear in bodies of rules provided that rules are safe as defined in <ref> [Ull89] </ref>. We also consider a limited form of negation by allowing negated EDB atoms in bodies of rules provided that negation is used safely. Note that the term "atom" refers to an atom that appears positively and the term "literal" refers to an atom that appears positively or negatively.
Reference: [Var89] <author> Moshe Y. Vardi. </author> <title> Automata theory for database theoreticians. </title> <booktitle> In Proceedings of the Eighth Symposium on Principles of Database Systems (PODS), </booktitle> <pages> pages 83-92, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: The children of a rule node are the goal nodes for the subgoals in the body of that rule. Intuitively, the query tree can be viewed as a tree automaton that accepts only the possible derivations of the query <ref> [Var89] </ref>. Once a query tree is constructed for a given program, a rewritten program can be obtained by forming a rule for every rule node in the tree.
Reference: [vdM92a] <author> Ron van der Meyden. </author> <title> The complexity of querying indefinite data about linearly ordered domains. </title> <booktitle> In The Proceedings of the Eleventh ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, </booktitle> <address> San Diego, CA., </address> <pages> pages 331-345, </pages> <year> 1992. </year>
Reference-contexts: Emptiness of a f; :g-program with respect to a set of f; :g-ic's is in EXPSPACE. Proof The upper bounds follow from [Klu88, LS93]. The lower bounds of Parts 1 and 3 follow from [SY81] and <ref> [vdM92a] </ref>, respectively. 2 In the remainder of this section, we give some undecidability results for satisfiability. First, satisfiability is undecidable if ic's have order atoms, even when only monadic recursion and 6= are used [vdM92b, LMSS93]. In fact, the proof of [LMSS93] shows the following.
Reference: [vdM92b] <author> Ron van der Meyden. </author> <title> The Complexity of Querying Indefinite Information: Defined Relations Recursion and Linear Order. </title> <type> PhD thesis, </type> <institution> Rutgers University, </institution> <address> New Brunswick, New Jersey, </address> <year> 1992. </year> <month> 173 </month>
Reference-contexts: The lower bounds of Parts 1 and 3 follow from [SY81] and [vdM92a], respectively. 2 In the remainder of this section, we give some undecidability results for satisfiability. First, satisfiability is undecidable if ic's have order atoms, even when only monadic recursion and 6= are used <ref> [vdM92b, LMSS93] </ref>. In fact, the proof of [LMSS93] shows the following. Theorem 5.3 Satisfiability of the query predicate of a datalog program P with respect to a set C of f6=g-ic's is undecidable, even if P has only unary IDB predicates, one linear recursive rule and two nonrecursive rules.
References-found: 15

