URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-93-1147/CS-TR-93-1147.ps.Z
Refering-URL: http://www.cs.wisc.edu/~fischer/ftp/pub/tech-reports/ncstrl.uwmadison/CS-TR-93-1147/
Root-URL: http://www.cs.wisc.edu
Title: Batch Scheduling in Parallel Database Systems  
Author: Manish Mehta Valery Soloviev David J. DeWitt 
Affiliation: Computer Science Department Computer Science Department Computer Science Department University of Wisconsin-Madison North Dakota State University University of Wisconsin-Madison  
Abstract: Current techniques for query scheduling in a parallel database system schedule a single query at a time. This paper investigates scheduling of queries for parallel database systems by dividing the workload into batches. We propose scheduling algorithms which exploit the common operations within the queries in a batch. The performance of the proposed algorithms is studied using a simple analytical model and a detailed simulation model. We show that batch scheduling can provide significant savings compared to single query scheduling for a variety of system and workload parameters. 1. Introduction 
Abstract-found: 1
Intro-found: 1
Reference: [Bobe92a] <author> Bober, P., and Carey, M., </author> <title> "On Mixing Queries and Transactions via Multiversion Locking," </title> <booktitle> Proc. 8th IEEE Data Engineering Conf., </booktitle> <address> Phoenix, AZ, </address> <month> Feb. </month> <year> 1992. </year>
Reference: [Bobe92b] <author> Bober, P., and Carey, M., </author> <title> "Multiversion Query Locking," </title> <booktitle> Proc. 18th Int'l. VLDB Conf., </booktitle> <address> Vancouver, BC, Canada, </address> <month> Aug. </month> <year> 1992, </year> <note> to appear. </note>
Reference: [Bora90] <author> Boral, H. et al, </author> <title> "Prototyping Bubba: A Highly Parallel Database System," </title> <journal> IEEE Trans. on Knowledge and Data Engineering 2(1), </journal> <month> March </month> <year> 1990. </year>
Reference-contexts: Current trends show that customer applications on these databases are growing in size and complexity with an ever increasing demand for performance. Multiprocessor database machines (GAMMA [DeWi90], Volcano [Grae89], Bubba <ref> [Bora90] </ref>, XPRS [Ston88], DBC/1012 [Tera85], Non-Stop SQL [Tand88]), with their promise of high availability, scalability and performance, are increasingly the systems of choice for large applications. Current parallel database configurations already contain up to several hundred processing nodes and future systems are projected to be even bigger.
Reference: [Brow92] <author> Brown, K., et al, </author> <title> "Resource Allocation and Scheduling Issues for Mixed Database Workloads", Comp. Sc. </title> <type> Tech. Rep. TR 1095, </type> <institution> University of Wisconsin-Madison, </institution> <month> July, </month> <year> 1992. </year>
Reference-contexts: In particular, none of these earlier studies have determined the best way of scheduling multiple query workloads. The only related work that we are -3 aware of is <ref> [Brow92] </ref>, which examines the effect of different memory allocation schemes in a mixed workload of short transactions and multiple large queries. Even this is only a preliminary study and does not provide answers to important policy questions.
Reference: [Chak86] <author> Chakravarthy, U. S. et al, </author> <title> "Semantic Query Optimization in Expert Systems and Database Systems", Expert Database Systems: </title> <booktitle> Proc. of 1st International Workshop, </booktitle> <address> Menlo Park, Calif. </address> <year> 1986. </year>
Reference: [Chen92a] <author> Chen, Ming-Syan et al, </author> <title> "Using Segmented Right-Deep Trees for the Execution of Pipelined Hash Joins", </title> <booktitle> Proc. 18th VLDB Conf., to appear, </booktitle> <address> Vancouver, Canada, </address> <month> August </month> <year> 1992. </year>
Reference-contexts: Scheduling single queries for parallel systems was studied in [Schn90], which compared the tradeoffs between various scheduling algorithms for complex join queries and demonstrated that the best scheduling algorithm depends on the structure of the query and the resources available for its execution. This issue was further explored in <ref> [Chen92a] </ref> which studied segmented right-deep scheduling. [Chen92b] studied processor allocation techniques for executing complex join queries. While the issues involved in scheduling a single query are now fairly well understood, little is known about the applicability of these techniques in complex, multi-user environments.
Reference: [Chen92b] <author> Chen, Ming-Syan et al, </author> <title> "Scheduling and Processor Allocation for Parallel Execution of multi-join Queries", </title> <booktitle> Proc. 8th IEEE Data Engineering Conf., </booktitle> <address> Phoenix, AZ, </address> <month> Feb. </month> <year> 1992. </year>
Reference-contexts: This issue was further explored in [Chen92a] which studied segmented right-deep scheduling. <ref> [Chen92b] </ref> studied processor allocation techniques for executing complex join queries. While the issues involved in scheduling a single query are now fairly well understood, little is known about the applicability of these techniques in complex, multi-user environments.
Reference: [DeWi84] <author> DeWitt, D., et al, </author> <title> "Implementation Techniques for Main Memory Database Systems," </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Boston, MA, </address> <month> June </month> <year> 1984. </year>
Reference-contexts: Sharing Joins The join operator is one of the most complex database operators to execute. While a number of different join algorithms have been proposed, we restrict out attention to the hybrid-hash join algorithm <ref> [DeWi84, DeWi85] </ref>. This algorithm executes in two phases, termed the build and probe phases. In the build phase, the smaller relation is scanned and an in-memory hash table is constructed by hashing each tuple on the join attribute.
Reference: [DeWi85] <author> Dewitt, D. and Gerber, R., </author> <title> "Multiprocessor Hash-Based Join Algorithms", </title> <booktitle> Proc. 11th VLDB Conf., </booktitle> <month> August </month> <year> 1985. </year>
Reference-contexts: Sharing Joins The join operator is one of the most complex database operators to execute. While a number of different join algorithms have been proposed, we restrict out attention to the hybrid-hash join algorithm <ref> [DeWi84, DeWi85] </ref>. This algorithm executes in two phases, termed the build and probe phases. In the build phase, the smaller relation is scanned and an in-memory hash table is constructed by hashing each tuple on the join attribute. <p> Since hash-joins are very memory intensive algorithms, reducing memory usage for one set of queries can significantly improve performance by making additional memory available to other queries. In the case of a multiprocessor join algorithm <ref> [Kits83, Vald84, DeWi85, Schn90] </ref>, the building and probing relations are horizontally partitioned across multiple processors by hashing on the join attribute.
Reference: [DeWi90] <author> DeWitt, D., et al, </author> <title> "The Gamma Database Machine Project", </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <month> March </month> <year> 1990. </year>
Reference-contexts: 1. Introduction The improvements in database technology over the past decade have made database management systems (DBMSs) an essential component of many application domains. Current trends show that customer applications on these databases are growing in size and complexity with an ever increasing demand for performance. Multiprocessor database machines (GAMMA <ref> [DeWi90] </ref>, Volcano [Grae89], Bubba [Bora90], XPRS [Ston88], DBC/1012 [Tera85], Non-Stop SQL [Tand88]), with their promise of high availability, scalability and performance, are increasingly the systems of choice for large applications.
Reference: [DeWi92] <author> Dewitt., D. and J. Gray, </author> <title> "Parallel Database Systems: The Future of High Performance Database Systems", </title> <journal> CACM, </journal> <volume> 35(6), </volume> <month> June </month> <year> 1992. </year>
Reference: [Fink82] <author> Finkelstein, F., </author> <title> "Common Expression Analysis in Database Applications", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Orlando, FL, </address> <month> June </month> <year> 1982. </year>
Reference: [Ghan90] <author> Ghandeharizadeh, S. and D. J. DeWitt, </author> <title> "Hybrid-Range Partitioning Strategy: A New Declustering Strategy for Multiprocessor Database Machines," </title> <booktitle> Proc. 16th VLDB Conf., </booktitle> <address> Melbourne, Australia, </address> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: The earlier model was a useful starting point since it had been validated against the actual Gamma implementation; it had also been used extensively in previous work on parallel database machines <ref> [Ghan90, Schn90, Hsia91] </ref>. The new simulator, which is much more modular, is written in the CSIM/C++ process-oriented simulation language [Schw90]. The simulator accurately captures the algorithms and techniques used in Gamma, and it is currently being used as an experimental vehicle in several ongoing research studies. <p> For example, if an index is employed, only the relevant data tuples need to be read. Also, in our performance study, accesses to the relations were made on all nodes of the system. In several cases, if a declustering strategy other than round-robin is used (multi-attribute partitioning <ref> [Ghan90] </ref>, we can restrict access to only a subset of the nodes in the system; if the relations are range partitioned, two selects may be scheduled on disjoint nodes in which case sharing is not possible.
Reference: [Grae89] <author> Gray, J., ed., "Volcano: </author> <title> An extensible and parallel dataflow query processing system.", </title> <institution> Computer Science Technical Report, Oregon Graduate Center, </institution> <address> Beavorton, OR, </address> <month> June </month> <year> 1989. </year>
Reference-contexts: Current trends show that customer applications on these databases are growing in size and complexity with an ever increasing demand for performance. Multiprocessor database machines (GAMMA [DeWi90], Volcano <ref> [Grae89] </ref>, Bubba [Bora90], XPRS [Ston88], DBC/1012 [Tera85], Non-Stop SQL [Tand88]), with their promise of high availability, scalability and performance, are increasingly the systems of choice for large applications. Current parallel database configurations already contain up to several hundred processing nodes and future systems are projected to be even bigger.
Reference: [Gran80] <author> Grant, J. and Minker, J., </author> <title> "Optimization in Deductive and Conventional Relational Database Systems", </title> <booktitle> Advances in Data Base Systems, </booktitle> <month> September </month> <year> 1980. </year>
Reference-contexts: This allows, for example, two selections with non-overlapping predicates, to be processed using a single relation scan. The previous approaches would not have found anything in common between the two selections. Operator sharing was also proposed in <ref> [Gran80] </ref> in the context of optimization in deductive databases. A significant difference between our work and previous proposals is that compile-time optimization techniques tend to ignore issues of resource allocation.
Reference: [Haas90] <author> Haas, L. et. al., </author> <title> "Starburst Mid-Flight: As the Dust Clears", </title> <journal> IEEE Trans. on Knowledge and Data Eng., </journal> <volume> 2(1), </volume> <month> March, </month> <year> 1990. </year>
Reference-contexts: The buffer pool models a set of main memory page frames. Page replacement in the buffer pool is controlled via the LRU policy extended with "love/hate" hints (like those used in the Starburst buffer manager <ref> [Haas90] </ref>). These hints are provided by the various relational operators when fixed pages are unpinned. For example, "love" hints are given by the index scan operator to keep index pages in memory; "hate" hints are used by the sequential scan operator to prevent buffer pool flooding.
Reference: [Hall74] <author> Hall, P.V., </author> <title> "Common Subexpression Identification in General Algebraic Systems", </title> <type> Tech. Rep. </type> <institution> UKSC 0060, IBM United Kingdom Scientific Centre, </institution> <month> Nov. </month> <year> 1974. </year>
Reference: [Hsia91] <author> Hsiao, H. I. and D. J. Dewitt, </author> <title> "A Performance Study of Three High-Availability Data Replication Strategies", </title> <booktitle> Proc. 1st Int'l Conf. on Parallel and Distributed Information Systems, </booktitle> <address> Miami Beach, FA, </address> <month> Dec. </month> <year> 1991. </year>
Reference-contexts: The earlier model was a useful starting point since it had been validated against the actual Gamma implementation; it had also been used extensively in previous work on parallel database machines <ref> [Ghan90, Schn90, Hsia91] </ref>. The new simulator, which is much more modular, is written in the CSIM/C++ process-oriented simulation language [Schw90]. The simulator accurately captures the algorithms and techniques used in Gamma, and it is currently being used as an experimental vehicle in several ongoing research studies.
Reference: [Ioan90] <author> Ioannidis, Y. and Kang, Y. C., </author> <title> "Randomized Algorithms for Optimizing Large Join Queries", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Atlantic City, NJ, </address> <month> May. </month> <year> 1990. </year>
Reference-contexts: Related Work Single query scheduling has received increasing attention recently. Using the optimization techniques first proposed in System R [Seli79] as a basis, simple query optimization techniques have been extended to handle larger and more complex queries ([Kris86], [Ioan87], [Swam88], <ref> [Ioan90] </ref>). Scheduling single queries for parallel systems was studied in [Schn90], which compared the tradeoffs between various scheduling algorithms for complex join queries and demonstrated that the best scheduling algorithm depends on the structure of the query and the resources available for its execution.
Reference: [Kris86] <author> Krishnamurthy, R., Boral., H. and C. Zaniolo, </author> <title> "Optimization of Nonrecursive Queries", </title> <booktitle> Proceedings 12th VLDB Conf., </booktitle> <month> August </month> <year> 1986. </year>
Reference: [Kits83] <author> Kitsuregawa, M., Tanaka, H., and M. Takagi, </author> <title> "Application of Hash to Data Base Machine and its Architecture", </title> <journal> New Generation Computing, </journal> <volume> Vol. 1, No. 1, </volume> <year> 1983. </year>
Reference-contexts: Since hash-joins are very memory intensive algorithms, reducing memory usage for one set of queries can significantly improve performance by making additional memory available to other queries. In the case of a multiprocessor join algorithm <ref> [Kits83, Vald84, DeWi85, Schn90] </ref>, the building and probing relations are horizontally partitioned across multiple processors by hashing on the join attribute.
Reference: [Livn87] <author> Livny, M., S. Khoshafian, and H. Boral, </author> <title> "Multi-Disk Management Algorithms", </title> <booktitle> Proc. ACM SIGMETRICS Conf., </booktitle> <address> Alberta, Canada, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: This node controls the scheduling and execution of all transactions present in the system. The Database is modeled as a set of relations and indices. The relations (and their associated indices) are declustered <ref> [Ries78, Livn87] </ref> over all the nodes. The simulator models the parallel database system as a closed queueing system, with the workload originating from a fixed set of terminals. Given this background, we can now turn our attention to the details of the various components of the simulator. 5.2.
Reference: [Ries78] <author> Ries, D. and R. Epstein, </author> <title> "Evaluation of Distribution Criteria for Distributed Database Systems", </title> <type> UCBERL Technical Report M78/22, </type> <institution> UC Berkeley, </institution> <month> May </month> <year> 1978. </year> <month> -24 </month>
Reference-contexts: This node controls the scheduling and execution of all transactions present in the system. The Database is modeled as a set of relations and indices. The relations (and their associated indices) are declustered <ref> [Ries78, Livn87] </ref> over all the nodes. The simulator models the parallel database system as a closed queueing system, with the workload originating from a fixed set of terminals. Given this background, we can now turn our attention to the details of the various components of the simulator. 5.2.
Reference: [Schn89] <author> Schneider, D. and D. DeWitt, </author> <title> "A Performance Evaluation of Four Parallel Join Algorithms in a Shared--Nothing Multiprocessor Environment", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Portland, OR, </address> <month> June </month> <year> 1989. </year>
Reference: [Schn90] <author> Schneider, D. and D. DeWitt, </author> <title> "Tradeoffs in Processing Complex Join Queries via Hashing in Multiprocessor Database Machines," </title> <booktitle> Proc. 16th VLDB Conf., </booktitle> <address> Melbourne, Australia, </address> <month> Aug. </month> <year> 1990. </year>
Reference-contexts: Using the optimization techniques first proposed in System R [Seli79] as a basis, simple query optimization techniques have been extended to handle larger and more complex queries ([Kris86], [Ioan87], [Swam88], [Ioan90]). Scheduling single queries for parallel systems was studied in <ref> [Schn90] </ref>, which compared the tradeoffs between various scheduling algorithms for complex join queries and demonstrated that the best scheduling algorithm depends on the structure of the query and the resources available for its execution. <p> Since hash-joins are very memory intensive algorithms, reducing memory usage for one set of queries can significantly improve performance by making additional memory available to other queries. In the case of a multiprocessor join algorithm <ref> [Kits83, Vald84, DeWi85, Schn90] </ref>, the building and probing relations are horizontally partitioned across multiple processors by hashing on the join attribute. <p> Single join queries can be scheduled in only two ways the only choice being which of the two relations is used as the building relation. In contrast, for a more complex multi-join query, there are several execution strategies including left-deep, right-deep, and bushy <ref> [Schn90] </ref>. As the relative performance of these alternatives is not known for a multi-query environment, including multi-join queries in our workload would not have allowed the separation of the effects of sharing from other query scheduling issues. <p> The earlier model was a useful starting point since it had been validated against the actual Gamma implementation; it had also been used extensively in previous work on parallel database machines <ref> [Ghan90, Schn90, Hsia91] </ref>. The new simulator, which is much more modular, is written in the CSIM/C++ process-oriented simulation language [Schw90]. The simulator accurately captures the algorithms and techniques used in Gamma, and it is currently being used as an experimental vehicle in several ongoing research studies.
Reference: [Schw90] <author> Schwetman, H., </author> <title> CSIM Users' Guide, </title> <type> MCC Technical Report No. </type> <institution> ACT-126-90, Microelectronics and Computer Technology Corp., Austin, TX, </institution> <month> March </month> <year> 1990. </year>
Reference-contexts: The new simulator, which is much more modular, is written in the CSIM/C++ process-oriented simulation language <ref> [Schw90] </ref>. The simulator accurately captures the algorithms and techniques used in Gamma, and it is currently being used as an experimental vehicle in several ongoing research studies.
Reference: [Seli79] <author> Selinger, P. G. et. al., </author> <title> "Access Path Selection in a Relational Database Management System", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <year> 1979. </year>
Reference-contexts: Section 6 presents the results of our performance study and Section 7 contains our conclusions and suggestions for future work. 2. Related Work Single query scheduling has received increasing attention recently. Using the optimization techniques first proposed in System R <ref> [Seli79] </ref> as a basis, simple query optimization techniques have been extended to handle larger and more complex queries ([Kris86], [Ioan87], [Swam88], [Ioan90]).
Reference: [Sell88] <author> Sellis, T., </author> <title> "Multiple Query Optimization", </title> <journal> ACM TODS 13(1), </journal> <month> March </month> <year> 1988. </year>
Reference: [Ston86] <author> Stonebraker, M., </author> <title> "The Case for Shared Nothing", </title> <booktitle> Proc. Int'l Conf. on Data Engineering, </booktitle> <year> 1986. </year>
Reference-contexts: Simulator Overview The simulator models a shared-nothing <ref> [Ston86] </ref> parallel database system. The main components of such a system are shown in Figure 5. The system consists of a number of Processing Nodes connected in a shared-nothing manner via an Interconnection Network.
Reference: [Ston88] <editor> Stonebraker, M. et. al., </editor> <booktitle> "The Design of XPRS," Proc. 14th VLDB Conf., </booktitle> <address> Los Angeles, CA, </address> <month> September </month> <year> 1988. </year>
Reference-contexts: Current trends show that customer applications on these databases are growing in size and complexity with an ever increasing demand for performance. Multiprocessor database machines (GAMMA [DeWi90], Volcano [Grae89], Bubba [Bora90], XPRS <ref> [Ston88] </ref>, DBC/1012 [Tera85], Non-Stop SQL [Tand88]), with their promise of high availability, scalability and performance, are increasingly the systems of choice for large applications. Current parallel database configurations already contain up to several hundred processing nodes and future systems are projected to be even bigger.
Reference: [Swam88] <author> Swami. A. and A. Gupta, </author> <title> "Optimization of Large Join Queries", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <month> June </month> <year> 1988. </year>
Reference-contexts: Related Work Single query scheduling has received increasing attention recently. Using the optimization techniques first proposed in System R [Seli79] as a basis, simple query optimization techniques have been extended to handle larger and more complex queries ([Kris86], [Ioan87], <ref> [Swam88] </ref>, [Ioan90]). Scheduling single queries for parallel systems was studied in [Schn90], which compared the tradeoffs between various scheduling algorithms for complex join queries and demonstrated that the best scheduling algorithm depends on the structure of the query and the resources available for its execution.
Reference: [Tand88] <author> Tandem Performance Group, </author> <title> "A benchmark of non-stop SQL on the debit credit transaction", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <address> Chicago, IL, </address> <month> June </month> <year> 1988. </year>
Reference-contexts: Current trends show that customer applications on these databases are growing in size and complexity with an ever increasing demand for performance. Multiprocessor database machines (GAMMA [DeWi90], Volcano [Grae89], Bubba [Bora90], XPRS [Ston88], DBC/1012 [Tera85], Non-Stop SQL <ref> [Tand88] </ref>), with their promise of high availability, scalability and performance, are increasingly the systems of choice for large applications. Current parallel database configurations already contain up to several hundred processing nodes and future systems are projected to be even bigger.
Reference: [Tera85] <institution> Teradata Corp., "DBC/1012 Data Base Computer System Manual", Teradata Corp. </institution> <note> Document No. C10-0001-02, Release 2.0, </note> <month> November </month> <year> 1985 </year>
Reference-contexts: Current trends show that customer applications on these databases are growing in size and complexity with an ever increasing demand for performance. Multiprocessor database machines (GAMMA [DeWi90], Volcano [Grae89], Bubba [Bora90], XPRS [Ston88], DBC/1012 <ref> [Tera85] </ref>, Non-Stop SQL [Tand88]), with their promise of high availability, scalability and performance, are increasingly the systems of choice for large applications. Current parallel database configurations already contain up to several hundred processing nodes and future systems are projected to be even bigger.
Reference: [Vald84] <author> Valduriez, P. and G. Gardarin, </author> <title> "Join and Semi-Join Algorithms for a Multiprocessor Database Machine", </title> <journal> ACM Trans. on Database Systems, </journal> <volume> 9(1), </volume> <month> March, </month> <year> 1984. </year>
Reference-contexts: Since hash-joins are very memory intensive algorithms, reducing memory usage for one set of queries can significantly improve performance by making additional memory available to other queries. In the case of a multiprocessor join algorithm <ref> [Kits83, Vald84, DeWi85, Schn90] </ref>, the building and probing relations are horizontally partitioned across multiple processors by hashing on the join attribute.
Reference: [Yack92] <author> Yackel., J. and Meyer., R. R., </author> <title> "Optimal Tilings for Parallel Database Design", </title> <booktitle> Advances in Optimization and Parallel Computing, </booktitle> <publisher> North-Holland, </publisher> <year> 1992, </year> <editor> ed. P. M. </editor> <publisher> Pardalos. </publisher>
Reference-contexts: Our goal is to employ a hash function that minimizes this replication. The solution models the hashing as an integer programming problem which has been studied in the context of data placement for parallel systems in <ref> [Yack92] </ref>. The results show that the replication factor can be approximated by P k-1/k where P is the number of processors and k is the actual number of attributes used for hashing 2 .
Reference: [Yann87] <author> Ioannidis, Y. and Wong., E., </author> <title> "Query Optimization by Simulated Annealing", </title> <booktitle> Proc. ACM SIGMOD Conf., </booktitle> <month> June </month> <year> 1987. </year>
Reference: [Zipf49] <author> Zipf., G. K., </author> <title> "Human Behavior and the Principle of Least Effort", </title> <publisher> Addison Wesley, </publisher> <address> Reading, MA, </address> <year> 1949. </year> <month> -25 </month>
Reference-contexts: This will not only reduce the number of I/Os performed but also the number of CPU cycles consumed. Other examples of operators hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh 2 We assume that the usage of attributes in join predicates follows a Zipfian distribution <ref> [Zipf49] </ref> with z = 1.5. This is a skewed distribution where the most probable attribute is likely to be chosen 50% of the time and the other half is distributed among the rest of the elements.
References-found: 37

