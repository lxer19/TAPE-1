URL: http://www.cs.wustl.edu/~schmidt/wrapper-facade.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/new.html
Root-URL: http://www.cs.wustl.edu
Email: schmidt@cs.wustl.edu  
Title: Wrapper Facade A Structural Pattern for Encapsulating Functions within Classes  
Author: Douglas C. Schmidt 
Address: St. Louis, MO 63130, (314) 935-7538  
Affiliation: Department of Computer Science Washington University  
Abstract: An earlier version of this paper appeared in the C++ Report magazine, February, 1999. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal, </author> <title> Pattern-Oriented Software Architecture A System of Patterns. </title> <publisher> Wiley and Sons, </publisher> <year> 1996. </year>
Reference-contexts: This paper illustrates how the Wrapper Facade pattern can help make these types of applications more concise, robust, portable, and maintainable. This paper is organized as follows: Section 2 describes the Wrapper Facade pattern in detail using the Siemens format <ref> [1] </ref> and Section 3 presents concluding remarks. 2 Wrapper Facade Pattern 2.1 Intent Encapsulate low-level functions and data structures within more concise, robust, portable, and maintainable higher-level object-oriented class interfaces. 2.2 Example To illustrate the Wrapper Facade pattern, consider the server for a distributed logging service shown in Figure 1.
Reference: [2] <author> W. R. Stevens, </author> <title> UNIX Network Programming, First Edition. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: Logging records and connection requests can arrive concurrently on multiple socket handles. Each handle identifies network communication resources managed within an OS. Clients communicate with the logging server using a connection-oriented protocol like TCP <ref> [2] </ref>. Thus, when a client wants to log data, it must first send a connection request to the logging server. The server accepts connection requests using a handle factory, which listens on a network address known to clients.
Reference: [3] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shivalin-giah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> Beyond Multiprocessing... Multithreading the SunOS Kernel, </title> <booktitle> in Proceedings of the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: A common way to develop a logging server that processes multiple clients concurrently is to use low-level C language 1 functions and data structures for threading, synchronization and network communication. For instance, Figure 2 illus trates the use of Solaris threads <ref> [3] </ref> and the socket [4] net work programming API to develop a multi-threaded logging server.
Reference: [4] <author> W. R. Stevens, </author> <title> UNIX Network Programming, Second Edition. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1997. </year>
Reference-contexts: A common way to develop a logging server that processes multiple clients concurrently is to use low-level C language 1 functions and data structures for threading, synchronization and network communication. For instance, Figure 2 illus trates the use of Solaris threads [3] and the socket <ref> [4] </ref> net work programming API to develop a multi-threaded logging server.
Reference: [5] <author> D. C. Schmidt, </author> <title> IPC SAP: An Object-Oriented Interface to Interprocess Communication Services, </title> <journal> C++ Report, </journal> <volume> vol. 4, </volume> <month> November/December </month> <year> 1992. </year>
Reference-contexts: For instance, the code for creating and initializing an acceptor socket in the main function in Section 2.2 is prone to errors, such as failing to zero-out the sock addr or not using htons on the logging port number <ref> [5] </ref>. The locking code is also easy to misuse. For example, if the write call returns 1 the logging handler code breaks out of the loop without releasing the lock. Similarly, the socket handle h will not be closed if the nested for loop returns when it encounters an error. <p> can use the C++ private access control specifier to disallow copying and assignment of mutexes, which is an erroneous use-case that is not prevented by the less strongly-typed C programming API. * The socket wrapper facades: The socket API is much larger and more expressive than the Solaris mutex API <ref> [5] </ref>. Therefore, we must define a group of related wrap per facade classes to encapsulate sockets. <p> SOCKET handle_; -; Note how the constructor for the SOCK Acceptor ensures that the low-level socket, bind, and listen functions are always called in the right order. A complete set of wrapper facades for sockets <ref> [5] </ref> would also include a SOCK Connector, which encapsulates the active connection establishment logic [10]. * The threading facade: Many threading APIs are available on different OS platforms, including Solaris threads, POSIX Pthreads, and Win32 threads. <p> This overhead can be particularly problematic for embedded systems that must be efficient and have small memory footprints. The drawbacks of exception handling are particularly problematic for wrapper facades that encapsulate kernel-level device drivers or low-level native OS APIs that must run portably on many platforms <ref> [5] </ref>. For these types of wrapper facades, a more portable, efficient, and thread-safe way to handle errors is to define an error handler abstraction that maintains information about the success or failure of operations explicitly.
Reference: [6] <author> H. Spencer and G. Collyer, </author> <title> #ifdef Considered Harmful, or Portability Experience with C News, </title> <booktitle> in Proceedings of the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: High maintenance effort: C and C++ developers typically achieve portability by explicitly adding conditional compilation directives into their application source code using #ifdefs. However, using conditional compilation to address platform-specific variations at all points of use makes it hard to maintain and extend the application <ref> [6] </ref>. In particular, the physical design complexity [7] of the application software is very high since platform-specific implementation details are scattered throughout the application source files.
Reference: [7] <author> J. Lakos, </author> <title> Large-scale Software Development with C++. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: However, using conditional compilation to address platform-specific variations at all points of use makes it hard to maintain and extend the application [6]. In particular, the physical design complexity <ref> [7] </ref> of the application software is very high since platform-specific implementation details are scattered throughout the application source files. For instance, the #ifdefs that handle Win32 and So-laris portability with respect to the data type of a socket, i.e., SOCKET vs. int, impedes the readability and maintainability of the code. <p> Moreover, the Wrapper Facade pattern improves software structure by replacing an application configuration strategy based on physical design entities, such as files and # ifdefs, with logical design entities, such as base classes, subclasses, and their relationships <ref> [7] </ref>. It is generally easier to understand and maintain applications in terms of their logical design rather than their physical design.
Reference: [8] <author> D. C. Schmidt, </author> <title> ACE: an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: NETWORKNETWORK SERVERSERVER LOGGING SERVERLOGGING SERVER LoggingLogging HandlerHandler LoggingLogging HandlerHandler LoggingLogging AcceptorAcceptor 1: SOCK Acceptor 2: accept () 4: spawn () 3: connect () 5: send () 6: recv () 7: write () CLIENTCLIENT AA CLIENTCLIENT BB 5: send () 6: recv () 7: write () components from the ACE framework <ref> [8] </ref>. ACE provides a rich set of reusable C++ wrappers and framework components that perform common communication software tasks across a wide range of OS platforms. The following steps can be taken to implement the Wrapper Facade pattern: 1. <p> The ACE framework: The mutex, thread, and socket wrapper facades described in Section 2.8 are based on components in the ACE framework <ref> [8] </ref>, such as the ACE Thread Mutex, ACE Thread Manager, and ACE SOCK* classes, respectively. Rogue Wave class libraries: Rogue Wave's Net.h++ and Threads.h++ class libraries implement wrapper facades for sockets, threads, and synchronization mechanisms on a number of OS platforms. <p> Implementations of the ACE wrapper facade components described in this paper are freely available in the ACE <ref> [8] </ref> software distribution at URL www.cs.wustl.edu/schmidt/ACE.html. This distribution contains complete C++ source code, documentation, and example test drivers developed at Washington University, St. Louis. ACE is currently being used in many communication software projects at companies like Bellcore, Boeing, DEC, Ericsson, Kodak, Lucent, Motorola, SAIC, and Siemens.
Reference: [9] <author> E. Gamma, R. Helm, R. Johnson, and J. Vlissides, </author> <title> Design Patterns: Elements of Reusable Object-Oriented Software. </title> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: To enhance extensibility, it is also possible to add another level of indirection by dynamically dispatching the wrapper facade method implementations. In this case, the wrapper facade classes play the role of the Abstraction in the Bridge pattern <ref> [9] </ref>. D. Determine where to encapsulate platform-specific variation: Minimizing platform-specific application code is an important benefit of using the Wrapper Facade pattern. Thus, although wrapper facade class method implementations may differ across different OS platforms they should provide uniform, platform-independent interfaces. <p> However, languages that support inlining, such as C++, can implement this pattern with no significant overhead since compilers can inline the method calls used to implement the wrapper facades. 2.12 See Also The Wrapper Facade pattern is similar to the Facade pattern <ref> [9] </ref>. The intent of the Facade pattern is to simplify the interface for a subsystem. <p> In general, Facades hide complex class relationships behind a simpler API, whereas Wrapper Facades hide complex function and data structure relationships behind a richer class API. 9 The Wrapper Facade pattern can be implemented with the Bridge pattern <ref> [9] </ref> if dynamic dispatching is used to implement wrapper facade methods that play the role of the Abstraction in the Bridge pattern. 3 Concluding Remarks This paper describes the Wrapper Facade pattern and gives a detailed example illustrating how to use it.
Reference: [10] <author> D. C. Schmidt, </author> <title> Acceptor and Connector: Design Patterns for Initializing Communication Services, in Pattern Languages of Program Design (R. </title> <editor> Martin, F. Buschmann, and D. Riehle, eds.), </editor> <address> Reading, MA: </address> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: SOCKET handle_; -; Note how this class ensures that a socket handle is automati cally closed when a SOCK Stream object goes out of scope. SOCK Stream objects are created by a connection fac tory, SOCK Acceptor, which encapsulates passive con nection establishment logic <ref> [10] </ref>. The SOCK Acceptor constructor initializes the passive-mode acceptor socket to listen at the sock addr address. <p> SOCKET handle_; -; Note how the constructor for the SOCK Acceptor ensures that the low-level socket, bind, and listen functions are always called in the right order. A complete set of wrapper facades for sockets [5] would also include a SOCK Connector, which encapsulates the active connection establishment logic <ref> [10] </ref>. * The threading facade: Many threading APIs are available on different OS platforms, including Solaris threads, POSIX Pthreads, and Win32 threads. These APIs exhibit subtle syntactic and semantic differences, e.g., So-laris and POSIX threads can be spawned in detached mode, whereas Win32 threads cannot.
Reference: [11] <author> H. Mueller, </author> <title> Patterns for Handling Exception Handling Successfully, </title> <journal> C++ Report, </journal> <volume> vol. 8, </volume> <month> Jan. </month> <year> 1996. </year>
Reference-contexts: In contrast, reporting error information using integer values or structures provides a more universal solution. * It complicates resource management: Resource management can be complicated if there are multiple exit paths from a block of C++ or Java code <ref> [11] </ref>. <p> is not supported by the language or programming environment, care must be taken to ensure that dynamically allocated objects are deleted when an exception is thrown. * It is potentially time and/or space inefficient: Poor implements of exception handling incur time and/or space overhead even when exceptions are not thrown <ref> [11] </ref>. This overhead can be particularly problematic for embedded systems that must be efficient and have small memory footprints. The drawbacks of exception handling are particularly problematic for wrapper facades that encapsulate kernel-level device drivers or low-level native OS APIs that must run portably on many platforms [5].
Reference: [12] <author> D. C. Schmidt, T. Harrison, and N. Pryce, </author> <title> Thread-Specific Storage An Object Behavioral Pattern for Accessing per-Thread State Efficiently, </title> <journal> C++ Report, </journal> <volume> vol. 9, </volume> <month> Novem-ber/December </month> <year> 1997. </year>
Reference-contexts: One widely used solution for these system-level wrapper facades is to use the Thread-Specific Storage pattern <ref> [12] </ref>. 7 4. Define related helper classes (optional): Once the low--level functions and data structures are encapsulated within cohesive wrapper facade classes, it often becomes possible to create other helper classes that further simplify application development.
Reference: [13] <author> Bjarne Stroustrup, </author> <title> The C++ Programming Language, </title> <address> 3 rd Edition. </address> <publisher> Addison-Wesley, </publisher> <year> 1998. </year> <month> 10 </month>
Reference-contexts: LOCK &lock_; The Guard class applies the C++ idiom described in <ref> [13] </ref> whereby a constructor acquires resources and the destructor releases them within a scope, as follows: // ... // Constructor of &lt;mon&gt; automatically // acquires the &lt;mutex&gt; lock.
References-found: 13

