URL: http://www.cs.colorado.edu/users/carzanig/papers/icse97.ps.gz
Refering-URL: http://www.cs.colorado.edu/users/carzanig/papers/index.html
Root-URL: http://www.cs.colorado.edu
Email: carzaniga@elet.polimi.it  picco@athena.polito.it  vigna@elet.polimi.it  
Phone: +39-2-2399-3638  +39-11-564-7008  +39-2-2399-3666  
Title: Designing Distributed Applications with Mobile Code Paradigms  
Author: Antonio Carzaniga Gian Pietro Picco Giovanni Vigna 
Keyword: Mobile code, design paradigms, distributed applications.  
Address: Piazza Leonardo da Vinci, 32 20133 Milano, Italy  Corso Duca degli Abruzzi, 24 10129 Torino, Italy  Piazza Leonardo da Vinci, 32 20133 Milano, Italy  
Affiliation: Politecnico di Milano  Politecnico di Torino  Politecnico di Milano  
Abstract: Large scale distributed systems are becoming of paramount importance, due to the evolution of technology and to the interest of market. Their development, however, is not yet supported by a sound technological and methodological background, as the results developed for small size distributed systems often do not scale up. Recently, mobile code languages (MCLs) have been proposed as a technological answer to the problem. In this work, we abstract away from the details of these languages by deriving design paradigms exploiting code mobility that are independent of any particular technology. We present such design paradigms, together with a discussion of their features, their application domain, and some hints about the selection of the correct paradigm for a given distributed application. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> G. Abowd, R. Allen, and D. Garlan. </author> <title> Using Style to Understand Descriptions of Software Architecture. </title> <booktitle> In Proceedings of SIGSOFT'93: Foundations of Software Engineering, </booktitle> <month> December </month> <year> 1993. </year>
Reference-contexts: In our view, good technology addresses only a part of the problem. Software engineering taught us that a good software product does not come just from technology. Rather, higher level phases in the development process, such as specification and design, play a central role in the final success <ref> [1, 16] </ref>. Research on distributed systems partially fails to address these issues within a well-established framework able to guide an engineer through the development of a distributed application, and this deficiency is even more evident when large scale systems are involved.
Reference: [2] <author> M. Baldi, S. Gai, and G. P. Picco. </author> <title> Exploiting Code Mobility in Decentralized and Flexible Network Management. </title> <booktitle> In Proceedings of the First International Workshop on Mobile Agents (MA97), </booktitle> <address> Berlin, Germany, </address> <month> April </month> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: Current mainstream protocols for network management, e.g. SNMP, are based on a pure client-server paradigm where a management station continuously polls and updates data on the network devices by means of very low-level get/set operations. As discussed in <ref> [2] </ref>, this is likely to generate a huge network traffic in proximity of the management station, thus worsening the situation that management is supposed to solve. <p> DISCUSSION The mobile code design paradigms introduced in the previous section define a number of abstractions that provide an explicit model for the bindings between components, locations, and code and their dynamic reconfiguration. Our initial experience in applying the paradigms <ref> [2, 6] </ref> suggests that these abstractions are effective in the design of distributed applications. Furthermore, their independence of the particular language or system in which they are ultimately implemented is an additional asset. Mobile code paradigms model explicitly the concept of location. <p> For this purpose, we plan to implement a mobile code application for network management, along the lines described in <ref> [2] </ref>. * We will extend the repertoire of design paradigms described in this paper and provide assessment criteria that will allow each paradigm to be evaluated with respect to the quality criteria of a given appli cation. * It is an open question whether the paradigms described here, which are inspired
Reference: [3] <author> A. Black, N. Hutchinson, E. Jul, and H. Levy. </author> <title> Fine-Grained Mobility in the Emerald System. </title> <journal> ACM Transactions on Computer Systems, </journal> <volume> 6(1), </volume> <month> February </month> <year> 1988. </year>
Reference-contexts: Work on code mobility is not new; other approaches <ref> [3, 8] </ref> already investigated the capability to provide code mobility at the language level. The novelty of the new approaches is in their emphasis on the application of code mobility to a large scale setting. In our view, good technology addresses only a part of the problem. <p> Agent Tcl also supports weak mobility, as it provides a submit instruction that allows transmission of Tcl [14] procedures, together with a portion of their global environment, to an interpreter running on a different site. Emerald <ref> [3] </ref> also provides a form of strong mobility, though it is not completely under programmer's control. Weak mobility has been around for quite a long time under many shapes.
Reference: [4] <author> G. Cugola, C. Ghezzi, G. P. Picco, and G. Vigna. </author> <title> Analyzing Mobile Code Languages. </title> <editor> In J. Vitek and C. Tschudin, editors, </editor> <booktitle> Mobile Object Systems. Lecture Notes on Computer Science, </booktitle> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: Our goal is to develop a repertoire of design paradigms [15] that can be used to design distributed applications exploiting code mobility. We achieve this by leveraging off of the experience we gained in our ongoing research <ref> [4] </ref> about programming languages supporting code mobility, often called mobile code languages (MCLs). We proceed bottom-up, trying to abstract away from MCLs and conceptualize the design paradigms they embody. <p> On the other hand, in Java there is no support for mi 1 For simplicity, we refer to the technologies mentioned here as "languages", even when they are extensions of existing languages. Furthermore, we will describe only briefly problems and issues in MCLs. An in-depth discussion is provided in <ref> [4] </ref>. gration of executing code. The only language feature that can be directly exploited for code mobility is provided by a programmable class loader.
Reference: [5] <author> B. T. et al. </author> <title> Facile Antigua Release Programming Guide. </title> <type> Technical Report ECRC-93-20, </type> <institution> European Computer-Industry Research Centre, Munich, Ger-many, </institution> <month> December </month> <year> 1993. </year>
Reference-contexts: TACOMA [9] is an extension of Tcl that allows the programmer to send code together with any kind of data to a remote machine, in order to be executed there. Facile <ref> [5] </ref> is a higher-order functional language conceived for concurrent distributed programming where code mobility is naturally achieved because Facile functions are first class elements of the language.
Reference: [6] <author> C. Ghezzi and G. Vigna. </author> <title> Mobile Code Paradigms and Technologies: A Case Study. </title> <booktitle> In Proceedings of the First International Workshop on Mobile Agents (MA97), </booktitle> <address> Berlin, Germany, </address> <month> April </month> <year> 1997. </year> <note> To appear. </note>
Reference-contexts: The resulting paradigms are quite general and independent of the specific technology one may choose for the implementation although, of course, each design paradigm can be implemented more naturally by languages pro-viding specific features <ref> [6] </ref>. Independence of the design paradigm from the underlying technology is a major point in the general software engineering practice. As an example, the benefits of an object-oriented design do not stem from the availability of an object-oriented language to be used in the implementation. <p> DISCUSSION The mobile code design paradigms introduced in the previous section define a number of abstractions that provide an explicit model for the bindings between components, locations, and code and their dynamic reconfiguration. Our initial experience in applying the paradigms <ref> [2, 6] </ref> suggests that these abstractions are effective in the design of distributed applications. Furthermore, their independence of the particular language or system in which they are ultimately implemented is an additional asset. Mobile code paradigms model explicitly the concept of location.
Reference: [7] <author> R. S. Gray. </author> <title> Agent Tcl: A transportable agent system. </title> <booktitle> In Proceedings of the CIKM'95 Workshop on Intelligent Information Agents. </booktitle>
Reference-contexts: Besides Telescript, the family of strong MCLs includes languages such as Tycoon, Agent Tcl and Emerald. Tycoon [12] provides thread migration like Telescript, but lacks Telescript's richness of abstractions and features. Agent Tcl <ref> [7] </ref> provides strong mobility where the whole image of the interpreter can be transferred to a different site by executing a jump instruction.
Reference: [8] <author> J. W. Stamos and D. K. Gifford. </author> <title> Remote Evaluation. </title> <journal> ACM Transactions on Programming Languages and Systems, </journal> <volume> 12(4) </volume> <pages> 537-565, </pages> <month> October </month> <year> 1990. </year>
Reference-contexts: Work on code mobility is not new; other approaches <ref> [3, 8] </ref> already investigated the capability to provide code mobility at the language level. The novelty of the new approaches is in their emphasis on the application of code mobility to a large scale setting. In our view, good technology addresses only a part of the problem. <p> In addition, the REV <ref> [8] </ref> system, that inspired much of the work on code mobility, provides an extension to remote procedure call (RPC) that allows one to send both the actual parameters and the code for a procedure to be executed on a remote machine. <p> Although it has been inspired by work on the REV system <ref> [8] </ref>, they have to be kept definitely distinct. Our REV is a design paradigm, while the REV system is a technology that may be used to actually implement an application designed using the REV paradigm.
Reference: [9] <author> D. Johansen, R. van Renesse, and F. Schneider. </author> <title> An Introduction to the TACOMA Distributed System Version 1.0. </title> <type> Technical Report 95-23, </type> <institution> "University of Tromst and Cornell University", </institution> <month> June </month> <year> 1995. </year>
Reference-contexts: An extension of Java, called MOLE [17], adds the capability of sending code to another Java interpreter without modifying the Java interpreter. TACOMA <ref> [9] </ref> is an extension of Tcl that allows the programmer to send code together with any kind of data to a remote machine, in order to be executed there.
Reference: [10] <author> J. Kramer. </author> <booktitle> Distributed Software Engineering. In Proceedings of the 16th International Conference on Software Engineering, </booktitle> <address> Sorrento (Italy), </address> <month> May </month> <year> 1994. </year>
Reference-contexts: In this paper, we are concerned mainly with the design of distributed applications, that aims at identifying the distributable components and their interactions which together satisfy the system requirements <ref> [10] </ref>. Our goal is to develop a repertoire of design paradigms [15] that can be used to design distributed applications exploiting code mobility.
Reference: [11] <author> G. </author> <title> Magic. Telescript Language Reference. General Magic, </title> <month> October </month> <year> 1995. </year>
Reference-contexts: This is proven by the fact that two of the most well-known MCLs, that is, Java by Sun Microsystems [18], and Telescript by General Magic <ref> [11] </ref>, come from industry. Although both Java and Telescript are considered MCLs, they are at the extremes of a continuum representing the degree of code mobility that can be provided by a programming language.
Reference: [12] <author> B. Mathiske, F. Matthes, and J. Schmidt. </author> <title> On Migrating Threads. </title> <type> Technical report, </type> <institution> Fachbereich In-formatik Universitat Hamburg, </institution> <year> 1994. </year>
Reference-contexts: Strong MCLs are a minority, because of the challenging problems they pose in both defining and implementing the semantics of strong mobility. Besides Telescript, the family of strong MCLs includes languages such as Tycoon, Agent Tcl and Emerald. Tycoon <ref> [12] </ref> provides thread migration like Telescript, but lacks Telescript's richness of abstractions and features. Agent Tcl [7] provides strong mobility where the whole image of the interpreter can be transferred to a different site by executing a jump instruction.
Reference: [13] <author> OMG. </author> <title> CORBA: Architecture and Specification, </title> <month> August </month> <year> 1995. </year>
Reference-contexts: The location of components is simply regarded as an implementation detail. In some cases, such details are explicitly stated by the programmer in the implementation stage. In other cases, they are automatically defined by some middleware layer. For example, CORBA <ref> [13] </ref> intentionally hides the location of components to the programmer. In this framework, there is no distinction between interaction involving components residing on the same host and components residing on different hosts of a computer network. This, however, is not the only possible approach to the design of distributed applications.
Reference: [14] <author> J. Ousterhout. </author> <title> Tcl and the Tk Toolkit. </title> <publisher> Addison-Wesley, </publisher> <year> 1995. </year>
Reference-contexts: Agent Tcl [7] provides strong mobility where the whole image of the interpreter can be transferred to a different site by executing a jump instruction. Agent Tcl also supports weak mobility, as it provides a submit instruction that allows transmission of Tcl <ref> [14] </ref> procedures, together with a portion of their global environment, to an interpreter running on a different site. Emerald [3] also provides a form of strong mobility, though it is not completely under programmer's control. Weak mobility has been around for quite a long time under many shapes.
Reference: [15] <author> D. Perry and A. Wolf. </author> <title> Foundations for the Study of Software Architecture. </title> <booktitle> ACM SIGSOFT Software Engineering Notes, </booktitle> <month> October </month> <year> 1992. </year>
Reference-contexts: In this paper, we are concerned mainly with the design of distributed applications, that aims at identifying the distributable components and their interactions which together satisfy the system requirements [10]. Our goal is to develop a repertoire of design paradigms <ref> [15] </ref> that can be used to design distributed applications exploiting code mobility. We achieve this by leveraging off of the experience we gained in our ongoing research [4] about programming languages supporting code mobility, often called mobile code languages (MCLs).
Reference: [16] <author> M. Shaw and D. Garlan. </author> <title> Software Architecture: Perspective on an Emerging Discipline. </title> <publisher> Prentice Hall, </publisher> <year> 1996. </year>
Reference-contexts: In our view, good technology addresses only a part of the problem. Software engineering taught us that a good software product does not come just from technology. Rather, higher level phases in the development process, such as specification and design, play a central role in the final success <ref> [1, 16] </ref>. Research on distributed systems partially fails to address these issues within a well-established framework able to guide an engineer through the development of a distributed application, and this deficiency is even more evident when large scale systems are involved.
Reference: [17] <author> M. Straer, J. Baumann, and F. Hohl. </author> <title> MOLE A Java Based Mobile Agent System. </title> <booktitle> In Proceedings of the Second International Workshop on Mobile Object Systems, </booktitle> <address> Linz, </address> <month> July </month> <year> 1996. </year>
Reference-contexts: More recent approaches have been inspired by applications development on the Internet. As we mentioned, the Java class loader allows the programmer to customize the resolution of a class name, possibly downloading the corresponding code from any machine on the network. An extension of Java, called MOLE <ref> [17] </ref>, adds the capability of sending code to another Java interpreter without modifying the Java interpreter. TACOMA [9] is an extension of Tcl that allows the programmer to send code together with any kind of data to a remote machine, in order to be executed there.
Reference: [18] <author> Sun Microsystems. </author> <title> The Java Language Specification, </title> <month> October </month> <year> 1995. </year>
Reference-contexts: This is proven by the fact that two of the most well-known MCLs, that is, Java by Sun Microsystems <ref> [18] </ref>, and Telescript by General Magic [11], come from industry. Although both Java and Telescript are considered MCLs, they are at the extremes of a continuum representing the degree of code mobility that can be provided by a programming language.
Reference: [19] <author> C. F. Tschudin. </author> <title> An Introduction to the M0 Messenger Language. </title> <institution> University of Geneva, Switzerland, </institution> <year> 1994. </year>
Reference-contexts: Facile [5] is a higher-order functional language conceived for concurrent distributed programming where code mobility is naturally achieved because Facile functions are first class elements of the language. M0 <ref> [19] </ref> differs from the above languages in that it is not conceived to be the language in which mobile code applications are programmed. Rather, its goal is to provide a middleware layer supporting code mobility for higher level layers.
Reference: [20] <author> J. Waldo, G. Wyant, A. Wollrath, and S. </author> <title> Kendall. </title>
Reference-contexts: In some cases, the interaction among components residing on the same host is remarkably different with respect to the case where components reside on different hosts of a computer network, in terms of latency, access to memory, partial failure, and concurrency. As stated in <ref> [20] </ref>, hiding such differences can lead to unexpected performance and reliability problems. In this paper, we address the class of applications for which the concepts of location and mobility are so important that they affect the conceptual structure of the application as it is conceived in the design stage.
References-found: 20

