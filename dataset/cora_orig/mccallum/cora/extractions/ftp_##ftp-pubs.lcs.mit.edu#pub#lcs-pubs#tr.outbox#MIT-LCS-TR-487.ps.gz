URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/tr.outbox/MIT-LCS-TR-487.ps.gz
Refering-URL: ftp://ftp-pubs.lcs.mit.edu/pub/lcs-pubs/listings/trlow.html
Root-URL: 
Title: Specification and Verification of Real-Time Constraints in Coarse-Grain Dataflow  
Author: Dana S. Henry 
Pubnum: MIT LCS TR-487  
Abstract-found: 0
Intro-found: 1
Reference: [1] <author> John A. Stankovic. </author> <title> "Misconceptions About Real-Time Computing." </title> <journal> IEEE Computer, </journal> <volume> pp10-19, </volume> <month> October, </month> <year> 1988. </year>
Reference-contexts: Such assertions hide synchronization and contention costs and correspond to worst case analysis of individual latencies as explored by Leinbaugh and Yamini [5]. More accurate latency bounds can be achieved through direct simulation. However, as Stankovic <ref> [1] </ref> points out, this approach must tackle the complexity barrier.
Reference: [2] <author> E. G. Coffman. </author> <title> "Computer and Job-Shop Scheduling Theory." </title> <publisher> John Wiley & Sons, </publisher> <address> New York, </address> <year> 1976. </year>
Reference: [3] <author> E. Horowitz, S. Sahni. </author> <title> 'Exact and approximate algorithms for scheduling nonidentical processors." </title> <journal> Journal of ACM, </journal> <volume> 23, </volume> <month> April </month> <year> 1976, </year> <pages> 317-327. </pages>
Reference: [4] <author> Stephen A. Ward. </author> <title> "An Approach to Real Time Computation." </title> <booktitle> Proceedings of the 7th Texas Conference on Computer Systems, </booktitle> <address> pp26-34, </address> <year> 1978. </year>
Reference: [5] <author> Dennis W. Leinbaugh, Mohamad-Reza Yamini. </author> <title> "Guaranteed Response Times in a Distributed Hard-Real-Time Environment." </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-12, No. 12, </volume> <month> December </month> <year> 1986. </year>
Reference-contexts: As long as all assertions are met by the underlying machine, an absolute constraint is feasible. Such assertions hide synchronization and contention costs and correspond to worst case analysis of individual latencies as explored by Leinbaugh and Yamini <ref> [5] </ref>. More accurate latency bounds can be achieved through direct simulation. However, as Stankovic [1] points out, this approach must tackle the complexity barrier. <p> Else, the maximum latency is infinity and no constraints can be met. 53 SAMPLE Modules' Timing Specification Module State Statement Next State Tool - s 1 0 Acquisition s 2 5 - s 16 !s 1 <ref> [5] </ref> - 5 ModelSelect - s 3 1520 1520 Oil1 - s 4 !s 5 [10] - 5 Oil2 - s 5 !s 6 [5]^s 7 [5] - Sand - 2s 9 10 ModelMerge - s 6 ^s 8 20 s 10 ^s 8 !s 16 [20] MonitorSelect 1 s 3 <p> 53 SAMPLE Modules' Timing Specification Module State Statement Next State Tool - s 1 0 Acquisition s 2 5 - s 16 !s 1 <ref> [5] </ref> - 5 ModelSelect - s 3 1520 1520 Oil1 - s 4 !s 5 [10] - 5 Oil2 - s 5 !s 6 [5]^s 7 [5] - Sand - 2s 9 10 ModelMerge - s 6 ^s 8 20 s 10 ^s 8 !s 16 [20] MonitorSelect 1 s 3 10 2 s 3 !s 13 [10] 1 Monitor1 - s 11 50130 Monitor2 - s 13 30 MonitorMerge - s 12 ^s 14 10 10 <p> 6 ^s 8 20 s 10 ^s 8 !s 16 [20] MonitorSelect 1 s 3 10 2 s 3 !s 13 [10] 1 Monitor1 - s 11 50130 Monitor2 - s 13 30 MonitorMerge - s 12 ^s 14 10 10 Process - s 16 5 s 17 !s 15 <ref> [5] </ref> Record - s 15 5 Display - s 15 5 Table 4.3: Behavior and Timing Specifications for Our Sample Modules. 54 4.3 Program's Execution Model Having described the behavior and timing of each module, we are ready to describe the behavior and timing of the entire program.
Reference: [6] <author> Michael F. Coulas, Glenn H. MacEwen, Genevieve Marquis. "RNet: </author> <title> A Hard Real-Time Distributed Programming System." </title> <journal> IEEE Transactions on Computers, </journal> <volume> Vol. C-36, No. 8, </volume> <month> August </month> <year> 1987. </year>
Reference: [7] <author> Aloysius Ka-Lau Mok. </author> <title> "Fundamental Design Problems of Distributed Systems for the Hard Real-Time Environment." </title> <type> MIT LCS Technical Report 297, </type> <institution> Department of Computer Science, MIT, </institution> <month> May, </month> <year> 1983. </year>
Reference: [8] <author> Farnam Jahanian, Aloysius Ka-Lau Mok. </author> <title> "Safety Analysis of Timing Properties in Real-Time Systems." </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-12, No. 9, </volume> <month> September </month> <year> 1986. </year>
Reference: [9] <author> M. Garey, D. Johson. </author> <title> "Computers and Intractability: a Guide to the Theory of NP-Completeness." </title> <editor> W. H. </editor> <publisher> Freeman, </publisher> <address> San Francisco, California, </address> <year> 1979. </year>
Reference-contexts: In an optimal real-time system, one would like an automated allocator to arrive at an optimal allocation schedule. Such an allocator would be NP complete even for the much simpler case of two identical processors executing independent tasks with no communication overhead <ref> [9] </ref>. As a result, all practical scheduling algorithms within a multiple processor environment rely on heuristics. The most common approach is a back-tracking branch and bound search within a simulation.
Reference: [10] <author> Glenn H. MacEwen, David B. Skillicon. </author> <title> "Using Higher-Order Logic for Modular Specification of Real-Time Distributed Systems." Proceedings of a Symposium on Formal Techniques in Real-Time and Fault Tolerant Systems, </title> <booktitle> Lecture Notes in Computer Science 331, Warwick, </booktitle> <address> UK, </address> <month> September 22-23, </month> <year> 1988. </year>
Reference-contexts: It then continues to execute for the remaining 20 time units, updating its internal state. One way to incorporate this information into our specification of Monitor2's actions is as follows: s 13 ! s 14 <ref> [10] </ref>: Here, we have taken the time of invocation as our point of reference. We have specified Monitor2's execution latency above its execution arrow. <p> the maximum latency is infinity and no constraints can be met. 53 SAMPLE Modules' Timing Specification Module State Statement Next State Tool - s 1 0 Acquisition s 2 5 - s 16 !s 1 [5] - 5 ModelSelect - s 3 1520 1520 Oil1 - s 4 !s 5 <ref> [10] </ref> - 5 Oil2 - s 5 !s 6 [5]^s 7 [5] - Sand - 2s 9 10 ModelMerge - s 6 ^s 8 20 s 10 ^s 8 !s 16 [20] MonitorSelect 1 s 3 10 2 s 3 !s 13 [10] 1 Monitor1 - s 11 50130 Monitor2 - <p> 1520 1520 Oil1 - s 4 !s 5 <ref> [10] </ref> - 5 Oil2 - s 5 !s 6 [5]^s 7 [5] - Sand - 2s 9 10 ModelMerge - s 6 ^s 8 20 s 10 ^s 8 !s 16 [20] MonitorSelect 1 s 3 10 2 s 3 !s 13 [10] 1 Monitor1 - s 11 50130 Monitor2 - s 13 30 MonitorMerge - s 12 ^s 14 10 10 Process - s 16 5 s 17 !s 15 [5] Record - s 15 5 Display - s 15 5 Table 4.3: Behavior and Timing Specifications for Our Sample Modules. 54 <p> The simulator's final time, 10, would meet this deadline. We can easily incorporate the imposed deadline into the constraint's specification: s 17 [0] ! s 1 T ool <ref> [10] </ref>: Similarly, we can incorporate a deadline into the general specification of 5.1: s [t] ! s 0 65 66 Here, we constrain the arrival time of a token along input stream s' of module M to be less than some deadline d. <p> We illustrates the fallacy of this assumption on the simple program of Figure 6.1. The timing behavior of the three modules in Figure 6.1 is: M1 behavior: s 1 3 M2 behavior: s 2 24 M3 behavior: s 3 10 s 4 ! s 5 <ref> [10] </ref> Assume, for simplicity, that all channels have zero latency and each module is allocated to a separate processor. <p> The handling of tagged tokens and the timing of successive modules' invocations are compromised. Tagging First, the behavior of tagged constraints is compromised. To illustrate, consider the program: 84 M1 behavior: s 1 100 M2 behavior: s 2 10 M3 behavior: s 3 10 s 4 ! s 5 <ref> [10] </ref> M4 behavior: s 5 ^s 6 10 M5 behavior: s 7 10 The imposed constraint is: s 6 [0]^s 1 [0]^s 2 [0] ! s 7 M5 [20fM3 : s 4 !s 5 g]: invocation of module M4 may consume the wrong token.
Reference: [11] <author> F. Jahanian, A. K. Mok. </author> <title> "Safety Analysis of Timing Properties in Real-Time Systems." </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-12, No. 9, pp890-904, </volume> <month> September, </month> <year> 1986. </year>
Reference-contexts: At higher level, few of the formal specification methods have succeeded in providing a clean interface to the low machine level verification. One of the more successful approaches in this respect has been Jahanian and Mok's real time logic (RTL) <ref> [11] </ref>. Their logic relies on safety assertions, maximum delays along each module, for deadline specification. As long as all assertions are met by the underlying machine, an absolute constraint is feasible.
Reference: [12] <author> J. L. Bergerand, P. Caspi, D. Pilaud, N. Halbwachs, E. Pilaud. </author> <title> "Outline of a Real Time Data Flow Language." </title> <booktitle> Proceedings of the Real-Time Systems Symposium, </booktitle> <address> San Diego, Cal-ifornia, </address> <month> December 3-6, </month> <year> 1985. </year>
Reference-contexts: Investigated specification approaches vary from integrated program specifications as in real-time languages, to isolated timing specifications. Of the programming languages, the best 8 known is Ada which allows specification of relative constraints. More thorough treatment of real time concepts can be found in research languages such as LUSTRE <ref> [12] </ref>, a synchronous, real time dataflow language. Other approaches range from use of static typing to specify relative and absolute time predicates [13] to the extension of temporal logic to model states and events through clock ticks [14]. Verification efforts vary with the nature of timing constraints.
Reference: [13] <author> H. Wupper, J. </author> <title> Vytopil. "A Specification Language for Reliable Real-time Systems." Proceedings of a Symposium on Formal Techniques in Real-Time and Fault Tolerant Systems, </title> <booktitle> Lecture Notes in Computer Science 331, Warwick, </booktitle> <address> UK, </address> <month> September 22-23, </month> <year> 1988. </year>
Reference-contexts: More thorough treatment of real time concepts can be found in research languages such as LUSTRE [12], a synchronous, real time dataflow language. Other approaches range from use of static typing to specify relative and absolute time predicates <ref> [13] </ref> to the extension of temporal logic to model states and events through clock ticks [14]. Verification efforts vary with the nature of timing constraints. Relative timing constraints enforce sequencing of events within an execution and can be verified without knowledge of machine speeds.
Reference: [14] <author> J. S. Ostroff, W. M. Wonham. </author> <title> "Modelling, Specifying and Verifying Real-time Embedded Computer Systems." </title> <booktitle> Proceedings of the Real-Time Systems Symposium, </booktitle> <address> San Jose, Califor-nia, </address> <month> December 1-3, </month> <year> 1987. </year>
Reference-contexts: Other approaches range from use of static typing to specify relative and absolute time predicates [13] to the extension of temporal logic to model states and events through clock ticks <ref> [14] </ref>. Verification efforts vary with the nature of timing constraints. Relative timing constraints enforce sequencing of events within an execution and can be verified without knowledge of machine speeds. Absolute timing constraints place absolute bounds on execution latencies and require knowledge of hardware timing.
Reference: [15] <author> David R. Barstow, Paul S. Barth. </author> <title> "The Resource Allocation Problem for Stream Machine Programs." </title> <institution> Schlumberger Doll Research, </institution> <year> 1988. </year>
Reference-contexts: The arrive-token event handler queues the token on stream 3's input queue and attempts to fire the ModelSelect module. The event handler finds the ModelSelect module in state 1 its only state. It finds one statement whose input set is ready: s 3 ! s 4 <ref> [15] </ref>^s 8 [15] ! s 9 [5 12; 10 15]^s 8 [10 15] The event handler forks two separate simulations one for each output set. Since the ModelSelect module is inactive, both simulations fire their output set.
Reference: [16] <author> David R. Barstow, Paul S. Barth, Richard Dinitz. </author> <title> "SPHINX: A Programming Environment for Device Control Software." </title> <institution> Schlumberger Doll Research, </institution> <year> 1987. </year>
Reference-contexts: It also forwards the signal transit time to the corresponding TransitToStartTime module. In addition, all TransitToStartTime modules forward the computed start time to the ToUser modules. The ToUser modules process four consecutive measurements and forward the result to the user. This implementation is identical to that of Barstow in <ref> [16] </ref>. The implementation overlaps the computation of four feedback values. The four-way interleaving of feedback computation 27 lessens the real time feedback constraint. Each amplitude and transit time measurement can be used to adjust the gain and start time of the fourth next measurement instead of the very next one.
Reference: [17] <author> Paul S. Barth, Scott B. Guthery, David R. Barstow. </author> <title> "The Stream Machine: A Data Flow Architecture for Real-Time Applications." </title> <booktitle> 1985 Eighth International Conference on Software Engineering. </booktitle>
Reference-contexts: We narrow our attention to periodic programs and start with an existing software architecture, the Stream Machine <ref> [17] </ref>. We augment and simplify the computational model to achieve a simple timing specification. We analyze constraints and check feasibility within an allocation scheme. The content of this thesis tracks the progress of its project. <p> Assumptions In order to simplify our specification, we restrict the original Stream Machine model. The Stream Machine model, as described in <ref> [17] </ref>, is a model of buffered communicating sequential processes (CSP). Stream reads and writes are interspersed throughout each module leading to many module states. In each state, a module is either executing with interspersed stream writes or waiting to read from one of its input streams.
Reference: [18] <author> David R. Barstow, Greenspan. </author> <title> "Using a Device Model as Domain Knowledge in the Automatic Programming of Software to Control Remote Devices." </title> <institution> Schlumberger Doll Research, </institution> <year> 1986. </year>
Reference-contexts: This example has been extensively analyzed in <ref> [18] </ref>. The tool consists of a tester with geophones for measuring seismic vibration and an arm for locking the tool into the borehole. There is a pressure sensor on the arm for detecting when the arm is pressing against the borehole well (Figure 3.7).
Reference: [19] <author> C. A. R. Hoare. </author> <title> "Communicating Sequential Processes." </title> <journal> Communications of the ACM, </journal> <volume> 8, pp666-677, </volume> <month> August, </month> <year> 1978. </year>
Reference: [20] <author> Paul R. Kosinsky. </author> <title> "A Straightforward Denotational Semantics for Non-Determinate Data Flow Programs." </title> <booktitle> Conference Record of the Fifth Annual ACM Symposium on Principles of Programming Languages. </booktitle>
Reference-contexts: s 16 !s 1 [5] - 5 ModelSelect - s 3 1520 1520 Oil1 - s 4 !s 5 [10] - 5 Oil2 - s 5 !s 6 [5]^s 7 [5] - Sand - 2s 9 10 ModelMerge - s 6 ^s 8 20 s 10 ^s 8 !s 16 <ref> [20] </ref> MonitorSelect 1 s 3 10 2 s 3 !s 13 [10] 1 Monitor1 - s 11 50130 Monitor2 - s 13 30 MonitorMerge - s 12 ^s 14 10 10 Process - s 16 5 s 17 !s 15 [5] Record - s 15 5 Display - s 15 5
Reference: [21] <author> J. Dean Brock, William B. Ackerman. </author> <title> "Scenarios: A Model of Non-determinate Computation." Computation Structures Group Memo 206, </title> <institution> Laboratory for Computer Science, MIT, </institution> <month> February </month> <year> 1981. </year>
Reference: [22] <author> Domenico Ferrari. </author> <title> "Computer Systems Performance Evaluation." </title> <publisher> Prentice Hall, </publisher> <address> New Jersey, </address> <year> 1978. </year>
Reference: [23] <author> John Henize. </author> <title> "Understanding Real-Time UNIX." Concurrent Computer Corporation, </title> <address> Westford, MA. </address>
Reference-contexts: Verification of absolute constraints has generated attention at two different levels, at the low machine level and at the high specification level. At machine level, commercial projects have successfully bound system latencies. Masscomp's Real Time Unix <ref> [23] </ref>, for instance, binds system response times through fixed priority scheduling for predictable schedules, through memory locking for processing free of paging and swapping, and through kernel preemption for bound delay of real time processes due to outside system requests. <p> A predictable allocation schedule is essential to absolute constraint verification. While easy to achieve, predictability has not been required of many existing schedulers <ref> [23] </ref>. A reasonably optimized allocation method is essential to meeting absolute constraints. In an optimal real-time system, one would like an automated allocator to arrive at an optimal allocation schedule.
Reference: [24] <author> Randal E. </author> <title> Bryant . "Simulation of Packet Communication Architecture Computer Systems." </title> <type> MIT LCS Technical Report 188, </type> <institution> Department of Computer Science, MIT, </institution> <month> November, </month> <year> 1977. </year>
Reference: [25] <author> David R. Boggs, Jeffrey C. Mogul, Christopher A. Kent. </author> <title> "Measured Capacity of an Ethernet: Myths and Reality." </title> <booktitle> Proceedings of SIGCOMM '88, ACM SIGCOMM, </booktitle> <month> August, </month> <year> 1988. </year>
Reference: [26] <author> Robert M. Metcalfe, David R. Boggs. </author> <title> "Ethernet: Distributed Packet Switching for Local Computer Networks." </title> <journal> Communications of the ACM, </journal> <volume> 7, pp395-404, </volume> <month> July, </month> <year> 1976. </year> <month> 101 </month>
Reference: [27] <author> Steven L. Beuerman, Edward J. Coyle. </author> <title> "The Delay Characteristics of CSMA/CD Net--works." </title> <journal> IEEE Transactions on Communications, </journal> <volume> 5, pp553-563, </volume> <month> May, </month> <year> 1988. </year> <month> 102 </month>
References-found: 27

