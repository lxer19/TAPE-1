URL: http://www.cs.wustl.edu/~sds/research/cgi-bin/server.cgi/research/papers/UNL-CSE-97-009.ps.gz
Refering-URL: http://www.cs.wustl.edu/~sds/research/type.html
Root-URL: 
Title: A Synthesizable VHDL Coding of a Genetic Algorithm  
Author: Stephen D. Scott, Sharad Seth, and Ashok Samal 
Date: November 19, 1997  
Affiliation: University of Nebraska-Lincoln  
Pubnum: Technical Report UNL-CSE-97-009  
Abstract: This paper presents the HGA, a genetic algorithm written in VHDL and intended for a hardware implementation. Due to pipelining, parallelization, and no function call overhead, a hardware GA yields a significant speedup over a software GA, which is especially useful when the GA is used for real-time applications, e.g. disk scheduling and image registration. Since a general-purpose GA requires that the fitness function be easily changed, the hardware implementation must exploit the reprogrammability of certain types of field-programmable gate arrays (FPGAs), which are programmed via a bit pattern stored in a static RAM and are thus easily reconfigured. After presenting some background on VHDL, this paper takes the reader through the HGA's code. We then describe some applications of the HGA that are feasible given the state-of-the-art in FPGA technology and summarize some possible extensions of the design. Finally, we review some other work in hardware-based GAs. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Darwin on a chip. </author> <booktitle> The Economist, </booktitle> <pages> page 85, </pages> <month> February </month> <year> 1993. </year>
Reference-contexts: In this case, each population member represents a hardware design, and the goal is to find an optimal design with respect to an objective function, e.g. how well the design performs a specific task. There are many examples of evolvable hardware in the literature <ref> [1, 17, 26, 43] </ref>. 2 A VHDL Primer In this section we briefly review some of the VHDL fundamentals employed in this paper. Much more detail is available at the VIUF and VHDL UK WWW sites [2, 3], which include lists of several VHDL books. <p> The SGA's selection procedure is as follows. 1. Using a random real number r 2 <ref> [0; 1] </ref>, scale down the sum of the fitnesses of the current population to get S scale = r S fit . 2. Starting at the first population member, examine the members in the order they appear in the population. 3. <p> One such encoding is called a random keys encoding [11, 37]. In this encoding, each tour is represented by a tuple of random numbers, one number for each city, with each number from <ref> [0; 1] </ref>. After selecting a pair of tours, simple or uniform crossover can be applied, yielding two new tuples. To evaluate these tuples, sort the numbers and visit the cities in ascending order of the sort.
Reference: [2] <institution> VHDL International Users Forum (VIUF), </institution> <year> 1997. </year> <note> http://www.vhdl.org/viuf. </note>
Reference-contexts: There are many examples of evolvable hardware in the literature [1, 17, 26, 43]. 2 A VHDL Primer In this section we briefly review some of the VHDL fundamentals employed in this paper. Much more detail is available at the VIUF and VHDL UK WWW sites <ref> [2, 3] </ref>, which include lists of several VHDL books. The material in this section should be sufficient to allow the reader to comprehend the code of the design. 2.1 Entities, Architectures and Processes Each module in the HGA consists of an ENTITY and an ARCHITECTURE.
Reference: [3] <institution> VHDL UK : A communication network for VHDL users, </institution> <year> 1997. </year> <note> http://www.vhdluk.org/. </note>
Reference-contexts: There are many examples of evolvable hardware in the literature [1, 17, 26, 43]. 2 A VHDL Primer In this section we briefly review some of the VHDL fundamentals employed in this paper. Much more detail is available at the VIUF and VHDL UK WWW sites <ref> [2, 3] </ref>, which include lists of several VHDL books. The material in this section should be sufficient to allow the reader to comprehend the code of the design. 2.1 Entities, Architectures and Processes Each module in the HGA consists of an ENTITY and an ARCHITECTURE.
Reference: [4] <author> M. Abramovici, M. A. Breuer, and A. D. Friedman. </author> <title> Digital Systems Testing and Testable Design. </title> <editor> AT&T Bell Laboratories and W. H. </editor> <publisher> Freeman and Company, </publisher> <address> New York, New York, </address> <year> 1990. </year>
Reference-contexts: In this model any faulty circuit has only a single fault, and the fault is of the following form: some wire in the circuit is permanently stuck at 0 (e.g. the wire is short-circuited to ground) or 1 (e.g. the wire is short-circuited to power). See Abramovici et al. <ref> [4] </ref> for more information on this and other fault models. O'Dare and Arslan [38] have described a GA to generate test vectors for stuck-at fault detection in combinational circuits (i.e. circuits with no memory). In their scheme, each population member is a single test vector.
Reference: [5] <author> Advanced Micro Devices. </author> <title> Bipolar Microprocessor and Logic Interface (Am29000 Family) Data Book, </title> <note> 1985. http://www.amd.com/. </note>
Reference-contexts: These amounts are 14 Since multipliers occupy significant FPGA space and can reduce the maximum possible clock rate, a dedicated multiplier chip, such as the AMD Am29323 multiplier <ref> [5] </ref>, could be used instead. This would increase the maximum possible clock rate and save area on the FPGAs. 11 2b2x 1 c and 2b10x 2 c, each of which is computable with two more uses of the multiplier 15 .
Reference: [6] <author> J. T. Alander, M. Nordman, and H. Setala. </author> <title> Register-level hardware design and simulation of a genetic algorithm using VHDL. </title> <editor> In P. Osmera, editor, </editor> <booktitle> Proceedings of the 1st International Mendel Conference on Genetic Algorithms, Optimization, Fuzzy Logic and Neural Networks, </booktitle> <pages> pages 10-14, </pages> <year> 1995. </year>
Reference-contexts: The result is a general-purpose GA engine which is useful in many applications where software-based GA implementations are too slow, e.g. when real-time constraints apply. Recently there has been more work on hardware-based GAs. Other VHDL GA implementations include Alander et al. <ref> [6] </ref> and Graham and Nelson [22]. Salami and Cain applied the design of this paper to the problems of finding optimal gains for a proportional integral differential (PID) controller [41] and optimization of electricity generation in response to demand [42].
Reference: [7] <institution> Altera Corporation, </institution> <address> San Jose, California. </address> <note> Flex 10k Embedded Programmable Logic Family, 1996. http://www.altera.com/. </note>
Reference-contexts: Additionally, Tommiska and Vuori [49] implemented a GA with Altera HDL (AHDL) for implementation on Altera FLEX 10K FPGAs <ref> [7] </ref>. A subset of the GA operations have been mapped to hardware by Liu [31], who designed and simulated a hardware implementation of the crossover and mutation operators. In similar work, Red'ko et al. [40] developed a GA which implemented crossover and mutation in hardware.
Reference: [8] <author> J. M. Arnold, D. A. Buell, and E. G. Davis. </author> <title> Splash 2. </title> <booktitle> In Proceedings of the 4th Annual ACM Symposium on Parallel Algorithms and Architectures, </booktitle> <pages> pages 316-324, </pages> <month> June </month> <year> 1992. </year>
Reference-contexts: While FPGAs are not as fast as typical application-specific integrated circuits (ASICs), they still hold a great speed advantage over functions executing in software. In fact, speedups of 1-2 orders of magnitude have been observed when frequently used software routines were implemented with FPGAs <ref> [8, 9, 12, 15, 19, 54] </ref>. Characteristically, these systems identify simple operations that are bottlenecks in software and map them to hardware. This is the approach used in this paper, except that the entire GA is intended for a hardware implementation. The remainder of this paper is organized as follows.
Reference: [9] <author> P. M. Athanas and H. F. Silverman. </author> <title> Processor reconfiguration through instruction-set metamorphosis. </title> <journal> IEEE Computer, </journal> <volume> 26(3) </volume> <pages> 11-18, </pages> <month> March </month> <year> 1993. </year>
Reference-contexts: While FPGAs are not as fast as typical application-specific integrated circuits (ASICs), they still hold a great speed advantage over functions executing in software. In fact, speedups of 1-2 orders of magnitude have been observed when frequently used software routines were implemented with FPGAs <ref> [8, 9, 12, 15, 19, 54] </ref>. Characteristically, these systems identify simple operations that are bottlenecks in software and map them to hardware. This is the approach used in this paper, except that the entire GA is intended for a hardware implementation. The remainder of this paper is organized as follows.
Reference: [10] <author> K. Batcher. </author> <title> Sorting networks and their applications. </title> <booktitle> In Proceedings of the AFIPS Spring Joint Computing Conference, </booktitle> <volume> volume 32, </volume> <pages> pages 307-314, </pages> <year> 1968. </year>
Reference-contexts: When employing this scheme, all that is required of the HGA's FM is, upon receiving a population member, to sort the tuple and accumulate the distances between the cities of the tour. Sorting of the numbers can be done with a sorting circuit based on the Odd-Even Merge algorithm <ref> [10] </ref> 16 . For sorting n numbers (i.e. for n-city tours), the depth of the sorting network is dlog 2 ne (dlog 2 ne + 1)/ 2. Each level of the network has n registers and n=2 comparators 17 .
Reference: [11] <author> J. Bean. </author> <title> Genetics and random keys for sequencing and optimization. </title> <journal> ORSA Journal on Computing, </journal> <volume> 6 </volume> <pages> 154-160, </pages> <year> 1994. </year>
Reference-contexts: This method can be used in the HGA but requires modification of the CMM. In lieu of this, conventional crossover operators can be used in conjunction with a special encoding of the population members. One such encoding is called a random keys encoding <ref> [11, 37] </ref>. In this encoding, each tour is represented by a tuple of random numbers, one number for each city, with each number from [0; 1]. After selecting a pair of tours, simple or uniform crossover can be applied, yielding two new tuples. <p> Finally, we note that the scheme just presented can be adapted for application to other problems with similar constraints as the TSP. These include scheduling problems, vehicle routing, and resource allocation (a generalization of the 0-1 knapsack problem and the set partitioning problem) <ref> [11, 37] </ref>. The HGA can be applied to these problems as well with a slight increase in complexity. 4.6 Other NP-Complete Problems In this section we explore the exploitation of polynomial-time reductions between instances of NP-complete problems. Developing a GA to solve any NP-complete problem (e.g.
Reference: [12] <author> P. Bertin, D. Roncin, and J. Vuillemin. </author> <title> Programmable active memories: A performance assessment. </title> <editor> In G. Borriello and C. Ebeling, editors, </editor> <booktitle> Research on Integrated Systems: Proceedings of the 1993 Symposium, </booktitle> <pages> pages 88-102, </pages> <year> 1993. </year>
Reference-contexts: While FPGAs are not as fast as typical application-specific integrated circuits (ASICs), they still hold a great speed advantage over functions executing in software. In fact, speedups of 1-2 orders of magnitude have been observed when frequently used software routines were implemented with FPGAs <ref> [8, 9, 12, 15, 19, 54] </ref>. Characteristically, these systems identify simple operations that are bottlenecks in software and map them to hardware. This is the approach used in this paper, except that the entire GA is intended for a hardware implementation. The remainder of this paper is organized as follows.
Reference: [13] <author> S. D. Brown, R. J. Francis, J. Rose, and Z. G. Vranesic. </author> <title> Field-Programmable Gate Arrays. </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Boston, Massachusetts, </address> <year> 1992. </year>
Reference-contexts: Since a general-purpose GA requires that the fitness function be easily changed, the hardware implementation must exploit the reprogramma-bility of certain types of field-programmable gate arrays (FPGAs) <ref> [13] </ref>, e.g. those from Xilinx [57]. Xilinx's FPGAs are programmed via a bit pattern stored in a static RAM and are thus easily reconfigured. While FPGAs are not as fast as typical application-specific integrated circuits (ASICs), they still hold a great speed advantage over functions executing in software.
Reference: [14] <author> C. Burns. </author> <title> An architecture for a Verilog hardware accelerator. </title> <booktitle> In Proceedings of the IEEE International Verilog HDL Conference, </booktitle> <pages> pages 2-11, </pages> <month> February </month> <year> 1996. </year> <note> http://www.crl.com/www/users/cb/cburns/. </note>
Reference-contexts: This hardware-based fault simulation component of our proposed hardware implementation of O'Dare and Arslan's fitness function is similar to hardware accelerators designed for fault simulation [29, 58] and logic simulation <ref> [14, 39, 47] </ref>. Then fitness evaluation simply requires a look-up table of previously selected vectors and the faults that they cover, a counter to cycle through all 2 (m+n) possible stuck-at faults, an accumulator for the members' scores, and some simple control logic.
Reference: [15] <author> S. Casselman. </author> <title> Virtual computing and the virtual computer. </title> <editor> In R. Werner and R. S. Sipple, editors, </editor> <booktitle> Proceedings of the IEEE Workshop on FPGAs for Custom Computing Machines, </booktitle> <pages> pages 43-48. </pages> <publisher> IEEE Computer Society Press, </publisher> <month> April </month> <year> 1993. </year> <note> http://www.vcc.com/. </note>
Reference-contexts: While FPGAs are not as fast as typical application-specific integrated circuits (ASICs), they still hold a great speed advantage over functions executing in software. In fact, speedups of 1-2 orders of magnitude have been observed when frequently used software routines were implemented with FPGAs <ref> [8, 9, 12, 15, 19, 54] </ref>. Characteristically, these systems identify simple operations that are bottlenecks in software and map them to hardware. This is the approach used in this paper, except that the entire GA is intended for a hardware implementation. The remainder of this paper is organized as follows.
Reference: [16] <author> H. Chan and P. Mazumder. </author> <title> A systolic architecture for high speed hypergraph partitioning using a genetic algorithm. </title> <editor> In X. Yao, editor, </editor> <booktitle> Progress in Evolutionary Computation, </booktitle> <pages> pages 109-126, </pages> <address> Berlin, </address> <year> 1995. </year> <title> Springer-Verlag. </title> <booktitle> Lecture Notes in Computer Science number 956. </booktitle> <pages> 18 </pages>
Reference-contexts: So the user's work can be limited to specifying the components and nets of the circuit. 4.3 Hypergraph Partitioning A GA approach to the hypergraph partitioning problem by Chan and Mazumder <ref> [16] </ref> uses a fitness function similar to that described in Section 4.2. After counting the number of nets that span the partition, this value is divided by the product of the sizes of the two partitions. <p> Problem-specific (non-FPGA) implementations include a suite of proprietary GAs in a text compression chip from DCP Research Corporation [55]. Other examples include Turton et al.'s applications to image processing [50], image registration [52], disk scheduling [51], and Chan et al.'s application to hyper-graph partitioning <ref> [16] </ref>. These GAs were designed for implementation on VLSI chips and thus are neither reconfigurable nor general-purpose. They are also expensive to produce in small quantities. However, the 17 intended applications are popular, so a VLSI implementation seems justifiable since the systems can be produced in bulk.
Reference: [17] <author> H. de Garis. </author> <title> An artificial brain. </title> <journal> New Generation Computing, </journal> <volume> 12 </volume> <pages> 215-221, </pages> <year> 1994. </year>
Reference-contexts: In this case, each population member represents a hardware design, and the goal is to find an optimal design with respect to an objective function, e.g. how well the design performs a specific task. There are many examples of evolvable hardware in the literature <ref> [1, 17, 26, 43] </ref>. 2 A VHDL Primer In this section we briefly review some of the VHDL fundamentals employed in this paper. Much more detail is available at the VIUF and VHDL UK WWW sites [2, 3], which include lists of several VHDL books.
Reference: [18] <author> K. A. De Jong and W. M. Spears. </author> <title> Using genetic algorithms to solve NP-complete problems. </title> <editor> In J. D. Schaffer, editor, </editor> <booktitle> Proceedings of the Third International Conference on Genetic Algorithms, </booktitle> <pages> pages 124-132. </pages> <publisher> Morgan Kaufmann Publishers, Incorporated, </publisher> <month> June </month> <year> 1989. </year>
Reference-contexts: A fit member in the SAT GA may map to a worthless non-solution in another problem unless the SAT member is optimal. The idea of exploiting the reductions between NP-complete problems was studied extensively by DeJong and Spears <ref> [18] </ref>, who also provided a SAT GA and empirical results on the hamiltonian circuit (HC) problem. Their SAT GA evaluates a population member by quantifying how "close" the bit string is to satisfying the given boolean function f .
Reference: [19] <author> M. Gokhale, W. Holmes, A. Kosper, S. Lucas, R. Minnich, D. Sweely, and D. Lopresti. </author> <title> Building and using a highly parallel programmable logic array. </title> <journal> IEEE Computer, </journal> <volume> 24(1) </volume> <pages> 81-89, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: While FPGAs are not as fast as typical application-specific integrated circuits (ASICs), they still hold a great speed advantage over functions executing in software. In fact, speedups of 1-2 orders of magnitude have been observed when frequently used software routines were implemented with FPGAs <ref> [8, 9, 12, 15, 19, 54] </ref>. Characteristically, these systems identify simple operations that are bottlenecks in software and map them to hardware. This is the approach used in this paper, except that the entire GA is intended for a hardware implementation. The remainder of this paper is organized as follows.
Reference: [20] <author> D. E. Goldberg. </author> <title> Genetic Algorithms in Search, Optimization, and Machine Learning. </title> <publisher> Addison-Wesley Publishing Company, Incorporated, </publisher> <address> Reading, Massachusetts, </address> <year> 1989. </year>
Reference-contexts: Thus these constants are not discussed here. The last portion of libs/sizing.hdl gives the locations in memory of the user-specified parameters described in Section 3.1. 3.3 The Architecture The HGA (Figure 1) was based on Goldberg's simple genetic algorithm (SGA) <ref> [20] </ref>. The HGA's modules were designed to correlate well with the SGA's operations, be simple and easily scalable, and have interfaces that facilitate parallelization. They were also designed to operate concurrently, yielding a coarse-grained pipeline. <p> This process continues until the GA run is complete and the MIC shuts down all the modules (i.e. init goes low). 3.5.5 Selection Module (SM) The HGA's selection method is similar to the implementation of roulette wheel selection used in Goldberg's SGA <ref> [20] </ref>. The SGA's selection procedure is as follows. 1. Using a random real number r 2 [0; 1], scale down the sum of the fitnesses of the current population to get S scale = r S fit . 2. <p> This is because regular (or uniform) crossover, if it changes anything, will create two invalid tours, i.e. some cities will appear more than once and some will not appear at all. Thus much work in applying GAs to the TSP (e.g. <ref> [20, 22] </ref>) involve the use of special crossover operators that preserve the validity of tours. This method can be used in the HGA but requires modification of the CMM. In lieu of this, conventional crossover operators can be used in conjunction with a special encoding of the population members. <p> First, other genetic algorithm operators could be implemented, including uniform crossover [48], multi-point crossover, and inversion <ref> [20] </ref>. Permutation-preserving crossover and mutation operators [20, 22] could be implemented for constrained problems such as the TSP. Additionally, the CMM could be parameterized to respect the boundaries of bit groups, i.e. only permit crossover at certain locations. <p> First, other genetic algorithm operators could be implemented, including uniform crossover [48], multi-point crossover, and inversion [20]. Permutation-preserving crossover and mutation operators <ref> [20, 22] </ref> could be implemented for constrained problems such as the TSP. Additionally, the CMM could be parameterized to respect the boundaries of bit groups, i.e. only permit crossover at certain locations.
Reference: [21] <author> D. E. Goldberg and K. Deb. </author> <title> A comparative analysis of selection schemes used in genetic algorithms. </title> <editor> In G. Rawlings, editor, </editor> <booktitle> Foundations of Genetic Algorithms, </booktitle> <pages> pages 69-93, </pages> <year> 1991. </year>
Reference-contexts: Additionally, the CMM could be parameterized to respect the boundaries of bit groups, i.e. only permit crossover at certain locations. This would be useful in preventing invalid strings in the generalized FPGA partitioning (Section 4.2) and hypergraph partitioning (Section 4.3) problems. Also, other selection methods <ref> [21] </ref> could be implemented. When implemented, these methods would be made available to the user via the software front end. The user would select the desired selection and crossover methods as HGA parameters.
Reference: [22] <author> P. Graham and B. Nelson. </author> <title> A hardware genetic algorithm for the traveling salesman problem on Splash 2. </title> <booktitle> In 5th International Workshop on Field-Programmable Logic and its Applications, </booktitle> <pages> pages 352-361, </pages> <month> August </month> <year> 1995. </year> <note> http://splish.ee.byu.edu/. </note>
Reference-contexts: This is because regular (or uniform) crossover, if it changes anything, will create two invalid tours, i.e. some cities will appear more than once and some will not appear at all. Thus much work in applying GAs to the TSP (e.g. <ref> [20, 22] </ref>) involve the use of special crossover operators that preserve the validity of tours. This method can be used in the HGA but requires modification of the CMM. In lieu of this, conventional crossover operators can be used in conjunction with a special encoding of the population members. <p> First, other genetic algorithm operators could be implemented, including uniform crossover [48], multi-point crossover, and inversion [20]. Permutation-preserving crossover and mutation operators <ref> [20, 22] </ref> could be implemented for constrained problems such as the TSP. Additionally, the CMM could be parameterized to respect the boundaries of bit groups, i.e. only permit crossover at certain locations. <p> The result is a general-purpose GA engine which is useful in many applications where software-based GA implementations are too slow, e.g. when real-time constraints apply. Recently there has been more work on hardware-based GAs. Other VHDL GA implementations include Alander et al. [6] and Graham and Nelson <ref> [22] </ref>. Salami and Cain applied the design of this paper to the problems of finding optimal gains for a proportional integral differential (PID) controller [41] and optimization of electricity generation in response to demand [42].
Reference: [23] <author> T. Hamalainen, H. Klapuri, J. Saarinen, P. Ojala, and K. Kaski. </author> <title> Accelerating genetic algorithm computation in tree shaped parallel computer. </title> <journal> Journal of Systems Architecture, </journal> <volume> 42(1) </volume> <pages> 19-36, </pages> <month> August </month> <year> 1996. </year>
Reference-contexts: In similar work, Red'ko et al. [40] developed a GA which implemented crossover and mutation in hardware. Hesser et al. [25] implemented in hardware crossover, mutation, and a simple neighborhood-based selection routine. Hamalainen et al. <ref> [23] </ref> designed the genetic algorithm parallel accelerator (GAPA), which is a tree structure of processors for executing a GA. The GAPA is a parallel GA with specialized hardware support to accelerate certain operations. Sitkoff et al. [46] designed a hardware GA for partitioning logic designs across Xilinx FPGAs.
Reference: [24] <author> J. P. Hayes. </author> <title> Computer Architecture and Organization. </title> <publisher> McGraw-Hill Book Company, </publisher> <address> New York, </address> <note> second edition, </note> <year> 1989. </year>
Reference-contexts: It then notifies the MIC of completion which in turn shuts down the HGA modules and signals the front end. 3.4 Inter-Module Communication The modules in Figure 1 communicate via a simple asynchronous handshaking protocol similar to asynchronous bus protocols used in computer architectures <ref> [24] </ref>. When transferring data from the initiating 5 module I to the participating module P , I signals P by raising a request signal to 1 and awaits an ac-knowledgment. When P agrees to participate in the transfer, it raises an acknowledgment signal.
Reference: [25] <author> J. Hesser, J. Ludvig, and R. </author> <title> Manner. Real-time optimization by hardware supported genetic algorithms. </title> <editor> In P. Osmera, editor, </editor> <booktitle> Proceedings of the 2nd International Mendel Conference on Genetic Algorithms, Optimization, Fuzzy Logic and Neural Networks, </booktitle> <pages> pages 52-59, </pages> <year> 1996. </year>
Reference-contexts: A subset of the GA operations have been mapped to hardware by Liu [31], who designed and simulated a hardware implementation of the crossover and mutation operators. In similar work, Red'ko et al. [40] developed a GA which implemented crossover and mutation in hardware. Hesser et al. <ref> [25] </ref> implemented in hardware crossover, mutation, and a simple neighborhood-based selection routine. Hamalainen et al. [23] designed the genetic algorithm parallel accelerator (GAPA), which is a tree structure of processors for executing a GA. The GAPA is a parallel GA with specialized hardware support to accelerate certain operations.
Reference: [26] <author> T. Higuchi, H. Iba, and B. Manderick. </author> <title> Evolvable hardware. </title> <editor> In H. Kitano and J. A. Hendler, editors, </editor> <booktitle> Massively Parallel Artificial Intelligence, </booktitle> <pages> pages 398-421. </pages> <publisher> MIT Press, </publisher> <year> 1994. </year>
Reference-contexts: In this case, each population member represents a hardware design, and the goal is to find an optimal design with respect to an objective function, e.g. how well the design performs a specific task. There are many examples of evolvable hardware in the literature <ref> [1, 17, 26, 43] </ref>. 2 A VHDL Primer In this section we briefly review some of the VHDL fundamentals employed in this paper. Much more detail is available at the VIUF and VHDL UK WWW sites [2, 3], which include lists of several VHDL books.
Reference: [27] <author> H. Hogl, A. Kugel, J. Ludvig, R. Manner, K.-H. Noffz, and R. Zoz. </author> <title> Enable++: A second generation FPGA processor. </title> <booktitle> In Proceedings of the IEEE Symposium on FPGAs for Custom Computing Machines, </booktitle> <pages> pages 45-53, </pages> <month> April </month> <year> 1995. </year> <note> http://www-mp.informatik.uni-mannheim.de/. </note>
Reference-contexts: Additionally, the user specifies the fitness function in some programming or other specification language (e.g. C or VHDL). Then software translates the specification into a hardware image and programs the FPGAs that implement the fitness function. Many such software-to-hardware translators exist <ref> [27, 35, 54] </ref>. Then the front end signals the back end. When the HGA back end detects the signal, it runs the GA based on the parameters in the shared memory. When done, the back end signals the front end.
Reference: [28] <author> P. D. Hortensius, H. C. Card, and R. D. McLeod. </author> <title> Parallel random number generation for VLSI using cellular automata. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 38 </volume> <pages> 1466-1473, </pages> <month> October </month> <year> 1989. </year>
Reference-contexts: It has also been shown that such a rule sequence has more randomness than a linear feedback shift register 6 (LFSR) of corresponding length <ref> [28] </ref>. This scheme is implemented in state active in rng.hdl. 3.5.2 Shared Memory The shared memory is actually external to the HGA system, but is presented here for completeness. The memory's specifications are known by the memory interface and control module (MIC, Section 3.5.3).
Reference: [29] <author> S. Kang, Y. Hur, and S. A. Szygenda. </author> <title> A hardware accelerator for fault simulation utilizing a reconfigurable array architecture. </title> <booktitle> VLSI Design, </booktitle> <volume> 4(2) </volume> <pages> 119-133, </pages> <year> 1996. </year> <note> http://www.ece.utexas.edu/ece/people/profs/Szygenda.html. </note>
Reference-contexts: This hardware-based fault simulation component of our proposed hardware implementation of O'Dare and Arslan's fitness function is similar to hardware accelerators designed for fault simulation <ref> [29, 58] </ref> and logic simulation [14, 39, 47]. Then fitness evaluation simply requires a look-up table of previously selected vectors and the faults that they cover, a counter to cycle through all 2 (m+n) possible stuck-at faults, an accumulator for the members' scores, and some simple control logic.
Reference: [30] <author> F. T. Leighton. </author> <title> Introduction to Parallel Algorithms and Architectures: Arrays, Trees, Hypercubes. </title> <publisher> Morgan Kaufmann Publishers, Incorporated, </publisher> <address> San Mateo, California, </address> <year> 1992. </year>
Reference-contexts: denoted val (e i ), is given as follows for the operators AND (^), OR (_) and NOT (e i ): val (e 1 ^ ^ e ` ) = avg (val (e 1 ); : : :; val (e ` )); 16 Also see an excellent description by Leighton <ref> [30] </ref>. 17 The size of each register and comparator depends on the desired precision of the numbers in the tuples, but should be at least log 2 n bits. 15 and where avg (x 1 ; : : : ; x ` ) returns the mean of the values x 1
Reference: [31] <author> J. Liu. </author> <title> A general purpose hardware implementation of genetic algorithms. </title> <type> Master's thesis, </type> <institution> University of North Carolina at Charlotte, </institution> <year> 1993. </year>
Reference-contexts: Additionally, Tommiska and Vuori [49] implemented a GA with Altera HDL (AHDL) for implementation on Altera FLEX 10K FPGAs [7]. A subset of the GA operations have been mapped to hardware by Liu <ref> [31] </ref>, who designed and simulated a hardware implementation of the crossover and mutation operators. In similar work, Red'ko et al. [40] developed a GA which implemented crossover and mutation in hardware. Hesser et al. [25] implemented in hardware crossover, mutation, and a simple neighborhood-based selection routine.
Reference: [32] <author> G. M. Megson and I. M. Bland. </author> <title> A generic systolic array for genetic algorithms. </title> <type> Technical report, </type> <institution> University of Reading, </institution> <month> May </month> <year> 1996. </year> <note> http://www.cs.rdg.ac.uk/cs/research/Publications/reports.html. 19 </note>
Reference-contexts: After running the GA in software, the bottleneck was determined to be in evaluation of the fitness function. Thus parallel fitness evaluation modules were implemented on FPGAs and the remainder of the GA ran in software. Megson and Bland <ref> [32] </ref> present a design for a hardware-based GA that implements all the GA operations except fitness evaluation in a pipeline of seven systolic arrays. Problem-specific (non-FPGA) implementations include a suite of proprietary GAs in a text compression chip from DCP Research Corporation [55].
Reference: [33] <institution> Mentor Graphics Corporation, Wilsonville, Oregon. </institution> <note> Mentor Graphics VHDL Reference Manual, 1994. http://www.mentorg.com/. </note>
Reference-contexts: In this design, we use the types qsim_state and qsim_state_vector, which are specific to the simulators and compilers of Mentor Graphics <ref> [33] </ref>. These types are nearly identical to bit and bit_vector, so a direct substitution should work to map the code of this paper to code compatible with other VHDL compilers. The functions to_qsim_state and to_integer appear frequently in the code.
Reference: [34] <institution> Mentor Graphics Corporation, Wilsonville, Oregon. VHDL Style Guide for AutoLogic II, </institution> <year> 1995. </year> <note> http://www.mentorg.com/. </note>
Reference-contexts: Finally, note that all the VHDL code except that which is in memory.hdl is synthesizable. That is, it uses a subset of VHDL that can not only be simulated, but can be mapped to actual hardware by using AutoLogic II from Mentor Graphics <ref> [34, 35] </ref>. Other synthesizers exist and can be used to synthesize the HGA code if the Mentor-specific code is changed. 3 The Design The functional model of the HGA is as follows. <p> The specific designs implemented from the general designs depend upon parameters provided at VHDL compile time. When the parameters are specified, the design can be simulated or implemented with a VHDL synthesizer such as AutoLogic II from Mentor Graphics <ref> [34, 35] </ref>. The parameters are set in libs/sizing.hdl and used in the other VHDL files. They are as follows. 1. The width in bits of the crossover and mutation probabilities and the random numbers sent from rng.hdl to xovermut.hdl is denoted p. 2.
Reference: [35] <institution> Mentor Graphics Corporation, Wilsonville, Oregon. Synthesizing with AutoLogic II, </institution> <year> 1996. </year> <note> http://www.mentorg.com/. </note>
Reference-contexts: Finally, note that all the VHDL code except that which is in memory.hdl is synthesizable. That is, it uses a subset of VHDL that can not only be simulated, but can be mapped to actual hardware by using AutoLogic II from Mentor Graphics <ref> [34, 35] </ref>. Other synthesizers exist and can be used to synthesize the HGA code if the Mentor-specific code is changed. 3 The Design The functional model of the HGA is as follows. <p> Additionally, the user specifies the fitness function in some programming or other specification language (e.g. C or VHDL). Then software translates the specification into a hardware image and programs the FPGAs that implement the fitness function. Many such software-to-hardware translators exist <ref> [27, 35, 54] </ref>. Then the front end signals the back end. When the HGA back end detects the signal, it runs the GA based on the parameters in the shared memory. When done, the back end signals the front end. <p> The specific designs implemented from the general designs depend upon parameters provided at VHDL compile time. When the parameters are specified, the design can be simulated or implemented with a VHDL synthesizer such as AutoLogic II from Mentor Graphics <ref> [34, 35] </ref>. The parameters are set in libs/sizing.hdl and used in the other VHDL files. They are as follows. 1. The width in bits of the crossover and mutation probabilities and the random numbers sent from rng.hdl to xovermut.hdl is denoted p. 2.
Reference: [36] <author> Z. Michalewicz. </author> <title> Genetic Algorithms + Data Structures = Evolution Programs. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <note> second edition, </note> <year> 1994. </year>
Reference-contexts: actual implementation since groups of components will likely be mapped to different FPGAs. 10 4 Example Applications This section gives a high-level description of several problems that the HGA is applicable to given the current state-of-the-art in FPGA technology. 4.1 A Mathematical Function Our first example application comes from Michalewicz <ref> [36] </ref>. The problem is to optimize the function f (x 1 ; x 2 ) = 21:5 + x 1 sin (4x 1 ) + x 2 sin (20x 2 ) (1) where 3:0 x 1 12:1 and 4:1 x 2 5:8.
Reference: [37] <author> B. Norman and J. Bean. </author> <title> Random keys genetic algorithm for job shop scheduling. </title> <journal> Engineering Design and Automation, </journal> <note> to appear. http://www-personal.engin.umich.edu/~jbean/. </note>
Reference-contexts: This method can be used in the HGA but requires modification of the CMM. In lieu of this, conventional crossover operators can be used in conjunction with a special encoding of the population members. One such encoding is called a random keys encoding <ref> [11, 37] </ref>. In this encoding, each tour is represented by a tuple of random numbers, one number for each city, with each number from [0; 1]. After selecting a pair of tours, simple or uniform crossover can be applied, yielding two new tuples. <p> Finally, we note that the scheme just presented can be adapted for application to other problems with similar constraints as the TSP. These include scheduling problems, vehicle routing, and resource allocation (a generalization of the 0-1 knapsack problem and the set partitioning problem) <ref> [11, 37] </ref>. The HGA can be applied to these problems as well with a slight increase in complexity. 4.6 Other NP-Complete Problems In this section we explore the exploitation of polynomial-time reductions between instances of NP-complete problems. Developing a GA to solve any NP-complete problem (e.g.
Reference: [38] <author> M. J. O'Dare and T. Arslan. </author> <title> Hierarchical test pattern generation using a genetic algorithm with a dynamic global reference table. </title> <booktitle> In Proceedings of the First IEE/IEEE International Conference on Genetic Algorithms in Engineering Systems: Innovations and Applications, </booktitle> <pages> pages 517-523, </pages> <month> September </month> <year> 1995. </year> <note> http://vlsi2.elsy.cf.ac.uk/group/. </note>
Reference-contexts: See Abramovici et al. [4] for more information on this and other fault models. O'Dare and Arslan <ref> [38] </ref> have described a GA to generate test vectors for stuck-at fault detection in combinational circuits (i.e. circuits with no memory). In their scheme, each population member is a single test vector. The member's fitness is evaluated on the basis of how many new faults it covers.
Reference: [39] <author> Precedence, Incorporated, Campbell, </author> <title> California. Product Brief, </title> <note> 1996. http://www.precedence.com/. </note>
Reference-contexts: This hardware-based fault simulation component of our proposed hardware implementation of O'Dare and Arslan's fitness function is similar to hardware accelerators designed for fault simulation [29, 58] and logic simulation <ref> [14, 39, 47] </ref>. Then fitness evaluation simply requires a look-up table of previously selected vectors and the faults that they cover, a counter to cycle through all 2 (m+n) possible stuck-at faults, an accumulator for the members' scores, and some simple control logic.
Reference: [40] <author> V. G. Red'ko, M. I. Dyabin, V. M. Elagin, N. G. Karpinskii, A. I. Polovyanyuk, V. A. Serechenko, and O. V. Urgant. </author> <title> On microelectronic implementation of an evolutionary optimizer. </title> <journal> Russian Microelectronics, </journal> <volume> 24(3) </volume> <pages> 182-185, </pages> <year> 1995. </year> <journal> Translated from Mikroelektronika, </journal> <volume> vol. 24, no. 3, </volume> <pages> pp. 207-210, </pages> <year> 1995. </year>
Reference-contexts: A subset of the GA operations have been mapped to hardware by Liu [31], who designed and simulated a hardware implementation of the crossover and mutation operators. In similar work, Red'ko et al. <ref> [40] </ref> developed a GA which implemented crossover and mutation in hardware. Hesser et al. [25] implemented in hardware crossover, mutation, and a simple neighborhood-based selection routine. Hamalainen et al. [23] designed the genetic algorithm parallel accelerator (GAPA), which is a tree structure of processors for executing a GA.
Reference: [41] <author> M. Salami and G. Cain. </author> <title> An adaptive PID controller based on a genetic algorithm processor. </title> <booktitle> In Proceedings of the First IEE/IEEE International Conference on Genetic Algorithms in Engineering Systems: Innovations and Applications, </booktitle> <pages> pages 88-93, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: Recently there has been more work on hardware-based GAs. Other VHDL GA implementations include Alander et al. [6] and Graham and Nelson [22]. Salami and Cain applied the design of this paper to the problems of finding optimal gains for a proportional integral differential (PID) controller <ref> [41] </ref> and optimization of electricity generation in response to demand [42]. Additionally, Tommiska and Vuori [49] implemented a GA with Altera HDL (AHDL) for implementation on Altera FLEX 10K FPGAs [7].
Reference: [42] <author> M. Salami and G. Cain. </author> <title> Multiple genetic algorithm processor for the economic power dispatch problem. </title> <booktitle> In Proceedings of the First IEE/IEEE International Conference on Genetic Algorithms in Engineering Systems: Innovations and Applications, </booktitle> <pages> pages 188-193, </pages> <month> September </month> <year> 1995. </year>
Reference-contexts: Other VHDL GA implementations include Alander et al. [6] and Graham and Nelson [22]. Salami and Cain applied the design of this paper to the problems of finding optimal gains for a proportional integral differential (PID) controller [41] and optimization of electricity generation in response to demand <ref> [42] </ref>. Additionally, Tommiska and Vuori [49] implemented a GA with Altera HDL (AHDL) for implementation on Altera FLEX 10K FPGAs [7]. A subset of the GA operations have been mapped to hardware by Liu [31], who designed and simulated a hardware implementation of the crossover and mutation operators.
Reference: [43] <editor> E. Sanchez and M. Tomassini, editors. </editor> <title> Towards Evolvable Hardware: The Evolutionary Engineering Approach. </title> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1996. </year> <booktitle> Lecture Notes in Computer Science number 1062. </booktitle>
Reference-contexts: In this case, each population member represents a hardware design, and the goal is to find an optimal design with respect to an objective function, e.g. how well the design performs a specific task. There are many examples of evolvable hardware in the literature <ref> [1, 17, 26, 43] </ref>. 2 A VHDL Primer In this section we briefly review some of the VHDL fundamentals employed in this paper. Much more detail is available at the VIUF and VHDL UK WWW sites [2, 3], which include lists of several VHDL books.
Reference: [44] <author> S. D. Scott, S. Seth, and A. Samal. </author> <title> A hardware engine for genetic algorithms. </title> <type> Technical Report UNL-CSE-97-001, </type> <institution> University of Nebraska-Lincoln, </institution> <month> July </month> <year> 1997. </year> <month> ftp://ftp.cse.unl.edu/pub/TechReps/UNL-CSE-97-001.ps.gz. </month>
Reference-contexts: Finally, in Section 6 we summarize and review other hardware-based GAs. Also available are simulation results, a theoretical analysis of this design, and a description of a proof-of-concept prototype. They are beyond the scope of this paper and are instead given in an associated technical report <ref> [44] </ref>. As they become available, updates to the code in this paper will be made available at ftp://ftp.cse.unl.edu/pub/HGA. Finally, it is important to distinguish hardware-based GAs from evolvable hardware. The former (e.g. the design presented in this paper) is an implementation of a genetic algorithm in hardware. <p> So a reset places the SM into state idle where it stores the new sof into sum and restarts selection. The HGA is designed to allow for multiple SMs to operate in parallel, which is useful when the SM is the bottleneck of the pipeline <ref> [44] </ref>. The PS sends the same members to all SMs, but this does not pose a problem for selection since each SM uses an independent pair of random bit strings to scale down the sum of fitnesses. Thus each selection process is independent of the others. <p> While not in the current design, it is possible to allow for multiple FMs to operate in parallel, much like the parallel SMs of Section 3.5.5. This is useful when the FM is the bottleneck of the pipeline <ref> [44] </ref>. If parallel FMs were to be added to this design, the duty of writing new members to memory and maintaining records of the HGA's state (e.g. maintaining numgens and psizetmp) would best be shifted from the FM to a new module called the memory writer (MW). <p> Now repeat for the other member, yielding a cumulative delay of 46 cycles. But note that operations performed in evaluating the first member can partially overlap operations evaluating the second. So in fact, both members can be evaluated in 43 cycles. In related work <ref> [44] </ref>, we give simulation results on this problem and contrast the results to those from a software implementation of Goldberg's SGA. 4.2 Logic Partitioning Sitkoff et al. [46] have proposed a scheme to apply GAs to the problem of partitioning logic designs across two FPGAs. <p> This process repeats until the termination criteria are satisfied. Another extension of this design involves allowing parallelization of the fitness modules. This is useful when the pipeline's bottleneck lies in the FM rather than the SM <ref> [44] </ref>.
Reference: [45] <author> M. Serra, T. Slater, J. C. Muzio, and D. M. Miller. </author> <title> The analysis of one-dimensional linear cellular automata and their aliasing properties. </title> <journal> IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, </journal> <volume> 9(7) </volume> <pages> 767-778, </pages> <month> July </month> <year> 1990. </year>
Reference-contexts: Here s i is the current state of site (cell) i in the linear array, s + i is the next state for s i , and is the exclusive OR operator. Serra et al. <ref> [45] </ref> showed that a 16-cell CA whose cells are updated by the rule sequence 150-150-90-150 90-150 produces a maximum-length cycle, i.e. it cycles through all 2 16 possible bit patterns except the all 0s pattern.
Reference: [46] <author> N. Sitkoff, M. Wazlowski, A. Smith, and H. Silverman. </author> <title> Implementing a genetic algorithm on a parallel custom computing machine. </title> <booktitle> In IEEE Symposium on FPGAs for Custom Computing Machines, </booktitle> <pages> pages 180-187, </pages> <month> April </month> <year> 1995. </year> <note> http://www.lems.brown.edu/arm/. </note>
Reference-contexts: So in fact, both members can be evaluated in 43 cycles. In related work [44], we give simulation results on this problem and contrast the results to those from a software implementation of Goldberg's SGA. 4.2 Logic Partitioning Sitkoff et al. <ref> [46] </ref> have proposed a scheme to apply GAs to the problem of partitioning logic designs across two FPGAs. <p> Hamalainen et al. [23] designed the genetic algorithm parallel accelerator (GAPA), which is a tree structure of processors for executing a GA. The GAPA is a parallel GA with specialized hardware support to accelerate certain operations. Sitkoff et al. <ref> [46] </ref> designed a hardware GA for partitioning logic designs across Xilinx FPGAs. After running the GA in software, the bottleneck was determined to be in evaluation of the fitness function. Thus parallel fitness evaluation modules were implemented on FPGAs and the remainder of the GA ran in software.
Reference: [47] <institution> Synopsys, Incorporated, Mountain View, California. Arkos Datasheet, </institution> <year> 1997. </year> <note> http://www.synopsys.com/. </note>
Reference-contexts: This hardware-based fault simulation component of our proposed hardware implementation of O'Dare and Arslan's fitness function is similar to hardware accelerators designed for fault simulation [29, 58] and logic simulation <ref> [14, 39, 47] </ref>. Then fitness evaluation simply requires a look-up table of previously selected vectors and the faults that they cover, a counter to cycle through all 2 (m+n) possible stuck-at faults, an accumulator for the members' scores, and some simple control logic.
Reference: [48] <author> G. Syswerda. </author> <title> Uniform crossover in genetic algorithms. </title> <booktitle> In Proceedings of the Third International Conference on Genetic Algorithms and their Applications, </booktitle> <pages> pages 2-9, </pages> <year> 1989. </year> <month> 20 </month>
Reference-contexts: Thus an HGA implementation of the SAT GA is feasible. 5 Extensions of the Design There are many possible ways to extend the design of Section 3, many of which require only simple modifications to the VHDL code. First, other genetic algorithm operators could be implemented, including uniform crossover <ref> [48] </ref>, multi-point crossover, and inversion [20]. Permutation-preserving crossover and mutation operators [20, 22] could be implemented for constrained problems such as the TSP. Additionally, the CMM could be parameterized to respect the boundaries of bit groups, i.e. only permit crossover at certain locations.
Reference: [49] <author> M. Tommiska and J. Vuori. </author> <title> Implementation of genetic algorithms with programmable logic devices. </title> <editor> In J. T. Alander, editor, </editor> <booktitle> Proceedings of the Second Nordic Workshop on Genetic Algorithms and their Applications (2NWGA), </booktitle> <pages> pages 71-78, </pages> <month> August </month> <year> 1996. </year> <note> http://www.uwasa.fi/cs/publications/2NWGA.html. </note>
Reference-contexts: Salami and Cain applied the design of this paper to the problems of finding optimal gains for a proportional integral differential (PID) controller [41] and optimization of electricity generation in response to demand [42]. Additionally, Tommiska and Vuori <ref> [49] </ref> implemented a GA with Altera HDL (AHDL) for implementation on Altera FLEX 10K FPGAs [7]. A subset of the GA operations have been mapped to hardware by Liu [31], who designed and simulated a hardware implementation of the crossover and mutation operators.
Reference: [50] <author> B. C. H. Turton and T. Arslan. </author> <title> An architecture for enhancing image processing via parallel genetic algorithms & data compression. </title> <booktitle> In Proceedings of the First IEE/IEEE International Conference on Genetic Algorithms in Engineering Systems: Innovations and Applications, </booktitle> <pages> pages 337-342, </pages> <month> September </month> <year> 1995. </year> <note> http://vlsi2.elsy.cf.ac.uk/group/. </note>
Reference-contexts: Problem-specific (non-FPGA) implementations include a suite of proprietary GAs in a text compression chip from DCP Research Corporation [55]. Other examples include Turton et al.'s applications to image processing <ref> [50] </ref>, image registration [52], disk scheduling [51], and Chan et al.'s application to hyper-graph partitioning [16]. These GAs were designed for implementation on VLSI chips and thus are neither reconfigurable nor general-purpose. They are also expensive to produce in small quantities.
Reference: [51] <author> B. C. H. Turton and T. Arslan. </author> <title> A parallel genetic VLSI architecture for combinatorial real-time applications|disc scheduling. </title> <booktitle> In Proceedings of the First IEE/IEEE International Conference on Genetic Algorithms in Engineering Systems: Innovations and Applications, </booktitle> <pages> pages 493-499, </pages> <month> September </month> <year> 1995. </year> <note> http://vlsi2.elsy.cf.ac.uk/group/. </note>
Reference-contexts: Due to pipelining, parallelization, and no function call overhead, a hardware GA yields a significant speedup over a software GA, which is especially useful when the GA is used for real-time applications, e.g. disk scheduling <ref> [51] </ref> and image registration [52]. Since a general-purpose GA requires that the fitness function be easily changed, the hardware implementation must exploit the reprogramma-bility of certain types of field-programmable gate arrays (FPGAs) [13], e.g. those from Xilinx [57]. <p> Problem-specific (non-FPGA) implementations include a suite of proprietary GAs in a text compression chip from DCP Research Corporation [55]. Other examples include Turton et al.'s applications to image processing [50], image registration [52], disk scheduling <ref> [51] </ref>, and Chan et al.'s application to hyper-graph partitioning [16]. These GAs were designed for implementation on VLSI chips and thus are neither reconfigurable nor general-purpose. They are also expensive to produce in small quantities.
Reference: [52] <author> B. C. H. Turton, T. Arslan, and D. H. Horrocks. </author> <title> A hardware architecture for a parallel genetic algorithm for image registration. </title> <booktitle> In Proceedings of the IEE Colloquium on Genetic Algorithms in Image Processing and Vision, </booktitle> <pages> pages 11/1-11/6, </pages> <month> October </month> <year> 1994. </year> <note> http://vlsi2.elsy.cf.ac.uk/group/. </note>
Reference-contexts: Due to pipelining, parallelization, and no function call overhead, a hardware GA yields a significant speedup over a software GA, which is especially useful when the GA is used for real-time applications, e.g. disk scheduling [51] and image registration <ref> [52] </ref>. Since a general-purpose GA requires that the fitness function be easily changed, the hardware implementation must exploit the reprogramma-bility of certain types of field-programmable gate arrays (FPGAs) [13], e.g. those from Xilinx [57]. <p> Problem-specific (non-FPGA) implementations include a suite of proprietary GAs in a text compression chip from DCP Research Corporation [55]. Other examples include Turton et al.'s applications to image processing [50], image registration <ref> [52] </ref>, disk scheduling [51], and Chan et al.'s application to hyper-graph partitioning [16]. These GAs were designed for implementation on VLSI chips and thus are neither reconfigurable nor general-purpose. They are also expensive to produce in small quantities.
Reference: [53] <author> J. E. Volder. </author> <title> The CORDIC trigonometric computing technique. </title> <journal> IRE Transactions on Electronic Computers, </journal> <volume> EC-8:330-334, </volume> <month> September </month> <year> 1959. </year>
Reference-contexts: His binary strings were manipulated directly and converted to real values only during fitness evaluation. A hardware implementation of this fitness function is straightforward if the CORDIC algorithm <ref> [53] </ref> is used to evaluate the sines. To evaluate Equation 1 in hardware, we require a single multiplier 14 , two adder/subtracters, six registers, two shifters, and a lookup table in the form of a 16 fi 18 ROM. All these components easily fit on a Xilinx XC4013 FPGA [57].
Reference: [54] <author> M. Wazlowski, A. Smith, R. Citro, and H. F. Silverman. Armstrong III: </author> <title> A loosely-coupled parallel processor with reconfigurable computing capabilities. </title> <type> Technical report, </type> <institution> Brown University, </institution> <year> 1996. </year> <note> http://www.lems.brown.edu/arm/. </note>
Reference-contexts: While FPGAs are not as fast as typical application-specific integrated circuits (ASICs), they still hold a great speed advantage over functions executing in software. In fact, speedups of 1-2 orders of magnitude have been observed when frequently used software routines were implemented with FPGAs <ref> [8, 9, 12, 15, 19, 54] </ref>. Characteristically, these systems identify simple operations that are bottlenecks in software and map them to hardware. This is the approach used in this paper, except that the entire GA is intended for a hardware implementation. The remainder of this paper is organized as follows. <p> Additionally, the user specifies the fitness function in some programming or other specification language (e.g. C or VHDL). Then software translates the specification into a hardware image and programs the FPGAs that implement the fitness function. Many such software-to-hardware translators exist <ref> [27, 35, 54] </ref>. Then the front end signals the back end. When the HGA back end detects the signal, it runs the GA based on the parameters in the shared memory. When done, the back end signals the front end.
Reference: [55] <author> L. Wirbel. </author> <title> Compression chip is first to use genetic algorithms. </title> <journal> Electronic Engineering Times, </journal> <pages> page 17, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Megson and Bland [32] present a design for a hardware-based GA that implements all the GA operations except fitness evaluation in a pipeline of seven systolic arrays. Problem-specific (non-FPGA) implementations include a suite of proprietary GAs in a text compression chip from DCP Research Corporation <ref> [55] </ref>. Other examples include Turton et al.'s applications to image processing [50], image registration [52], disk scheduling [51], and Chan et al.'s application to hyper-graph partitioning [16]. These GAs were designed for implementation on VLSI chips and thus are neither reconfigurable nor general-purpose.
Reference: [56] <author> S. Wolfram. </author> <title> Universality and complexity in cellular automata. </title> <journal> Physica, </journal> <volume> 10D:1-35, </volume> <year> 1984. </year>
Reference-contexts: After loading its seed into rn, the RNG uses a linear cellular automaton (CA) to generate a sequence of pseudorandom bit strings. The CA used in the RNG consists of 16 alternating cells which change their states according to rules 90 and 150 as described by Wolfram <ref> [56] </ref>: Rule 90: s + i = s i1 s i+1 Rule 150: s + i = s i1 s i s i+1 .
Reference: [57] <institution> Xilinx, Incorporated, </institution> <address> San Jose, California. </address> <note> The Programmable Logic Data Book, 1996. http://www.xilinx.com/. </note>
Reference-contexts: Since a general-purpose GA requires that the fitness function be easily changed, the hardware implementation must exploit the reprogramma-bility of certain types of field-programmable gate arrays (FPGAs) [13], e.g. those from Xilinx <ref> [57] </ref>. Xilinx's FPGAs are programmed via a bit pattern stored in a static RAM and are thus easily reconfigured. While FPGAs are not as fast as typical application-specific integrated circuits (ASICs), they still hold a great speed advantage over functions executing in software. <p> To evaluate Equation 1 in hardware, we require a single multiplier 14 , two adder/subtracters, six registers, two shifters, and a lookup table in the form of a 16 fi 18 ROM. All these components easily fit on a Xilinx XC4013 FPGA <ref> [57] </ref>. In the evaluation process, first x 1 is multiplied by 4 in the multiplier, and then x 2 is multiplied by 20 in the multiplier in the next cycle. Then both sine calculations run concurrently via CORDIC.
Reference: [58] <author> Zycad Corporation, Fremont, </author> <title> California. Paradigm XP Product News, </title> <note> 1996. http://www.zycad.com/. 21 </note>
Reference-contexts: This hardware-based fault simulation component of our proposed hardware implementation of O'Dare and Arslan's fitness function is similar to hardware accelerators designed for fault simulation <ref> [29, 58] </ref> and logic simulation [14, 39, 47]. Then fitness evaluation simply requires a look-up table of previously selected vectors and the faults that they cover, a counter to cycle through all 2 (m+n) possible stuck-at faults, an accumulator for the members' scores, and some simple control logic.
References-found: 58

