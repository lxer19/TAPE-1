URL: http://www.cs.wustl.edu/~schmidt/daemon-design-94.ps.gz
Refering-URL: http://www.cs.wustl.edu/~schmidt/resume.html
Root-URL: http://www.cs.wustl.edu
Email: schmidt@ics.uci.edu  
Title: A Domain Analysis of Network Daemon Design Dimensions  
Author: Douglas C. Schmidt 
Address: Irvine, CA 92717, (714) 856-4105  
Affiliation: Department of Information and Computer Science University of California,  
Abstract: An earlier version of this paper appeared in the C++ Report, March/April, 1994. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> D. C. Schmidt, </author> <title> IPC SAP: An Object-Oriented Interface to Interprocess Communication Services, </title> <journal> C++ Report, </journal> <volume> vol. 4, </volume> <month> November/December </month> <year> 1992. </year>
Reference-contexts: This article is part of a continuing series that describes object-oriented techniques that may be used to simplify the development of reliable, robust, and extensible distributed applications. Previous articles in this series have examined C++ wrappers that encapsulate the socket interpro-cess communication (IPC) interface <ref> [1] </ref> and the event demul-tiplexing mechanisms provided by the select and poll system calls [2, 3]. This article presents an object-oriented domain analysis of key design dimensions for network server daemons.
Reference: [2] <author> D. C. Schmidt, </author> <title> The Reactor: An Object-Oriented Interface for Event-Driven UNIX I/O Multiplexing (Part 1 of 2), </title> <journal> C++ Report, </journal> <volume> vol. 5, </volume> <month> February </month> <year> 1993. </year>
Reference-contexts: Previous articles in this series have examined C++ wrappers that encapsulate the socket interpro-cess communication (IPC) interface [1] and the event demul-tiplexing mechanisms provided by the select and poll system calls <ref> [2, 3] </ref>. This article presents an object-oriented domain analysis of key design dimensions for network server daemons. Subsequent articles will describe a framework called the ADAPTIVE Service eXecutive (ASX) [4] that provides flexibility across the design dimensions identified in this article.
Reference: [3] <author> D. C. Schmidt, </author> <title> The Object-Oriented Design and Implementation of the Reactor: A C++ Wrapper for UNIX I/O Multiplexing (Part 2 of 2), </title> <journal> C++ Report, </journal> <volume> vol. 5, </volume> <month> September </month> <year> 1993. </year>
Reference-contexts: Previous articles in this series have examined C++ wrappers that encapsulate the socket interpro-cess communication (IPC) interface [1] and the event demul-tiplexing mechanisms provided by the select and poll system calls <ref> [2, 3] </ref>. This article presents an object-oriented domain analysis of key design dimensions for network server daemons. Subsequent articles will describe a framework called the ADAPTIVE Service eXecutive (ASX) [4] that provides flexibility across the design dimensions identified in this article. <p> These five dimensions were identified by generalizing from practical design and implementation experience with a number of distributed applications ranging from on-line transaction processing systems <ref> [3] </ref>, PBX switch performance monitoring systems [9], and multi-processor-based communication subsystems [4]. Each of the five dimensions discussed below offer a set of relatively orthogonal design alternatives. These alternatives are examined to define the vocabulary of the network daemon domain, illustrate key abstractions, and clarify the boundaries of the domain.
Reference: [4] <author> D. C. Schmidt, ASX: </author> <title> an Object-Oriented Framework for Developing Distributed Applications, </title> <booktitle> in Proceedings of the 6 th USENIX C++ Technical Conference, </booktitle> <address> (Cambridge, Mas-sachusetts), </address> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: This article presents an object-oriented domain analysis of key design dimensions for network server daemons. Subsequent articles will describe a framework called the ADAPTIVE Service eXecutive (ASX) <ref> [4] </ref> that provides flexibility across the design dimensions identified in this article. <p> These five dimensions were identified by generalizing from practical design and implementation experience with a number of distributed applications ranging from on-line transaction processing systems [3], PBX switch performance monitoring systems [9], and multi-processor-based communication subsystems <ref> [4] </ref>. Each of the five dimensions discussed below offer a set of relatively orthogonal design alternatives. These alternatives are examined to define the vocabulary of the network daemon domain, illustrate key abstractions, and clarify the boundaries of the domain. <p> Some daemon control frameworks (such as inetd [5] and the ASX framework <ref> [4] </ref>) support both internal and external services. <p> These inter-connected services communicate by exchanging control and data messages. Several communication subsystem frameworks have been developed to simplify and automate the development and configuration of layered services <ref> [14, 15, 16, 4] </ref>. In general, these frameworks decouple the protocol and service functionality from (1) the time and/or order in which services are composed together and (2) the processing agent (s) (e.g., processes and/or threads) used to execute services at run-time. <p> For example, inetd is a concurrent multi-service daemon with respect to its external services, whereas it is an iterative, multi-service daemon with respect to its internal services. Other daemon control frameworks (such as the ASX framework <ref> [4] </ref>) offer more flexible support for concurrent execution of both internal and external services. * Eager vs. On-demand vs. Lazy Process/Thread Invocation: Several process- and thread-based invocation mechanisms help developers optimize concurrent daemon performance.
Reference: [5] <author> W. R. Stevens, </author> <title> UNIX Network Programming. </title> <address> Englewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1990. </year>
Reference-contexts: A daemon is an operating system (OS) process that executes services on a host machine in the background (i.e., disassociated from any controlling terminal) <ref> [5] </ref>. A service is a portion of a daemon that offers a single processing capability to communicating entities. <p> want to benefit from these advanced OS mechanisms must manually program them into their applications. 3 Network Daemon Design Dimensions The increased availability of advanced OS mechanisms (such as multi-threading and explicit dynamic linking), cou 1 A thorough discussion of these topics is beyond the scope of this paper; see <ref> [5] </ref> for additional details. 2 NETWORK DAEMON DESIGN DIMENSIONS MESSAGE PASSING VS. DISTRIBUTED SHARED MEMORY (2) COOPERATION AND COMMUNICATION DIMENSIONS RPC VS. LOWER-LEVEL IPC SINGLESERVICE VS. MULTI-SERVICE DAEMONS (3) DAEMON ARCHITECTURE DIMENSIONS ONESHOT VS. STANDING DAEMONS CONFIGURATION DIMENSIONS STATIC LINKING VS. IMPLICIT AND EXPLICIT DYNAMIC LINKING STATIC VS. <p> In the latter case, a master service dispatcher process may be used to monitor a set of communication ports, accept connection requests and receive data indications, and then spawn a new process to perform the requested service (s) externally. Some daemon control frameworks (such as inetd <ref> [5] </ref> and the ASX framework [4]) support both internal and external services. <p> One example of DEVICE DRIVER WQ WQ RQ IP MODULE TCP MODULE (1) LAYERED SERVICES (2) MONOLITHIC SERVICE DGRAM BROADCAST DGRAM RECV FILE I/O RWHOD APPLICATION INTERFACE 5 a monolithic service is the standard UNIX implementation of the rwho daemon <ref> [5] </ref>. As illustrated in Figure 5 (2), the datagram broadcast and receiver functions in an rwho daemon operate in relative isolation from each other to report and store user activities within hosts on a LAN subnet. <p> These daemon architectures are generally structured according to the following alternatives: * Single-Service vs. Multi-Service Daemons: Single-service daemons offer only one service. The rwho daemon (rwhod <ref> [5] </ref>) is an example of a single-service daemon. Early versions of UNIX ran standard network services (such as ftp and telnet) as distinct single-service daemons that were 6 SERVICE DISPATCHER PROCESS (1) ONESHOT DAEMONS (2) STANDING DAEMONS SERVICE DISPATCHER PROCESS NAMED PIPES initiated at OS boot-time [5]. <p> The rwho daemon (rwhod <ref> [5] </ref>) is an example of a single-service daemon. Early versions of UNIX ran standard network services (such as ftp and telnet) as distinct single-service daemons that were 6 SERVICE DISPATCHER PROCESS (1) ONESHOT DAEMONS (2) STANDING DAEMONS SERVICE DISPATCHER PROCESS NAMED PIPES initiated at OS boot-time [5]. Each instance of a service was executed externally in a separate process. As the number of system daemons increased, however, this statically configured, single-service per-process approach revealed several limitations that are addressed by multi-service daemons such as inetd and listen. <p> 2 Daemonization typically involves (1) dynamically spawning a new process, (2) closing all unnecessary file descriptors, (3) changing the current working directory to the root directory, (4) resetting the file access creation mask, (5) disassociating from the controlling process group and the controlling terminal, and (6) ignoring terminal I/O-related signals <ref> [5] </ref>. sumptive of system resources (such as memory and process table slots) since a one-shot daemon does not remain in system memory when it becomes idle. A standing daemon, on the other hand, continues to run beyond the lifetime of the service request (s) it performs.
Reference: [6] <author> F. P. Brooks, </author> <title> No Silver Bullet: </title> <journal> Essence and Accidents of Software Engineering, IEEE Computer, </journal> <volume> vol. 20, </volume> <pages> pp. 10-19, </pages> <month> Apr. </month> <year> 1987. </year>
Reference-contexts: Object-oriented design and implementation techniques offer a variety of principles, methods, and tools that may help to alleviate much of the complexity related to developing and configuring distributed applications, in particular accidental complexity <ref> [6] </ref>. Accidental complexity is an artifact of limitations with tools and techniques used to develop software systems within an application domain. One common example of accidental complexity is the lack of type-safe, portable, and extensible system call interfaces and reusable component libraries. Debuggers are another source of accidental complexity.
Reference: [7] <author> G. Booch, </author> <title> Object Oriented Analysis and Design with Ap plications (2 nd Edition). </title> <address> Redwood City, California: Ben-jamin/Cummings, </address> <year> 1993. </year>
Reference-contexts: A domain analysis is an incremental, feedback-driven process that examines an application domain to identify its key abstractions. Common application domains include window systems, databases, network server daemons, distributed applications, and operating system kernels. The key abstractions that are identified via analysis constitute the vocabulary of the application domain <ref> [7] </ref>. For example, tasks, threads, memory objects, and communication ports are several key abstractions in the domain of micro-kernel operating systems [8]. A thorough domain analysis yields several significant benefits.
Reference: [8] <author> M. Accetta, R. Baron, D. Golub, R. Rashid, A. Tevanian, and M. Young, </author> <title> Mach: A New Kernel Foundation for UNIX Development, </title> <booktitle> in Proceedings of the Summer 1986 USENIX Technical Conference and Exhibition, </booktitle> <month> June </month> <year> 1986. </year>
Reference-contexts: The key abstractions that are identified via analysis constitute the vocabulary of the application domain [7]. For example, tasks, threads, memory objects, and communication ports are several key abstractions in the domain of micro-kernel operating systems <ref> [8] </ref>. A thorough domain analysis yields several significant benefits. First, identifying and concisely defining the vocabulary of key abstractions within a domain enables developers to communicate more effectively with one another.
Reference: [9] <author> D. C. Schmidt and P. Stephenson, </author> <title> An Object-Oriented Framework for Developing Network Server Daemons, </title> <booktitle> in Proceed ings of the 2 nd C++ World Conference, </booktitle> <address> (Dallas, Texas), SIGS, </address> <month> Oct. </month> <year> 1993. </year>
Reference-contexts: These five dimensions were identified by generalizing from practical design and implementation experience with a number of distributed applications ranging from on-line transaction processing systems [3], PBX switch performance monitoring systems <ref> [9] </ref>, and multi-processor-based communication subsystems [4]. Each of the five dimensions discussed below offer a set of relatively orthogonal design alternatives. These alternatives are examined to define the vocabulary of the network daemon domain, illustrate key abstractions, and clarify the boundaries of the domain.
Reference: [10] <author> J. Postel and J. Reynolds, </author> <title> Telnet Protocol Specficiation, </title> <booktitle> Network Information Center RFC 854, </booktitle> <pages> pp. 1-45, </pages> <month> May </month> <year> 1983. </year>
Reference-contexts: Services are implemented by protocols that shield applications from many low-level details of the underlying communication subsystem. For instance, the telnet application provides a remote login service implemented via the telnet protocol. The telnet protocol <ref> [10] </ref> precisely defines the format of messages exchanged to indicate terminal characteristics, negotiate options, and control the flow of data for users that access resources on remote hosts connected via a TCP/IP network.
Reference: [11] <author> D. R. Cheriton, VMTP: </author> <title> Versatile Message Transaction Protocol Specification, </title> <booktitle> Network Information Center RFC 1045, </booktitle> <pages> pp. 1-123, </pages> <month> Feb. </month> <year> 1988. </year>
Reference-contexts: Request-response protocols may be implemented as a separate layer on top of connectionless or connection-oriented protocols. They also may be directly implemented via a reliable message-passing protocol such as VMTP <ref> [11] </ref>. * Short-Duration vs. Long-Duration Services: Services offered by network daemons may be classified loosely as short-duration or long-duration. Short-duration services execute in brief, typically fixed amounts of time.
Reference: [12] <author> A. L. Sabsevitz, </author> <title> Distributed UNIX System Remote File Sharing, </title> <booktitle> in UNIX System Software Readings, </booktitle> <pages> pp. 109-136, </pages> <institution> AT&T Unix Pacific Co. Ltd, </institution> <year> 1988. </year>
Reference-contexts: Stateless Services: A stateful service caches certain information (such as authentication keys, identification numbers, and file handles) in the daemon to reduce communication and computation overhead. For instance, the Remote File Sharing (RFS) file system <ref> [12] </ref> is a stateful service that allows the selective sharing of resources across a network. A stateless service, on the other hand, retains no volatile per-connection state information in a daemon.
Reference: [13] <author> R. Sandberg, </author> <title> The Sun Network Filesystem: Design, Implementation, and Experience, </title> <booktitle> in Proceedings of the Summer 1986 USENIX Technical Conference and Exhibition, </booktitle> <year> 1986. </year>
Reference-contexts: For instance, the Remote File Sharing (RFS) file system [12] is a stateful service that allows the selective sharing of resources across a network. A stateless service, on the other hand, retains no volatile per-connection state information in a daemon. For example, the Network File System (NFS) <ref> [13] </ref> provides distributed data storage and retrieval services that do not maintain volatile state information within a server daemon. These two approaches tradeoff efficiency and reliability, with a suitable choice depending on factors such as the probability and impact of host and network failures.
Reference: [14] <author> D. Ritchie, </author> <title> A Stream Input-Output System, </title> <journal> AT&T Bell Labs Technical Journal, </journal> <volume> vol. 63, </volume> <pages> pp. 311-324, </pages> <month> Oct. </month> <year> 1984. </year>
Reference-contexts: These inter-connected services communicate by exchanging control and data messages. Several communication subsystem frameworks have been developed to simplify and automate the development and configuration of layered services <ref> [14, 15, 16, 4] </ref>. In general, these frameworks decouple the protocol and service functionality from (1) the time and/or order in which services are composed together and (2) the processing agent (s) (e.g., processes and/or threads) used to execute services at run-time.
Reference: [15] <author> N. C. Hutchinson and L. L. Peterson, </author> <title> The x-kernel: An Architecture for Implementing Network Protocols, </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> vol. 17, </volume> <pages> pp. 64-76, </pages> <month> January </month> <year> 1991. </year>
Reference-contexts: These inter-connected services communicate by exchanging control and data messages. Several communication subsystem frameworks have been developed to simplify and automate the development and configuration of layered services <ref> [14, 15, 16, 4] </ref>. In general, these frameworks decouple the protocol and service functionality from (1) the time and/or order in which services are composed together and (2) the processing agent (s) (e.g., processes and/or threads) used to execute services at run-time. <p> The choice of process architecture affects key sources of application performance overhead (such as context switching, synchronization, scheduling, and data movements costs), as well as influencing demultiplexing strategies and protocol programming techniques <ref> [15] </ref>. An in-depth survey of alternative process architectures appears in [23]. 3.5 Configuration Dimensions A complete network server daemon is typically created by configuring together its constituent services at static link-time or during daemon execution.
Reference: [16] <author> J. M. Zweig, </author> <title> The Conduit: a Communication Abstraction in C++, </title> <booktitle> in Proceedings of the 2 nd USENIX C++ Conference, </booktitle> <pages> pp. 191-203, </pages> <publisher> USENIX Association, </publisher> <month> April </month> <year> 1990. </year>
Reference-contexts: These inter-connected services communicate by exchanging control and data messages. Several communication subsystem frameworks have been developed to simplify and automate the development and configuration of layered services <ref> [14, 15, 16, 4] </ref>. In general, these frameworks decouple the protocol and service functionality from (1) the time and/or order in which services are composed together and (2) the processing agent (s) (e.g., processes and/or threads) used to execute services at run-time.
Reference: [17] <author> J. Crowcroft, I. Wakeman, Z. Wang, and D. Sirovica, </author> <title> Is Layering Harmful?, </title> <journal> IEEE Network Magazine, </journal> <month> January </month> <year> 1992. </year>
Reference-contexts: A common criticism of layered implementations is that their modularity introduces too much overhead. For instance, layering may cause inefficiencies if buffer sizes are not matched appropriately in adjacent layers, thereby causing additional segmentation/reassembly and transmission delays <ref> [17] </ref>. 3.2 Cooperation and Communication Dimen sions Separate components in a stand-alone application generally cooperate within a single address space by passing parameters via function calls and/or accessing global variables.
Reference: [18] <author> J. Eykholt, S. Kleiman, S. Barton, R. Faulkner, A. Shivalin-giah, M. Smith, D. Stein, J. Voll, M. Weeks, and D. Williams, </author> <title> Beyond Multiprocessing... Multithreading the SunOS Kernel, </title> <booktitle> in Proceedings of the Summer USENIX Conference, </booktitle> <address> (San Antonio, Texas), </address> <month> June </month> <year> 1992. </year>
Reference-contexts: Unlike iterative daemons, concurrent daemons allow more fine-grained synchronization techniques that serialize requests at an application-defined level (such as record-level locking in a database). This requires concurrency control mechanisms (such as semaphores or mutex locks <ref> [18] </ref>) that ensure robust cooperation and sharing of data between simultaneously active processes and threads. Multi-threading mechanisms are rapidly becoming available on most OS platforms [18]. A thread is an independent series of instructions executed within a single process address space. <p> This requires concurrency control mechanisms (such as semaphores or mutex locks <ref> [18] </ref>) that ensure robust cooperation and sharing of data between simultaneously active processes and threads. Multi-threading mechanisms are rapidly becoming available on most OS platforms [18]. A thread is an independent series of instructions executed within a single process address space. This address space may be shared with other independently executing threads. <p> The OS handles all process and thread management activities required to schedule, suspend, and resume. Moreover, if multiple CPUs are available, daemon services may execute in parallel <ref> [18] </ref>. A concurrent daemon may also be designed to handle multiple requests simultaneously within a single-threaded process. For instance, the standard X server from the MIT X windows system operates as a single-threaded concurrent daemon. <p> Another limitation with single-threaded concurrent daemons is that their performance may be greatly reduced if an OS blocks all services in an entire process whenever one service makes a system call or incurs a page fault. Multi-threading mechanisms in many modern operating systems <ref> [18, 20] </ref> overcome these performance limitations by allowing preemptive, fully parallel execution of independent services running in separate threads. Both iterative and concurrent daemons may offer multiple services or simply a single service.
Reference: [19] <author> A. D. Birrell, </author> <title> An Introduction to Programming with Threads, </title> <type> Tech. Rep. </type> <institution> SRC-035, Digital Equipment Corporation, </institution> <month> January </month> <year> 1989. </year>
Reference-contexts: This address space may be shared with other independently executing threads. Threads are often characterized as lightweight processes since they maintain minimal state information, require less overhead to spawn and synchronize, and inter-communicate via shared memory rather than message passing <ref> [19] </ref>. Under certain circumstances, it is advantageous to implement concurrent daemons that perform multiple service requests in separate threads rather than separate processes. For example, cooperating services that frequently reference common memory-resident data structures are often simpler and more efficient to implement via threads.
Reference: [20] <author> H. Custer, </author> <title> Inside Windows NT. </title> <address> Redmond, Washington: </address> <publisher> Mi-crosoft Press, </publisher> <year> 1993. </year>
Reference-contexts: Another limitation with single-threaded concurrent daemons is that their performance may be greatly reduced if an OS blocks all services in an entire process whenever one service makes a system call or incurs a page fault. Multi-threading mechanisms in many modern operating systems <ref> [18, 20] </ref> overcome these performance limitations by allowing preemptive, fully parallel execution of independent services running in separate threads. Both iterative and concurrent daemons may offer multiple services or simply a single service. <p> This lazy evaluation technique minimizes link editing overhead during daemon initialization. Implicit dynamic linking is used to implement shared libraries [24], also known as dynamic-link libraries (DLLs) <ref> [20] </ref>. Ideally, only one copy of shared library code exists, regardless of the number of processes that are simultaneously executing the library's code.
Reference: [21] <author> D. E. Comer and D. L. Stevens, </author> <title> Internetworking with TCP/IP Vol III: Client Server Programming and Applications. </title> <address> En-glewood Cliffs, NJ: </address> <publisher> Prentice Hall, </publisher> <year> 1992. </year>
Reference-contexts: Instead, a timer is set and the request is handled iteratively by the daemon. If the timer expires a new slave process is automatically spawned to continue processing the service independently from the master service dispatcher process <ref> [21] </ref>. * Task-based vs. Message-based Process Architectures: A process architecture represents a binding between various units of application services processing (such as layers, functions, connections, and messages) and various structural configurations of logical and/or physical CPUs [22].
Reference: [22] <author> D. C. Schmidt, D. F. Box, and T. Suda, </author> <title> ADAPTIVE: A Dynamically Assembled Protocol Transformation, Integration, and eValuation Environment, </title> <journal> Journal of Concurrency: Practice and Experience, </journal> <volume> vol. 5, </volume> <pages> pp. 269-286, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: Message-based Process Architectures: A process architecture represents a binding between various units of application services processing (such as layers, functions, connections, and messages) and various structural configurations of logical and/or physical CPUs <ref> [22] </ref>. The process architecture is one of several factors (along with protocol, bus, memory, and network interface characteristics) that significantly impact network daemon performance.
Reference: [23] <author> D. C. Schmidt and T. Suda, </author> <title> Transport System Architecture Services for High-Performance Communications Systems, </title> <journal> IEEE Journal on Selected Areas in Communication, </journal> <volume> vol. 11, </volume> <pages> pp. 489-506, </pages> <month> May </month> <year> 1993. </year>
Reference-contexts: The choice of process architecture affects key sources of application performance overhead (such as context switching, synchronization, scheduling, and data movements costs), as well as influencing demultiplexing strategies and protocol programming techniques [15]. An in-depth survey of alternative process architectures appears in <ref> [23] </ref>. 3.5 Configuration Dimensions A complete network server daemon is typically created by configuring together its constituent services at static link-time or during daemon execution.
Reference: [24] <author> R. Gingell, M. Lee, X. Dang, and M. Weeks, </author> <title> Shared Libraries in SunOS, </title> <booktitle> in Proceedingsof the Summer 1987 USENIX Technical Conference, </booktitle> <address> (Phoenix, Arizona), </address> <year> 1987. </year>
Reference-contexts: This lazy evaluation technique minimizes link editing overhead during daemon initialization. Implicit dynamic linking is used to implement shared libraries <ref> [24] </ref>, also known as dynamic-link libraries (DLLs) [20]. Ideally, only one copy of shared library code exists, regardless of the number of processes that are simultaneously executing the library's code.
Reference: [25] <author> D. C. Schmidt and T. Suda, </author> <title> The Service Configurator Framework: An Extensible Architecture for Dynamically Configuring Concurrent, Multi-Service Network Daemons, </title> <booktitle> in Proceedings of the Second International Workshop on Configurable Distributed Systems, </booktitle> <address> (Pittsburgh, PA), </address> <pages> pp. 190-201, </pages> <publisher> IEEE, </publisher> <month> Mar. </month> <year> 1994. </year> <month> 11 </month>
Reference-contexts: Explicit dynamic linking mechanisms significantly enhance the functionality and flexibility of network daemons since they enable services to be inserted, deleted, or modified at run-time without first terminating and restarting the underlying process or thread (s) <ref> [25] </ref>. 4 Concluding Remarks Distributed computing is a promising technology for improving collaboration through connectivity and interworking; performance through multi-processing; reliability and availability through replication; scalability, extensibility, and portability through modularity; and cost effectiveness through re 10 source sharing and open systems.
References-found: 25

