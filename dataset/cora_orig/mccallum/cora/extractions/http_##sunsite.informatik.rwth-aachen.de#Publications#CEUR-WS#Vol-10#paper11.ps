URL: http://sunsite.informatik.rwth-aachen.de/Publications/CEUR-WS/Vol-10/paper11.ps
Refering-URL: http://www.cs.sunysb.edu/~juliana/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: juliana@research.bell-labs.com  
Title: Practical Problems in Coupling Deductive Engines with Relational Databases  
Note: Bell Labs  
Abstract: Abstract There has been a considerable demand for applications that extend the capabilities of databases, such as data warehouses, decision support systems and knowledge discovery, to name a few. Unfortunately, adding new functionality by coupling separate components with commercial relational databases is usually a non-trivial task. One of the main reasons is the fact that the application programming interfaces of commercial relational databases do not provide adequate mechanisms that support efficient communication between client applications and the database servers. In this paper we illustrate this problem by focusing on the more specific issue of coupling deductive database query engines and relational databases.
Abstract-found: 1
Intro-found: 1
Reference: [BR91] <author> C. Beeri and R. Ramakrishnan. </author> <title> On the Power of Magic. </title> <journal> Journal of Logic Programming, </journal> <volume> 10(3) </volume> <pages> 255-299, </pages> <year> 1991. </year>
Reference-contexts: Deductive databases [Min88] address this problem by adopting logic programming [Llo84] or a restriction such as Datalog [Ull89] as the query language. The problem of evaluating Datalog queries has been extensively studied. Two approaches have gained special attention: (1) magic sets <ref> [BR91] </ref>, which adds goal directedness to bottom-up evaluation, and (2) tabling (or memoization) [CW96], which adds features of database evaluation to logic programming languages. These two approaches resemble each other in that they combine top-down goal orientation with bottom-up redundancy checking.
Reference: [CDF + 86] <author> M. Carey, D. DeWitt, D. Frank, G. Graefe, M. Muralikrishna, J.E. Richardson, and E.J. Shikita. </author> <title> Architecture of the EXODUS extensible DBMS. </title> <booktitle> In Proceedings of the International Workshop on Object-Oriented Database Systems, </booktitle> <pages> pages 52-65, </pages> <year> 1986. </year>
Reference-contexts: In practice however, given the available application programming interfaces (APIs), an efficient and portable interface between a DDB engine and a commercial RDBMS is very hard (and I wonder if possible) to build. There has been considerable progress on extensible databases [CH90]. Starburst [HCL + 90] and Exodus <ref> [CDF + 86] </ref> are good examples of research prototypes that attempted to make it easier to customize database systems to suit user's special needs.
Reference: [CDS97] <author> M. Codish, B. Demoen, and K. Sago-nas. </author> <title> XSB as the natural habitat for general purpose program analysis. </title> <booktitle> In Proceedings of the International Conference on Logic Programming (ICLP), </booktitle> <pages> page 416. </pages> <publisher> MIT Press, </publisher> <year> 1997. </year>
Reference-contexts: XSB, for instance, has been used for semantic integration of information systems [PAE98], 1 A mismatch between the data manipulation language and the host programming language. 2 For comprehensive survey see [RU95]. program analysis <ref> [CDS97] </ref>, model checking [RRR + 97], and natural language analysis [LWFS96], to name a few.
Reference: [CGK + 90] <author> D. Chimenti, R. Gamboa, R. Krishna-murthy, S. Naqvi, S. Tsur, and C. Zan-iolo. </author> <title> The LDL system prototype. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 76-90, </pages> <year> 1990. </year>
Reference-contexts: In practice, tabling systems were shown to be an order of magnitude faster than magic-style systems for in memory queries [SSW94], and at least as efficient for queries involving external data [FSW97]. A number of research prototypes such as, LDL <ref> [CGK + 90] </ref>, CORAL [RSS92], Aditi [VRK + 94], XSB [SSW94], are available. 2 These prototypes have been used in various applications [Ram95] and in different domains.
Reference: [CGT90] <author> S. Ceri, G. Gotlob, and L. Tanca. </author> <title> Logic Programming and Databases. </title> <publisher> Springer-Verlag, </publisher> <year> 1990. </year>
Reference-contexts: that the superfluous temporary relation get supplier id is eliminated, a single query with a triple join will suffice. get supplier name (Partid,Sname) :- db order ( ,Part, ), db supplies (Sid,Part), db supplier (Sid,Sname). 2 This and other high-level compile-time optimizations have been well-studied in the literature (see e.g., <ref> [CGT90] </ref>), and they do indeed improve the performance of query evaluation. However, in an implementation, another important issue that is not captured in these optimizations should be taken into account: the actual communication mechanisms | how tuples are sent back and forth between a DDB and an RDBMS.
Reference: [CH90] <author> M. Carey and L. Haas. </author> <title> Extensible database management systems. </title> <booktitle> SIGMOD Record, </booktitle> <volume> 19(4) </volume> <pages> 54-60, </pages> <year> 1990. </year>
Reference-contexts: In practice however, given the available application programming interfaces (APIs), an efficient and portable interface between a DDB engine and a commercial RDBMS is very hard (and I wonder if possible) to build. There has been considerable progress on extensible databases <ref> [CH90] </ref>. Starburst [HCL + 90] and Exodus [CDF + 86] are good examples of research prototypes that attempted to make it easier to customize database systems to suit user's special needs.
Reference: [Cha96] <author> D. Chamberlin. </author> <title> Using the New DB2. </title> <publisher> Mor-gan Kaufmann, </publisher> <year> 1996. </year>
Reference-contexts: Besides there is a great variation on how recursive queries are supported by different RDBMSs. For example, whereas DB2 can evaluate complex forms of recursion <ref> [Cha96] </ref>, Oracle only supports hierarchical queries [KL95]. At the same time, a number of research prototypes that use state of the art DDB techniques have been built, and theoretically, these could be coupled with existing RDBMSs to provide the latter with a full range of deductive capabilities. <p> But that is not always the case. No support for transparent caching was provided in Oracle 7, and Oracle 8 supports allows caching through its (non-standard) OCI call-level interface [Loc97] but not through embedded SQL [Mel97], which is also the case for DB2 v2 <ref> [Cha96] </ref> Another alternative provided by some databases to reduce the communication costs is through an array interface. In Oracle, for instance, by explicitly defining arrays (one for each column to be retrieved), the client application can control to a certain extent how many tuples are fetched at a time. <p> By selectively "tabling" certain views, XSB can avoid redundant computation and the infinite looping of Prolog for programs such as the left-recursive transitive closure of Example 3.2. would seem to be a natural choice, but neither DB2 nor Oracle allow arrays to be used as arguments for the IN predicate <ref> [Mel97, Cha96] </ref>. 5 A more general and scalable solution is to create a temporary table in the database, populate it with the relevant tuples from the path relation, and then perform the join with the edge table. The latter solution was implemented in the XSB system.
Reference: [CW96] <author> W. Chen and D.S. Warren. </author> <title> Tabled Evaluation with Delaying for General Logic Programs. </title> <journal> JACM, </journal> <volume> 43(1) </volume> <pages> 20-74, </pages> <month> January </month> <year> 1996. </year>
Reference-contexts: The problem of evaluating Datalog queries has been extensively studied. Two approaches have gained special attention: (1) magic sets [BR91], which adds goal directedness to bottom-up evaluation, and (2) tabling (or memoization) <ref> [CW96] </ref>, which adds features of database evaluation to logic programming languages. These two approaches resemble each other in that they combine top-down goal orientation with bottom-up redundancy checking. In fact, under certain assumptions they have been proved to be asymptotically equivalent [Sek89].
Reference: [FMMP96] <author> S.J. Finkelstein, N. Mattos, I. Mumick, and H Pirahesh. </author> <title> Expressing recursive queries in sql. </title> <type> Technical Report X3H2-96-075r1, </type> <institution> ISO/IEC JTC1/SC21 WG3 DBL MCI, </institution> <year> 1996. </year>
Reference-contexts: Recent improvements in some commercial RDBMS APIs indicate that vendors are starting to recognize the need for efficient communication mechanisms between client applications and database servers. Efforts towards designing more portable interfaces are also underway <ref> [Mel95, FMMP96, Gei95] </ref>, but adoption of such standards remain a rather slow process.
Reference: [FSW97] <author> J. Freire, T. Swift, and D.S. Warren. </author> <title> Taking I/O seriously: Resolution reconsidered for disk. </title> <booktitle> In Proceedings of the International Conference on Logic Programming (ICLP), </booktitle> <pages> pages 198-212, </pages> <year> 1997. </year>
Reference-contexts: In fact, under certain assumptions they have been proved to be asymptotically equivalent [Sek89]. In practice, tabling systems were shown to be an order of magnitude faster than magic-style systems for in memory queries [SSW94], and at least as efficient for queries involving external data <ref> [FSW97] </ref>. A number of research prototypes such as, LDL [CGK + 90], CORAL [RSS92], Aditi [VRK + 94], XSB [SSW94], are available. 2 These prototypes have been used in various applications [Ram95] and in different domains. <p> Let us examine how this query is evaluated in the XSB system. 4 XSB uses a top-down breadth-first search strategy to evaluate recursive queries that involve external data in a set-at-a-time fashion (which is equivalent to the semi-naive evaluation of a magic-transformed query <ref> [FSW97] </ref>). The query :- path (1,X) is first resolved against the non-recursive rule, which finds the nodes directly connected to node 1 (nodes 2 and 3) by selecting the desired tuples from the base table.
Reference: [Gei95] <author> K. Geiger. </author> <title> Inside ODBC. </title> <publisher> Microsoft Press, </publisher> <year> 1995. </year>
Reference-contexts: Below, we discuss if and how these requirements can be realized through current RDBMS APIs. Sending/fetching tuples The issue sending/fetching multiple tuples at a time is partially addressed through the array interfaces provided by some RDBMSs, such as Oracle's host arrays [Mel97], and the SQLExtendedFetch facility of ODBC <ref> [Gei95] </ref>. The host arrays supported by Oracle allow client applications to explicitly control how many values are sent/fetched from the database server. We have shown in Figure 1 (b) that host arrays can significantly reduce communication overheads. <p> Recent improvements in some commercial RDBMS APIs indicate that vendors are starting to recognize the need for efficient communication mechanisms between client applications and database servers. Efforts towards designing more portable interfaces are also underway <ref> [Mel95, FMMP96, Gei95] </ref>, but adoption of such standards remain a rather slow process.
Reference: [HCL + 90] <author> L.M. Haas, W. Chang, G.M. Lohman, J. McPherson, P.F. Wilms, G. Lapis, B. Lindsay, H. Pirahesh, M. Carey, , and E. Shekita. </author> <title> Starburst mid-flight: As the dust clears. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 2(1) </volume> <pages> 143-160, </pages> <year> 1990. </year>
Reference-contexts: In practice however, given the available application programming interfaces (APIs), an efficient and portable interface between a DDB engine and a commercial RDBMS is very hard (and I wonder if possible) to build. There has been considerable progress on extensible databases [CH90]. Starburst <ref> [HCL + 90] </ref> and Exodus [CDF + 86] are good examples of research prototypes that attempted to make it easier to customize database systems to suit user's special needs.
Reference: [KL95] <author> G. Koch and K. Loney. </author> <title> Oracle The Complete Reference. </title> <publisher> Oracle Press, </publisher> <year> 1995. </year>
Reference-contexts: Besides there is a great variation on how recursive queries are supported by different RDBMSs. For example, whereas DB2 can evaluate complex forms of recursion [Cha96], Oracle only supports hierarchical queries <ref> [KL95] </ref>. At the same time, a number of research prototypes that use state of the art DDB techniques have been built, and theoretically, these could be coupled with existing RDBMSs to provide the latter with a full range of deductive capabilities.
Reference: [Knu93] <author> D. E. Knuth. </author> <title> The Stanford GraphBase: </title>
Reference-contexts: on the number of bytes an array can store which can not be set by the client application. 5 One could also generate a string with all values, but clearly this is not a scalable solution. 6 The graphs used for this experiment were generated with Knuth's Stanford Graph Base <ref> [Knu93] </ref>. J.
References-found: 14

