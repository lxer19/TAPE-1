URL: http://www.win.tue.nl/~hooman/DEALtech.ps
Refering-URL: http://www.win.tue.nl/~hooman/DEALtech.html
Root-URL: http://www.win.tue.nl
Email: e-mail: wsinjh@win.tue.nl and wsinonno@win.tue.nl  
Title: A Programming-Language Extension for Distributed Real-Time Systems  
Author: Jozef Hooman and Onno van Roosmalen 
Date: December 4, 1996  
Address: P.O. Box 513, 5600 MB Eindhoven, The Netherlands  
Affiliation: Dept. of Computing Science, Eindhoven University of Technology  
Abstract: In this paper we propose a method for extending programming languages that enables the specification of timing properties of systems. The way time is treated is not language specific and the extension can therefore be included in many existing programming languages. The presented method includes a view on the system development process. An essential feature is that it enables the construction of (hard) real-time programs that may be proven correct independently of the properties of the machines that are used for their execution. It therefore provides a similar abstraction from the execution platform as is normal for non-real-time languages. The aim of this paper is to illustrate the method and demonstrate its applicability to actual real-time problems. To this end we define a simple programming language that includes the timing extension. We present a formal semantics for a characteristic part of the language constructs and apply formal methods to prove the correctness of a small example program. We consider in detail a larger example, namely the mine-pump problem known from the literature. We construct a real-time program for this problem and describe various ways to map the program to an implementation for different platforms. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <institution> "Ada 95 Reference Manual", International Standard ANSI/ISO/IEC-8652:1995, </institution> <month> January </month> <year> 1995. </year>
Reference-contexts: RT-Euclid is also a notable language. We will confine our comparison to these latter two languages and a couple of recent proposals that were not considered in the mentioned surveys. In the next couple of subsections we briefly describe the features with regard to timing of Ada <ref> [1, 4] </ref>, RT-Euclid [16], and the object oriented languages DROL [23], RTC++ [15], FLEX [20] and Sina (with real-time extensions) [3, 5]. <p> Presently DoD contractors are required to use Ada. It has become an international (ISO and ANSI) standard and is widely used for the implementation of real-time software. Numerous changes have been incorporated in the language's current version Ada 95 <ref> [1] </ref>. The language supports modular concurrent programming through constructs like subprograms, packages and tasks. Packages and subprograms constitute reusable components with well defined interfaces. Concurrency is provided by tasks. Various synchronization and communication primitives are offered, like rendezvous, semaphores and shared variables.
Reference: [2] <author> M. Aksit, </author> <title> "On the design of the object-oriented language Sina", </title> <type> Ph.D. Thesis, </type> <institution> University of Twente, Enschede, </institution> <address> The Netherlands, </address> <year> 1989. </year>
Reference-contexts: The block label is not sufficient to distinguish between such instances and constraints may be ambiguous. 14.6 Sina Sina <ref> [2] </ref> is an object oriented, concurrent programming language, suitable for distribution. Object are essentially abstract data types that hide implementation. With the use of so called composition filters typical object oriented mechanisms like inheritance and delegation are realized. Sina offers both inter- as well as intra-object concurrency.
Reference: [3] <author> M. Aksit, J. Bosch, W. v.d. Sterren and L. Bergmans, </author> <title> "Real-Time Specification Inheritance Anomalies and Real-Time Filters", </title> <booktitle> Proc. of the ECOOP '94 Conference, </booktitle> <publisher> LNCS 821, Springer Verlag, </publisher> <pages> pp 386-407, </pages> <year> 1994. </year>
Reference-contexts: In the next couple of subsections we briefly describe the features with regard to timing of Ada [1, 4], RT-Euclid [16], and the object oriented languages DROL [23], RTC++ [15], FLEX [20] and Sina (with real-time extensions) <ref> [3, 5] </ref>. After that we discuss the major differences with our approach. 14 COMPARISON WITH OTHER APPROACHES 38 14.1 ADA The Ada language [4] was developed to supply the US Department of Defense with a programming language for embedded applications. Presently DoD contractors are required to use Ada. <p> Sina offers both inter- as well as intra-object concurrency. Inter-object messages are either directly handled or queued in a, conceptually infinite, message queue of the receiving object. The order and way in which messages are handled is expressed in the filter construct. Real-time filters for Sina are introduced in <ref> [3, 5] </ref>, they are used to express timing constraints on invocation (message) acceptance and completion. Filters incorporate the following features for timing purposes. * Timing constraints can be attached to messages. <p> They also claim that some inheritance anomalies exist with regard to timing specification that are resolved using real-time filters <ref> [3, 5] </ref>. The real-time anomalies result in a reduced reusability of code of classes under inheritance.
Reference: [4] <author> G. Booch, </author> <title> "Software Engineering with Ada", </title> <publisher> Benjamin Cummings Publishing Company, </publisher> <address> Menlo Park CA, </address> <year> 1983. </year>
Reference-contexts: RT-Euclid is also a notable language. We will confine our comparison to these latter two languages and a couple of recent proposals that were not considered in the mentioned surveys. In the next couple of subsections we briefly describe the features with regard to timing of Ada <ref> [1, 4] </ref>, RT-Euclid [16], and the object oriented languages DROL [23], RTC++ [15], FLEX [20] and Sina (with real-time extensions) [3, 5]. <p> After that we discuss the major differences with our approach. 14 COMPARISON WITH OTHER APPROACHES 38 14.1 ADA The Ada language <ref> [4] </ref> was developed to supply the US Department of Defense with a programming language for embedded applications. Presently DoD contractors are required to use Ada. It has become an international (ISO and ANSI) standard and is widely used for the implementation of real-time software.
Reference: [5] <author> L. Bergmans and M. Aksit, </author> <title> "Composing Synchronization and Real-Time Constraints", </title> <publisher> ftp://ftp.cs.utwente.nl/pub/doc/TRESE. </publisher>
Reference-contexts: For instance skip <ref> [ &lt; 5; &gt; 5 ] </ref> has an unsatisfiable constraint.) Thus, we have three types of statements in the annotation: (1) timing assignments, that enable the manipulation of timing variables (2) time measurements which can be used to record the execution moment of the annotated program statement, (3) timing requirements, which <p> In the next couple of subsections we briefly describe the features with regard to timing of Ada [1, 4], RT-Euclid [16], and the object oriented languages DROL [23], RTC++ [15], FLEX [20] and Sina (with real-time extensions) <ref> [3, 5] </ref>. After that we discuss the major differences with our approach. 14 COMPARISON WITH OTHER APPROACHES 38 14.1 ADA The Ada language [4] was developed to supply the US Department of Defense with a programming language for embedded applications. Presently DoD contractors are required to use Ada. <p> Sina offers both inter- as well as intra-object concurrency. Inter-object messages are either directly handled or queued in a, conceptually infinite, message queue of the receiving object. The order and way in which messages are handled is expressed in the filter construct. Real-time filters for Sina are introduced in <ref> [3, 5] </ref>, they are used to express timing constraints on invocation (message) acceptance and completion. Filters incorporate the following features for timing purposes. * Timing constraints can be attached to messages. <p> They also claim that some inheritance anomalies exist with regard to timing specification that are resolved using real-time filters <ref> [3, 5] </ref>. The real-time anomalies result in a reduced reusability of code of classes under inheritance.
Reference: [6] <author> A. Burns and A.M. Lister, </author> <title> "A Framework for Building Dependable Systems", </title> <journal> The Computer Journal, </journal> <volume> Vol. 34, No. 2, </volume> <pages> pp 173-181, </pages> <year> 1991. </year>
Reference-contexts: We will use the insights that were obtained in this section also for constructing the solution to this larger problem but we will omit formal proves from now on. 6 Informal specification minepump We apply our full approach to the mine pump system as described by <ref> [6] </ref>. In this section we describe this system and give an accurate but informal specification. The mine-pump system is intended for regulating the ground-water level in a mine through the programmed control of a water pump. <p> Also other gases in the mine are monitored by the system and an operator is provided with information on the conditions in the mine and is given limited control over the pump. In this paper we will not consider the complete system as described in <ref> [6] </ref> but only the part that is concerned with the pump control. In particular we will omit the interaction with the operator and the monitoring of gases other than methane since they have no impact on the pump operation. <p> It may be assumed that dlh &gt;> hl and dlh &gt;> dh. (Comment: we will take into account that high signals may be given without low signals in between, because the pump may be switched off at any time. Values suggested by <ref> [6] </ref>: dl = dh = 10sec, dlh = 100sec.) 5. Consequence of device implementation choice and safety requirement: In the mine methane may be present. <p> The methane level increases or decreases with a maximum rate. Therefore some response time remains when the methane level is still sub-critical by a certain amount. This response time is called dc. The device must be polled by the control system. (Comment: values suggested by <ref> [6] </ref>: dc = 30msec.) 7. Requirement on the pump control: If the methane level is above the previously mentioned sub-critical value in [t1; t2] then the pump should be off in [t1 + dc; t2] no matter what the water level is. <p> The pump should remain in off position forever. It must be ensured that: if pump faulty and on in [t1; t1 + df ] then pump off in [t1 + df; inf). (Comment: value suggested by <ref> [6] </ref>: df = 100msec.) Since fault tolerance is not an issue in this paper we will assume that the platform has no failures. 7 Interaction with the environment The way the control system interacts with the environment that it controls, in particular the programmer's view of such interaction, is an important
Reference: [7] <author> A. Burns and A. Wellings, </author> <title> "Advanced Fixed Priority Scheduling", in "Real-time Systems; Specification, Verification and Analysis" edited by M. </title> <booktitle> Joseph, </booktitle> <pages> pp 32-96, </pages> <publisher> Prentice Hall, </publisher> <address> London, </address> <year> 1996. </year>
Reference-contexts: + 13u + x fl lcd (r m ; r c ; r w ) Again, the bound on u follows from equations (1) and (4), u 30=47ms, and for these values the schedule is feasible. 12 On-line preemptive priority scheduling In this case we employ a model similar to <ref> [7] </ref> in which processes are given an attribute periodic or sporadic and shared objects are present on which transactions are carried out. <p> Since our programming model is simpler and does not contain the concept of objects we will introduce in addition to periodic and sporadic processes a third process class, shared, that has a very similar role as the shared objects in <ref> [7] </ref>. The execution of processes in this model goes as follows. Periodic processes are each given a period. This period must be inferred from timing requirements. <p> To analyze schedulability, the following recursion relation can be derived for the relevant response times along the lines of <ref> [7] </ref> (taking into account that P pump is effectively the only shared process): R n+1 X i j2lp (i) C pump;j : Here, the process-label i only runs over the periodic and sporadic processes: i 2 fmethane; check; waterg and the sets hp (i) and lp (i) are the processes with <p> It appears that Ada does not provide means for explicitly specifying deadlines. Only release-times can be expressed using the delay statement. Process priorities are offered, but are indirect means for realizing deadlines. They are in some situations sufficient to give timeliness guarantees <ref> [7] </ref>, but the timeliness requirements have to be recorded and maintained separately from the program. We have already mentioned the context dependence and the resulting reduced reusability of program components with hard-coded priorities. <p> This resulted in a high number of primitives. Therefore, a formal definition of the language would be exceedingly difficult to generate and probably useless in any practical application. The reader may be interested to compare the minepump problem as implemented in Ada 95 <ref> [7] </ref> with the solution presented in this paper. We observe the following features of this implementation that contrast with our version. * Strictly periodic release-times for the periodic processes are specified in the Ada 95 program.
Reference: [8] <author> A. Burns and A. Wellings, </author> <title> "Real-Time Systems and their Programming Languages", </title> <publisher> Addison-Wesley, </publisher> <year> 1989. </year>
Reference-contexts: This was true in the on-line as well as off-line scheduling case that we presented. 14 Comparison with other approaches There are a number of survey papers on languages that can be applied to development of real-time systems <ref> [8, 11, 12] </ref>. From these studies Ada appears as the better languages for real-time programming. RT-Euclid is also a notable language. We will confine our comparison to these latter two languages and a couple of recent proposals that were not considered in the mentioned surveys.
Reference: [9] <author> E.W. Dijkstra, </author> <title> "Notes on Structured Programming", Structured Programming , A.P.I.C. </title> <booktitle> Studies in Data Processing No. </booktitle> <volume> 8, </volume> <pages> pp 1-81, </pages> <publisher> Academic Press, </publisher> <address> New York, </address> <year> 1972. </year>
Reference-contexts: A well-defined semantics is needed in then present context to be able to demonstrate that correctness of real-time programs can be established independent of the execution platform. 2 Composability and reusability of real-time programs It is generally recognized that problem decomposition and stepwise refinement <ref> [25, 9] </ref> are important programming strategies. When only functional aspects of programs are considered, there are no major problems in applying these strategies: the functional behavior of a component can be made to depend strictly on the explicitly declared interfaces offered by others.
Reference: [10] <author> V.D. Gligor and G.L. Luckenbaugh, </author> <title> "An Assessment of the Real-time Requirements for Programming Environments and Languages", </title> <booktitle> Proceedings of the 1983 Real-Time Systems Symposium, </booktitle> <publisher> IEEE Computer Society Press, </publisher> <pages> pp 3-19, </pages> <year> 1983. </year>
Reference-contexts: After that we will discuss our approach and compare it with various other proposals for including timing constraints in programming languages (section 13 to 14). 4 A simple parallel programming language Gligor and Luckenbaugh <ref> [10] </ref> have published general requirements that should be met by methods for the construction of real-time systems. They divided these requirements into four groups, two of which are of particular interest to real-time and two are more general: 1. Control requirements 2. Timing requirements 3. <p> A real-time programming language should deal with all 4 A SIMPLE PARALLEL PROGRAMMING LANGUAGE 5 timing aspects in a syntactically uniform and concise manner. This latter requirement falls in category (4), for which <ref> [10] </ref> describes the following requirements: * The number of language primitives should be kept small. * The primitives should be orthogonal (i.e., two or more primitives should not duplicate func tionality). * The principle of "separation of concerns" should be followed in designing the language primitives (e.g. , avoid primitives like <p> In the off-line scheduling approach such blocking can be avoided. 13 Discussion 13.1 Satisfying "good programming" requirements In chapter 4 we have listed the "good programming" requirements that have to be satisfied by programming languages as published by Gligor and Luckenbaugh <ref> [10] </ref>. We will now discuss some of the typical features of our approach in the light of these requirements. The language extension we have proposed includes only a small number of new primitives which provide expressiveness through the numerous ways they can be combined. <p> This separation of timing and synchronization primitives is an intentional language design choice inspired by the orthogonality and "separation of concerns" requirements of <ref> [10] </ref>. 1. Orthogonality: concurrent programming languages already contain primitives for synchro nization. Duplication of functionality should be avoided. 2. Separation of concerns: synchronization and timing are treated as completely separate issues (synchronization must also be offered in languages without timing constraints). Primitives should not combine such independent aspects. <p> It is a system implementation issue. In this paper we have demonstrated that the timing primitives can be formally defined and have a simple semantics, two other important requirements mentioned by <ref> [10] </ref>. More importantly, we have demonstrated how these formal definitions can be employed to prove correctness of programs. 13.2 Abstraction and refinement Another requirement on approaches to real-time programming that we mentioned in sections 2 and 3, is support for abstraction and refinement of timing behavior.
Reference: [11] <author> W.A. Halang and A.D. Stoyenko, </author> <title> "Comparative Evaluation of High-Level Real-Time Programming Languages", </title> <journal> International Journal of Time-Critical Computing Systems, </journal> <volume> Vol. 2, No 4, </volume> <pages> pp 365-382, </pages> <year> 1990. </year>
Reference-contexts: This was true in the on-line as well as off-line scheduling case that we presented. 14 Comparison with other approaches There are a number of survey papers on languages that can be applied to development of real-time systems <ref> [8, 11, 12] </ref>. From these studies Ada appears as the better languages for real-time programming. RT-Euclid is also a notable language. We will confine our comparison to these latter two languages and a couple of recent proposals that were not considered in the mentioned surveys.
Reference: [12] <author> W.A. Halang and A.D. Stoyenko, </author> <title> "Constructing Predictable Real-Time Systems", </title> <publisher> Kluwer Academic Publishers, </publisher> <address> Dordrecht-Hingham, </address> <year> 1991. </year>
Reference-contexts: This was true in the on-line as well as off-line scheduling case that we presented. 14 Comparison with other approaches There are a number of survey papers on languages that can be applied to development of real-time systems <ref> [8, 11, 12] </ref>. From these studies Ada appears as the better languages for real-time programming. RT-Euclid is also a notable language. We will confine our comparison to these latter two languages and a couple of recent proposals that were not considered in the mentioned surveys.
Reference: [13] <author> D.K. Hammer et al., "Dedos: </author> <title> A Distributed Real-Time Environment", Parallel & Distributed Technology, </title> <publisher> IEEE Computer Society, </publisher> <month> Winter </month> <year> 1994. </year>
Reference-contexts: The real-time programming approach presented in this paper has first been introduced in the object-oriented programming language Deal that was developed in the context of the Dependable Distributed Operating System (Dedos) project at Eindhoven University <ref> [13] </ref>. In the present paper we do not use Deal. Instead we introduce a simple concurrent language that is augmented with timing constructs.
Reference: [14] <author> J. Hooman, </author> <title> "Extending Hoare Logic to Real-Time", </title> <journal> Formal Aspects of Computing, </journal> <volume> 6A: </volume> <pages> 801-825, </pages> <year> 1994. </year>
Reference-contexts: We present a formal, axiomatic, semantics of (part of) the language by formulating proof system which express when a program satisfies a certain specification. First the specifications are introduced, using an extended and modified version of Hoare triples (program, precondition, post-condition), similar to <ref> [14] </ref>. Next the proof system is given by formulation a set of compositional rules and axioms. Compositionality implies that one can reason with the specifications of components without knowing their program text. Program verification is illustrated by a small example of a water level control program. <p> at t 2 ^ ((9t : read (d 1 ; 0) at t ^ term)_ (8t : :read (d 1 ; 0) at t ^ :term))ii. 5 FORMAL VERIFICATION OF TIME-ANNOTATED PROGRAMS 10 5.2 Proof system We briefly present the rules and axioms for our programming language and refer to <ref> [14] </ref> for more explanation. First in section 5.2.1 we axiomatize the programming language by giving rules and axioms for the primitive statements and the compound programming constructs. Next we give in section 5.2.2 rules and axioms that are generally applicable to any statement. <p> We only list the rules pertaining to the particulars of our real-time language, and refer to <ref> [14] </ref> for other rules. The first axiom expresses that a terminating program takes only a finite amount of time.
Reference: [15] <author> Y. Ishikawa, H. Tokuda, and C.W. Mercer, </author> <title> "Object-Oriented Real-Time Language Design: Constructs for Timing Constraints", </title> <institution> Carnegie Mellon, </institution> <year> 1990. </year>
Reference-contexts: In the next couple of subsections we briefly describe the features with regard to timing of Ada [1, 4], RT-Euclid [16], and the object oriented languages DROL [23], RTC++ <ref> [15] </ref>, FLEX [20] and Sina (with real-time extensions) [3, 5]. After that we discuss the major differences with our approach. 14 COMPARISON WITH OTHER APPROACHES 38 14.1 ADA The Ada language [4] was developed to supply the US Department of Defense with a programming language for embedded applications. <p> It is flexible with regard to synchronization and exception handling. However, the "best effort" approach can not result in guarantees on timing behavior. Composability and abstraction of timing behavior of DRObjects is not explicitly addressed. 14 COMPARISON WITH OTHER APPROACHES 41 14.4 RTC++ RTC++ <ref> [15] </ref> is also implemented on the ARTS kernel. The ARTS/RTC++ platform is an environment for the development of distributed object oriented real-time systems. It differs form the DROL language in that it focuses almost exclusively on the issues that are directly addressed by the kernel.
Reference: [16] <author> E. Kligerman and A.D. Stoyenko, </author> <title> "Real-Time Euclid: A Language for Reliable Real-Time Systems", </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> Vol. SE-12, No. 9, </volume> <year> 1986 </year>
Reference-contexts: We will confine our comparison to these latter two languages and a couple of recent proposals that were not considered in the mentioned surveys. In the next couple of subsections we briefly describe the features with regard to timing of Ada [1, 4], RT-Euclid <ref> [16] </ref>, and the object oriented languages DROL [23], RTC++ [15], FLEX [20] and Sina (with real-time extensions) [3, 5]. <p> It is interesting to note that timing parameters (as regular parameters of procedures) are used in the Ada program and the previously mentioned event abstraction is employed to a certain extent. 14.2 Real-Time Euclid Real-time Euclid <ref> [16] </ref> is a language derived from Pascal. It supports modularity and concurrency, but it does not support distribution. The authors address through their work on RT-Euclid issues on real-time and reliability and they do this in a very straightforward and coherent manner.
Reference: [17] <author> T. Kunz, </author> <title> "Event Abstraction: Some Definitions and Theorems". </title> <type> Technical Report TI-1/93, </type> <institution> Technische Hochschule Darmstadt, Fachbereich Informatik, Darmstadt, Germany, </institution> <month> February </month> <year> 1993, </year> <note> ftp://ftp.th-darmstadt.de/pub/docs/tech-reports/fb20/iti/at/THD-AT-1993-01.ps.Z REFERENCES 46 </note>
Reference-contexts: Our approach supports event abstraction. Event abstraction is extensively discussed in the context of distributed systems, particularly in distributed debugging. Many publications are available on the subject. For an interesting overview and references see <ref> [17] </ref>. With our present approach we have attempted to make an explicit connection between this field and real-time programming.
Reference: [18] <author> L. Lamport, </author> <title> "Time, Clocks, and the Ordering of Events in a Distributed System", </title> <journal> Communications of the ACM, </journal> <volume> Vol. 21, No 7, pp203-217, </volume> <year> 1978. </year>
Reference-contexts: For an interesting overview and references see [17]. With our present approach we have attempted to make an explicit connection between this field and real-time programming. However, in contrast with most work on timed events in distributed systems, where only logical time stamps are considered <ref> [18] </ref> that indicate the order of events, we attach real-time values to, possibly abstract, events. We will henceforth speak of timed-event abstraction. Although it is already present in our language, the scope and power of this form of abstraction becomes more manifest when procedures are introduced in our simple language.
Reference: [19] <author> I. Lee and V. Gehlot, </author> <title> "Language Constructs for Distributed Real-Time Programming", </title> <booktitle> Proceedings of the 1985 Real-Time Systems Symposium, </booktitle> <pages> pp 57-66, </pages> <publisher> IEEE Computer Society Press, </publisher> <year> 1985. </year>
Reference: [20] <author> K. Lin, J.W.S. Liu, K.B. Kenny and S. Natarajan, </author> <title> "FLEX: A Language for Programming Flexible Real-Time Systems", </title> <editor> in M. van Tilborg and G.M. Koob(eds), </editor> <title> Foundation of Real-Time Computing (Formal Specifications and Methods) pp 251-289, </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1991. </year>
Reference-contexts: In the next couple of subsections we briefly describe the features with regard to timing of Ada [1, 4], RT-Euclid [16], and the object oriented languages DROL [23], RTC++ [15], FLEX <ref> [20] </ref> and Sina (with real-time extensions) [3, 5]. After that we discuss the major differences with our approach. 14 COMPARISON WITH OTHER APPROACHES 38 14.1 ADA The Ada language [4] was developed to supply the US Department of Defense with a programming language for embedded applications. <p> We already commented on this in our discussion of the Ada language. The ARTS kernel employs rate monotonic scheduling of HRT tasks and the schedulability analysis is based on this scheduling regime. In this way it is possible to guarantee timeliness for certain applications. 14.5 FLEX FLEX <ref> [20] </ref> is a real-time language developed in the Concord project at the University of Illinois. It focuses on programming of systems that can operate in very dynamic environments. In this sense it aims at similar applications as the DROL language.
Reference: [21] <author> S. Matsuoka, K. Taura and Y. Yonezawa, </author> <title> "Highly Efficient and Encapsulated Re-use of Synchronization Code in Concurrent Object-Oriented Languages", </title> <booktitle> in Proceedings OOPSLA '93, Sigplan Notices Vol. </booktitle> <volume> 28, No. 10, </volume> <pages> pp 109-36, </pages> <year> 1993. </year>
Reference-contexts: Object-oriented languages are in general more complex and some problems with making such languages concurrent, such as inheritance anomalies <ref> [21] </ref>, are still being discussed. <p> This makes it very difficult to understand the full extent and implications of the various approaches. 15 CONCLUSION 44 14.8 The combination of real time with object orientation With their work the authors of Sina advocate composition filters as a solution to the well known concurrency anomalies <ref> [21] </ref> in concurrent object-oriented languages . They also claim that some inheritance anomalies exist with regard to timing specification that are resolved using real-time filters [3, 5]. The real-time anomalies result in a reduced reusability of code of classes under inheritance.
Reference: [22] <author> S. Ren, G. A. Agha and M. Saito, </author> <title> "A modular Approach for Programming Distributed Real-Time Systems", </title> <note> to appear in Journal of Parallel and Distributed Computing, preprint 1996. </note>
Reference-contexts: Superclasses can offer control over (abstract) events that are not affected by added functionality in sub-classes. Also refraining from over-specification of timing behavior helps to avoid the anomalies. In <ref> [22] </ref> an object-oriented programming model is introduced in which timing constraints between invocations of an object or group of objects can be specified by the programmer in separate entities, called synchronizers.
Reference: [23] <author> K. Takashio and M. Tokoro, "DROL: </author> <title> An Object-Oriented Programming Language for Distributed Real-Time Systems", </title> <booktitle> Proceedings of the OOPSLA '92 Conference, ACM SIGPLAN Notices, </booktitle> <volume> Vol. 27, No. 10, pp276-294, </volume> <year> 1992. </year>
Reference-contexts: In the next couple of subsections we briefly describe the features with regard to timing of Ada [1, 4], RT-Euclid [16], and the object oriented languages DROL <ref> [23] </ref>, RTC++ [15], FLEX [20] and Sina (with real-time extensions) [3, 5]. After that we discuss the major differences with our approach. 14 COMPARISON WITH OTHER APPROACHES 38 14.1 ADA The Ada language [4] was developed to supply the US Department of Defense with a programming language for embedded applications. <p> The only reason to have the programmer specify it is that such information is usually hard to deduce at compile time but is required to perform the timing analysis. 14.3 DROL DROL <ref> [23] </ref> is a programming language for distributed object-oriented real-time systems with a run-time system that is implemented on the ARTS kernel. It obtains the facilities to implement a distributed system from this kernel.
Reference: [24] <author> G. Yu and L.R. Welch, </author> <title> "Program Dependence Analysis for Concurrency Exploitation in Programs Composed of Abstract Data Type Modules", </title> <booktitle> Proceedings of the IEEE Symposium on Parallel and Distributed Computing, </booktitle> <pages> pp 66-73, </pages> <month> Oct. </month> <year> 1994. </year>
Reference-contexts: complexity), or finer grained concurrency, in a way that keeps platform considerations out of the program design. (Concurrency optimizations can also be done automatically during system generation, thus avoiding the danger of introducing concurrency that is not strictly inspired by the specification of the real-time problem that is being solved <ref> [24] </ref>.) The hope is that the envisaged system generation can be automated to a large extent. Real-time system-development tool kits that are presently available justify such hope. The main purpose of this paper is to illustrate our approach by an example, show its practical implications and argue for its feasibility.
Reference: [25] <author> N. Wirth, </author> <title> "Programming Development by Stepwise refinement", </title> <journal> Comm. of ACM, </journal> <volume> Vol. 14, No. 4, </volume> <pages> pp 221-227, </pages> <year> 1971. </year>
Reference-contexts: A well-defined semantics is needed in then present context to be able to demonstrate that correctness of real-time programs can be established independent of the execution platform. 2 Composability and reusability of real-time programs It is generally recognized that problem decomposition and stepwise refinement <ref> [25, 9] </ref> are important programming strategies. When only functional aspects of programs are considered, there are no major problems in applying these strategies: the functional behavior of a component can be made to depend strictly on the explicitly declared interfaces offered by others.
Reference: [26] <author> N. Wirth, </author> <title> "Towards a Discipline of Real-Time Programming", </title> <journal> Comm. of ACM, </journal> <volume> Vol. 20, No. 8, </volume> <pages> pp 577-583, </pages> <year> 1977. </year>
References-found: 26

