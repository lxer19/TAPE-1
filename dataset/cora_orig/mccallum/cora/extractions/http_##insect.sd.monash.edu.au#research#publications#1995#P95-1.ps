URL: http://insect.sd.monash.edu.au/research/publications/1995/P95-1.ps
Refering-URL: http://www.progsoc.uts.edu.au/~geldridg/cpp/
Root-URL: http://www.aic.nrl.navy.mil/~aha/people.html
Email: Email: fjona,cmingins,hwsg@insect.sd.monash.edu.au  
Phone: Phone: +61-3-9032787 Fax: +61-3-9032745  
Title: Yes! An Object-Oriented Compiler Compiler  
Author: (YOOCC) Jon Avotins, Christine Mingins and Heinz Schmidt 
Address: Caulfield Campus PO Box 197, Caulfield East, Australia 3145  
Affiliation: Department of Software Development Monash University,  
Abstract: Grammar-based processor generation is one of the most widely studied areas in language processor construction (Donzeau-Gouge 1984; Aho, Sethi, and Ullman 1986; Kramer and Schmidt 1989; Grosch and Emmelmann 1990). However, there have been very few approaches to date that reconcile object-oriented principles, processor generation, and an object-oriented language. Pertinent here also, is that currently to develop a processor using the Eiffel Parse libraries requires far too much time to be expended on tasks that can be automated. For these reasons, we have developed Y o o C C (Yes! an Object-Oriented Compiler Compiler), which produces a processor framework from a grammar using an enhanced version of the Eiffel Parse libraries, incorporating the ideas hypothesized by Meyer (1994b), and Grape and Walden (1992), as well as many others. Various essential changes have been made to the Eiffel Parse libraries. Examples are presented to illustrate the development of a processor using Y o o C C, and it is concluded that the Eiffel Parse libraries are now not only an intelligent, but also a productive option for processor construction. 
Abstract-found: 1
Intro-found: 1
Reference: <author> Aho, A., R. Sethi, and J. </author> <title> Ullman (1986). </title> <booktitle> Compilers: Principles, Techniques and Tools. </booktitle> <publisher> Addison Wesley. </publisher>
Reference: <author> Avotins, J. </author> <year> (1994). </year> <title> Defining and Designing a Quality OO Metrics Suite. TOOLS 1994. </title> <publisher> Prentice Hall. </publisher>
Reference: <author> Avotins, J., G. Maughan, and C. </author> <month> Mingins </month> <year> (1995). </year> <title> Truly Reusable OO Parser for Eif-fel Re-Engineering (TROOPER). </title> <type> Technical Report 2, </type> <institution> Monash University. </institution>
Reference-contexts: These include: 1. Metrics collection and analysis tools (Avotins and Mingins 1993; Avotins 1994). 2. Testing class interfaces (Fletcher 1995). 3. Project management tools (Wang 1995). 4. Truly Reusable OO Parser for Eiffel Re-Engineering <ref> (Avotins, Maughan, and Min gins 1995) </ref>. 5. OO architectural restructuring (Maughan 1996). <p> Some of these are presented in this section. 6.1 TROOPER A parser for Eiffel entitled Truly Reusable Object-Oriented Parser for Eiffel Re-engineering (T r o o peR) <ref> (Avotins, Maughan, and Mingins 1995) </ref> originally developed without the aid of Y o o C C, and later re-developed using it. Y o o C C drastically cut production time by an estimated 280 percent.
Reference: <author> Avotins, J. and C. </author> <month> Mingins </month> <year> (1993). </year> <title> Metrics for object-oriented design. TOOLS 1993. </title> <publisher> Prentice Hall. </publisher>
Reference: <author> Donzeau-Gouge, V. </author> <year> (1984). </year> <title> Programming environment based on structured editors: The mentor experience. Interactive Programming Environments. </title> <address> Mc Graw-Hill New York. </address>
Reference: <author> Fletcher, R. </author> <year> (1995, </year> <month> March). </month> <title> Testing of Object-Oriented Software Based on Formal Specifications. </title> <type> Master's thesis, </type> <institution> Monash University, </institution> <address> Melbourne, Australia. </address>
Reference-contexts: There are also a wide variety of new tools which can also be developed just for Eiffel class texts, which are currently under construction by researchers at Monash University in Australia. These include: 1. Metrics collection and analysis tools (Avotins and Mingins 1993; Avotins 1994). 2. Testing class interfaces <ref> (Fletcher 1995) </ref>. 3. Project management tools (Wang 1995). 4. Truly Reusable OO Parser for Eiffel Re-Engineering (Avotins, Maughan, and Min gins 1995). 5. OO architectural restructuring (Maughan 1996).
Reference: <author> Grape, P. and K. </author> <title> Walden (1992). Automating the Development of Syntax Tree Generators for an Evolving Language. </title> <booktitle> TOOLS 8, </booktitle> <pages> pp. 185-195. </pages> <publisher> Prentice Hall. </publisher>
Reference-contexts: The term document denotes the texts to be parsed, whilst a processor refers to a software system that performs pars ing as part of their processing. 2. The maintenance effort required for an evolving processor is severe <ref> (Grape and Walden 1992) </ref>. 3. The slightest change in the grammar will usually result in a large re-coding effort and inevitable inconsistencies. <p> Apply object-oriented concepts as fully as possible to all aspects of a system. 3. Permit easier error detection than its alternatives, and subsequently reduces the effort required for syntax control, permitting more time to be devoted to semantics <ref> (Grape and Walden 1992) </ref>. 4. Independently develop semantic classes with algorithms for semantic analysis and evaluation, without unnecessary overheads resulting from grammar transformations (Grape and Walden 1992). 5. Apply various semantic treatments to the same syntactic structure. 6. Use an object-centred approach to proces sor generation. <p> Permit easier error detection than its alternatives, and subsequently reduces the effort required for syntax control, permitting more time to be devoted to semantics <ref> (Grape and Walden 1992) </ref>. 4. Independently develop semantic classes with algorithms for semantic analysis and evaluation, without unnecessary overheads resulting from grammar transformations (Grape and Walden 1992). 5. Apply various semantic treatments to the same syntactic structure. 6. Use an object-centred approach to proces sor generation. The ability to apply several semantic treatments to the same syntactic structure is a powerful notion.
Reference: <author> Groeber, B. and O. </author> <month> Langmack </month> <year> (1990, </year> <title> Decem-ber). A Compiler Front-End for Eiffel-3. </title> <type> Technical Report Report B-92-2520, </type> <institution> Institute of Information Berlin University. </institution>
Reference-contexts: The power of LEX BUILDER is fully realized via its development. T r o o peR obviously provides an Eiffel counterpart to the existent yacc generated Eiffel 3 parser "EP" <ref> (Groeber and Langmack 1990) </ref> providing the advantages presented in Section 1.2. Semantic actions can be easily attached to enable the development of prospective Eiffel tools like those mentioned in Section 1.3.
Reference: <author> Grosch, J. </author> <year> (1990, </year> <month> August 27). </month> <title> Object-Oriented Attribute Grammars. </title> <type> Technical Report Compiler Generation Report Number 23, </type> <institution> GMD Forschungsstelle University Karlsruhe. </institution>
Reference-contexts: Solutions to some of these problems have been provided by OO grammar approaches. 1.1.1 OO Grammar Approaches Existing object-oriented attribute grammar systems include ASDL (Kramer and Schmidt 1989), Centaur (Borras et al. 1988), and the Karlsruhe Cocktail system <ref> (Grosch and Emmel-mann 1990) </ref>. These systems resolve many of the problems with traditional techniques. For instance, ASDL defines a cluster of classes and associated rules for capturing the document structure of a processor, whilst allowing one to associate different semantic actions to that same syntactic structure.
Reference: <author> Grosch, J. </author> <year> (1991, </year> <month> March 1). </month> <title> Rex A Scanner Generator. </title> <type> Technical Report Compiler Generation Report Number 5, </type> <institution> GMD Forschungsstelle University Karlsruhe. </institution>
Reference-contexts: o o C C however, an indirect-terminal will inherit from its associated single right hand side name construct. 10 Explained in more detail in Section 7. 3.2 Lexical Definition Complementing the Eiffel Parse library is the Eiffel lexical library, providing similar functionality to lex (Lesk and Schmidt 1975), and Rex <ref> (Grosch 1991) </ref>. In order to parse any document, there is a need to obtain tokens from a lexical analyzer. Therefore, terminal constructs are usually implemented as descendants of lexical classes. <p> same concepts as Eiffel: The Environment (Meyer 1994a), providing similar functionality to the compiler toolbox developed by Grosch and Emmelmann (1990). * Extending the Eiffel Parse libraries to include techniques for integrating within the same language LALR (1) and LL (1) grammars, similar to that implemented by Lalr and Ell <ref> (Grosch and Vielsack 1991) </ref>. * Implementing advanced object-oriented attribute grammar techniques like those hypothesized by Grosch (1990), as well as the complementary ideas of Kramer and Schmidt (1989), which allow routine calls from within grammar rules as mentioned in Section 3.4.1. * Implementing facilities for Y o o C C to
Reference: <author> Grosch, J. and H. </author> <month> Emmelmann </month> <year> (1990, </year> <month> January 21). </month> <title> A Toolbox for Compiler Construction. </title> <type> Technical Report Compiler Generation Report Number 20, </type> <institution> GMD Forschungsstelle University Karlsruhe. </institution>
Reference-contexts: Solutions to some of these problems have been provided by OO grammar approaches. 1.1.1 OO Grammar Approaches Existing object-oriented attribute grammar systems include ASDL (Kramer and Schmidt 1989), Centaur (Borras et al. 1988), and the Karlsruhe Cocktail system <ref> (Grosch and Emmel-mann 1990) </ref>. These systems resolve many of the problems with traditional techniques. For instance, ASDL defines a cluster of classes and associated rules for capturing the document structure of a processor, whilst allowing one to associate different semantic actions to that same syntactic structure.
Reference: <author> Grosch, J. and B. </author> <month> Vielsack </month> <year> (1991, </year> <month> March 6). </month> <title> The Parser Generators Lalr and Ell. </title> <type> Technical Report Compiler Generation Report Number 8, </type> <institution> GMD Forschungsstelle University Karlsruhe. </institution>
Reference-contexts: o o C C however, an indirect-terminal will inherit from its associated single right hand side name construct. 10 Explained in more detail in Section 7. 3.2 Lexical Definition Complementing the Eiffel Parse library is the Eiffel lexical library, providing similar functionality to lex (Lesk and Schmidt 1975), and Rex <ref> (Grosch 1991) </ref>. In order to parse any document, there is a need to obtain tokens from a lexical analyzer. Therefore, terminal constructs are usually implemented as descendants of lexical classes. <p> same concepts as Eiffel: The Environment (Meyer 1994a), providing similar functionality to the compiler toolbox developed by Grosch and Emmelmann (1990). * Extending the Eiffel Parse libraries to include techniques for integrating within the same language LALR (1) and LL (1) grammars, similar to that implemented by Lalr and Ell <ref> (Grosch and Vielsack 1991) </ref>. * Implementing advanced object-oriented attribute grammar techniques like those hypothesized by Grosch (1990), as well as the complementary ideas of Kramer and Schmidt (1989), which allow routine calls from within grammar rules as mentioned in Section 3.4.1. * Implementing facilities for Y o o C C to
Reference: <author> Johnson, S. </author> <year> (1975). </year> <title> Yacc: Yet Another Compiler-Compiler. </title> <institution> Technical Report Computer Science 32, Bell Laboratories. </institution>
Reference-contexts: It is concluded, however, that existing object-oriented attribute grammar techniques are grammar centred, where as, the Eiffel Parse libraries are object centred. 1.1 Traditional Techniques Although most software engineers are accustomed to using automatic compiler generators like yacc <ref> (Johnson 1975) </ref>, this technology for processor construction has various limitations. These include: 1.
Reference: <author> Keene, S. </author> <year> (1989). </year> <title> Object-Oriented Programming in CMMON LISP: A programmer's guide to CLOS. </title> <publisher> Addison-Wesley. </publisher>
Reference-contexts: For terminal constructs, only one semantic action makes sense, and therefore pre action is renamed unused pre action and post action is renamed action. These actions are similar to before and after methods in Common Lisp Object System (CLOS) 13 <ref> (Keene 1989) </ref>, whereby methods are combined, which implies that all methods are executed along the inheritance hierarchy.
Reference: <author> Kramer, B. and H. Schmidt (1989, </author> <month> January). </month> <title> Developing Integrated Environments with ASDL. </title> <journal> IEEE Software, </journal> <pages> 98-107. </pages>
Reference-contexts: The slightest change in the grammar will usually result in a large re-coding effort and inevitable inconsistencies. Solutions to some of these problems have been provided by OO grammar approaches. 1.1.1 OO Grammar Approaches Existing object-oriented attribute grammar systems include ASDL <ref> (Kramer and Schmidt 1989) </ref>, Centaur (Borras et al. 1988), and the Karlsruhe Cocktail system (Grosch and Emmel-mann 1990). These systems resolve many of the problems with traditional techniques.
Reference: <author> Lesk, M. and E. Schmidt (1975, </author> <month> October). </month> <pages> Lex </pages>
Reference-contexts: When processed by Y o o C C however, an indirect-terminal will inherit from its associated single right hand side name construct. 10 Explained in more detail in Section 7. 3.2 Lexical Definition Complementing the Eiffel Parse library is the Eiffel lexical library, providing similar functionality to lex <ref> (Lesk and Schmidt 1975) </ref>, and Rex (Grosch 1991). In order to parse any document, there is a need to obtain tokens from a lexical analyzer. Therefore, terminal constructs are usually implemented as descendants of lexical classes.
References-found: 16

