URL: ftp://flint.cs.yale.edu/pub/flint/publications/tcif.ps.gz
Refering-URL: http://daffy.cs.yale.edu/users/shao-zhong/papers.html
Root-URL: http://www.cs.yale.edu
Email: shao-zhong@cs.yale.edu  
Title: Typed Common Intermediate Format  
Author: Zhong Shao 
Address: New Haven, CT 06520-8285  
Affiliation: Dept. of Computer Science Yale University  
Abstract: This paper presents a framework on building high-quality systems environment for multiple advanced languages. Our key innovation is the use of a common typed intermediate language, named FLINT, to model the semantics and interactions of various language-specific features. FLINT is based on a predicative variant of the Girard-Reynolds polymorphic calculus F ! , extended with a very rich set of primitive types and functions. FLINT provides a common compiler infrastructure that can be quickly adapted to generate compilers for new general-purpose and domain-specific languages. With its single unified type system, FLINT serves as a great platform for reasoning about cross-language interoperations. FLINT types act as a glue to connect language features that complicate interoperability, such as mixed data representations, multiple function calling conventions, and different memory management protocols. In addition, because all runtime representations are determined by FLINT types, languages compiled under FLINT can share the same system-wide garbage collector and foreign function call interface. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> A. V. Aho, R. Sethi, and J. D. Ullman. </author> <booktitle> Compilers: Principles, Techniques, and Tools. </booktitle> <publisher> Addison-Wesley, </publisher> <address> Reading, MA, </address> <year> 1986. </year>
Reference: [2] <author> A. W. Appel. </author> <title> A runtime system. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 3(4) </volume> <pages> 343-380, </pages> <year> 1990. </year>
Reference-contexts: introduction about F ! , and then formally define the Core-FLINT language. The standard Girard-Reynolds polymorphic calculus F ! is often defined as follows: (kinds) ::= j 1 ! 2 (types) ::= t j 1 ! 2 j 8t :: : j t :: : j 1 <ref> [ 2 ] </ref> (terms) e ::= x j x : :e j @e 1 e 2 j flt :: :e j e [] The calculus contains three syntactic classes: kinds (), types (), and terms (e). Here, kinds classify types, and types classify terms. <p> A higher-order type 1 can be applied to another type 2 , written as 1 <ref> [ 2 ] </ref>. At the term level, in addition to the usual lambda abstraction and application, F ! also support explicit type abstraction and type application (written as flt :: :e and e []).
Reference: [3] <author> A. W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cam-bridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: First, the middle end performs a series of conventional control and data flow optimizations. All optimizations are type-preserving so the resulting FLINT code will still type-check under the same typing rules. Because FLINT terms are always in the A-normal form, all CPS-based optimizations <ref> [3] </ref> apply to FLINT as well. Apart from the presence of polymorphism and higher-order functions, the resulting FLINT code should be very close to the low-level machine languages. <p> Our algorithm exploits the use of compile-time control and data flow information to optimize closure representations. By extensive closure sharing and allocating as many closures in registers as possible, our closure conversion algorithm not only gives good performance but also satisfies the strong safe for space complexity rule <ref> [3] </ref>, thus achieving good asymptotic space usage. 5 Translation into FLINT To demonstrate the power of the FLINT language, we have built a new front end that translates the en tire SML'97 [22] plus MacQueen-Tofte higher-order modules [21]) into our typed common intermediate format.
Reference: [4] <author> M. Blume. </author> <title> A compilation manager for SML/NJ. as part of SML/NJ User's Guide, </title> <year> 1995. </year>
Reference-contexts: With the use of suspension terms, type application is always done on a by-need basis, and once it is done, the result will be memoized for future use. Our preliminary measurements have shown that on heavily functorized applications such as SML/NJ Compilation Manager <ref> [4] </ref>, our optimized implementation is an order-of-magnitude faster (in compilation time) than naive implementations. Representing type variables as de Bruijn indices does have its drawback. For example, the type-based manipulation becomes much harder to program.
Reference: [5] <author> K. B. Bruce, L. Cardelli, and B. C. Pierce. </author> <title> Comparing object encodings. </title> <booktitle> In Proc. Third Workshop on Foundations of Object Oriented Languages, </booktitle> <month> July </month> <year> 1996. </year>
Reference-contexts: Type class can be eliminated by explicit dictionary-passing, done by the type checker in the front end. Lazy evaluation requires the use of FLINT primitives, delay and force, to make the evaluation explicit. Translating Java into FLINT is less trivial, but it boils down to what kind of encodings <ref> [5] </ref> we use to model the Java objects. We believe that FLINT is a sufficiently rich intermediate language that can be used to handle many interesting application languages.
Reference: [6] <author> N. de Bruijn. </author> <title> A survey of the project AUTOMATH. In To H. </title> <editor> B. </editor> <booktitle> Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, </booktitle> <pages> pages 579-606. </pages> <note> Edited by J. </note> <editor> P. Seldin and J. R. Hindley, </editor> <publisher> Academic Press, </publisher> <year> 1980. </year>
Reference-contexts: Naive implementation of these operations would lead to duplicate copying, redundant traversal, and extremely slow compilation. We use the following techniques to optimize the representations of kinds, constructors, and types ( see written as ML datatype definitions). First, we represent all type variables as de Bruijn indices <ref> [6] </ref>. Under de Bruijn notations, all constructors and types have unique representations. We then hash-cons all the kinds, constructors, and types into three separate hash-tables. Each kind (tkind), constructor (tyc), or type (lty) is represented as an internal hash cell (or icell).
Reference: [7] <author> J. Dean, G. DeFouw, D. Grove, V. Litvinov, and C. Chambers. </author> <title> Vortex: An optimizing compiler for object-oriented languages. </title> <booktitle> In Proc. ACM SIG-PLAN '96 Conf. on Object-Oriented Programming Systems, Languages, and applications, </booktitle> <pages> pages 83-100, </pages> <address> New York, </address> <month> October </month> <year> 1996. </year> <note> ACM Press. </note>
Reference-contexts: Many existing compilers such as GNU's GCC, Stanford's SUIF [12], and U. Washington's Vortex <ref> [7] </ref> all use some kind of shared intermediate representations for multiple source languages. In addition, the C programming language has been used as the de facto common intermediate format for a long time.
Reference: [8] <author> L. George, F. Guillaume, and J. Reppy. </author> <title> A portable and optimizing backend for the SML/NJ compiler. </title> <booktitle> In Proceedings of the 1994 International Conference on Compiler Construction, </booktitle> <pages> pages 83-97. </pages> <publisher> Springer-Verlag, </publisher> <month> April </month> <year> 1994. </year>
Reference-contexts: After the optimizations, the back end uses flexible representation analysis [34] to compile polymor-phism and safe-for-space closure conversion to compile higher-order functions [36]; it then does the standard register allocation, instruction scheduling, and machine code generation <ref> [8] </ref>. In the rest of this section, we sample several important techniques used in our compiler back end. 4.1 Type Specialization Because polymorphic functions are often more expensive than monomorphic functions, the middle end of our compiler performs several rounds of type specialization to decrease the degree of polymor-phism.
Reference: [9] <author> J. Y. Girard. </author> <title> Interpretation Fonctionnelle et Elimination des Coupures dans l'Arithmetique d'Ordre Superieur. </title> <type> PhD thesis, </type> <institution> University of Paris VII, </institution> <year> 1972. </year>
Reference: [10] <author> J. Gosling, B. Joy, and G. Steele. </author> <title> The Java Language Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference: [11] <author> O. M. </author> <title> Group. The common object request broker: Architecture and specifications (corba). Revision 1.2., Object Management Group (OMG), Framing-ham,M A, </title> <month> December </month> <year> 1993. </year>
Reference: [12] <author> M. Hall, J. Anderson, S. Amarasinghe, B. Murphy, S. Liao, E. Bugnion, and M. Lam. </author> <title> Maximizing multiprocessor performance with the SUIF compiler. </title> <booktitle> IEEE Computer, </booktitle> <month> December </month> <year> 1996. </year>
Reference-contexts: If we consider C as a common intermediate format for conventional imperative languages, FLINT plays the same role but for modern HOT languages. 6 Related Work Common intermediate format has been an active research area in the past. Many existing compilers such as GNU's GCC, Stanford's SUIF <ref> [12] </ref>, and U. Washington's Vortex [7] all use some kind of shared intermediate representations for multiple source languages. In addition, the C programming language has been used as the de facto common intermediate format for a long time.
Reference: [13] <author> R. Harper and J. C. Mitchell. </author> <title> On the type structure of Standard ML. </title> <journal> ACM Trans. Prog. Lang. Syst., </journal> <volume> 15(2) </volume> <pages> 211-252, </pages> <month> April </month> <year> 1993. </year>
Reference-contexts: Translation from the Core-ML-like (or Core-Haskell-like) language to FLINT is same as the standard embedding of ML into F ! <ref> [13] </ref>; other features such as ML datatypes are translated into FLINT type constructors. Compilation from SML higher-order modules to FLINT is quite a challenge because higher-order modules involve the use of dependent types which, in general, cannot be expressed as F ! -like polymorphism. <p> Our FLINT compiler is the first that handles the entire SML'97 plus MacQueen-Tofte higher-order modules. Using the predicative polymorphic -calculus to model the type-theoretic semantics of Standard ML was pioneered by Harper and Mitchell <ref> [13] </ref>. Their XML calculus also includes dependent types to characterize ML module constructs. Harper and Mor-risett [15, 23] later proposed to use a predicative variant of F ! (but extended with typerec) to compile ML-like polymorphism.
Reference: [14] <author> R. Harper, J. C. Mitchell, and E. Moggi. </author> <title> Higher-order modules and the phase distinction. </title> <booktitle> In Seventeenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 341-344, </pages> <address> New York, Jan 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: For example, the front end for ML can translate higher-order modules into the Core-FLINT-like calculus <ref> [35, 14] </ref> in a type-preserving way, thus completely eliminating the need of module constructs from the intermediate language. Similarly, type classes in Haskell can also be embedded into F ! through explicit dictionary passing. The complete FLINT language still contains many more type and term constructs than the core languages.
Reference: [15] <author> R. Harper and G. Morrisett. </author> <title> Compiling polymor-phism using intensional type analysis. </title> <booktitle> In Twenty-second Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 130-141, </pages> <address> New York, Jan 1995. </address> <publisher> ACM Press. </publisher>
Reference-contexts: This complicates the semantics and makes the calculus impredicative. Following Harper and Morrisett <ref> [15] </ref>, we split the type hierarchy into two levels: a constructor level characterizes the monomorphic types (and type functions), and a type level expresses the polymorphic types. "Kind" is now used to classify "constructors" only; polymorphic types such as the previous 0 no longer belongs to kind . <p> The term formation rules are in the form of 4; ` e : where 4 is a kind environment mapping type variables to kinds, and is the type environment mapping term variables to types. Harper and Morrisett <ref> [15, 23] </ref> have shown that type checking for predicative F ! - like calculus is decidable, and furthermore, its typing rules are consistent with the standard call-by-value operational semantics. 3.4 The Full Language In order to make FLINT as simple as possible, we let the front end deal with many higher-level <p> Using the predicative polymorphic -calculus to model the type-theoretic semantics of Standard ML was pioneered by Harper and Mitchell [13]. Their XML calculus also includes dependent types to characterize ML module constructs. Harper and Mor-risett <ref> [15, 23] </ref> later proposed to use a predicative variant of F ! (but extended with typerec) to compile ML-like polymorphism. Recently, Harper and Stone [16] gave a new type theoretic account for the entire SML'97; the internal language they use still contain a separate module calculus and translucent types.
Reference: [16] <author> R. Harper and C. Stone. </author> <title> A type-theoretic account of Standard ML 1996 (version 2). </title> <type> Technical Report CMU-CS-96-136R, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> September </month> <year> 1996. </year>
Reference-contexts: Their XML calculus also includes dependent types to characterize ML module constructs. Harper and Mor-risett [15, 23] later proposed to use a predicative variant of F ! (but extended with typerec) to compile ML-like polymorphism. Recently, Harper and Stone <ref> [16] </ref> gave a new type theoretic account for the entire SML'97; the internal language they use still contain a separate module calculus and translucent types.
Reference: [17] <author> P. Hudak, S. P. Jones, and P. W. et al. </author> <title> Report on the programming language Haskell, a non-strict, purely functional language version 1.2. </title> <journal> SIGPLAN Notices, </journal> <volume> 21(5), </volume> <month> May </month> <year> 1992. </year>
Reference: [18] <author> L. Huelsbergen. </author> <title> A portable C interface for Standard ML of New Jersey. </title> <type> Technical memorandum, </type> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, NJ, </address> <month> January </month> <year> 1996. </year>
Reference: [19] <author> X. Leroy. </author> <title> Unboxed objects and polymorphic typing. </title> <booktitle> In Nineteenth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <pages> pages 177-188, </pages> <address> New York, </address> <month> Jan </month> <year> 1992. </year> <note> ACM Press. Longer version available as INRIA Tech Report. </note>
Reference-contexts: Under flexible representation analysis, recursive and mutable data objects can use unboxed representations without incurring expensive runtime cost on heavily polymorphic code. In contrast, the coercion-based approach used in Gallium <ref> [19] </ref> and SML/NJ [37] does not support unboxed representations on recursive and mutable objects; the type-passing approach used in TIL [38] does handle all data objects, but it involves heavy-weight runtime type analysis and code manipulations. 4.4 Closure Conversion After the polymorphism is eliminated, we use an efficient and safe-for-space closure <p> Because the Java bytecode is originally designed for Java only, it does not directly support common HOT language features such as higher-order functions and polymorphic functions. Typed intermediate languages have gotten a lot of attentions in the ML community lately. Several ML compilers, e.g., Gallium <ref> [19] </ref>, SML/NJ [37], and TIL [38], all maintain explicit type information inside their intermediate languages. Our FLINT compiler is the first that handles the entire SML'97 plus MacQueen-Tofte higher-order modules. Using the predicative polymorphic -calculus to model the type-theoretic semantics of Standard ML was pioneered by Harper and Mitchell [13].
Reference: [20] <author> T. Lindholm and F. Yellin. </author> <title> The Java Virtual Machine Specification. </title> <publisher> Addison-Wesley, </publisher> <year> 1997. </year>
Reference-contexts: Of course, none of these intermediate languages are strongly typed, and neither do they support advanced HOT languages such as ML. One example of typed intermediate format is the Java VM bytecode <ref> [20] </ref>. Like FLINT, the Java byte-code can be statically type-checked, though its type system is not as formalized as the F ! calculus. Because the Java bytecode is originally designed for Java only, it does not directly support common HOT language features such as higher-order functions and polymorphic functions.
Reference: [21] <author> D. MacQueen and M. Tofte. </author> <title> A semantics for higher order functors. </title> <booktitle> In The 5th European Symposium on Programming, </booktitle> <pages> pages 409-423, </pages> <address> Berlin, </address> <month> April </month> <year> 1994. </year> <pages> Spinger-Verlag. </pages>
Reference-contexts: The product kind makes it possible to define type functions that takes a sequence of type constructors as argument and returns another sequence as the result. This is useful to express the parameterized modules such as ML higher-order functors <ref> [21] </ref>. <p> gives good performance but also satisfies the strong safe for space complexity rule [3], thus achieving good asymptotic space usage. 5 Translation into FLINT To demonstrate the power of the FLINT language, we have built a new front end that translates the en tire SML'97 [22] plus MacQueen-Tofte higher-order modules <ref> [21] </ref>) into our typed common intermediate format. This new front end and the FLINT middle end have been incorporated and released as part of the Standard ML of New Jersey compiler since version 109.24 (January 9, 1997).
Reference: [22] <author> R. Milner, M. Tofte, R. Harper, and D. MacQueen. </author> <title> The Definition of Standard ML (Revised). </title> <publisher> MIT Press, </publisher> <address> Cambridge, Massachusetts, </address> <year> 1997. </year>
Reference-contexts: closure conversion algorithm not only gives good performance but also satisfies the strong safe for space complexity rule [3], thus achieving good asymptotic space usage. 5 Translation into FLINT To demonstrate the power of the FLINT language, we have built a new front end that translates the en tire SML'97 <ref> [22] </ref> plus MacQueen-Tofte higher-order modules [21]) into our typed common intermediate format. This new front end and the FLINT middle end have been incorporated and released as part of the Standard ML of New Jersey compiler since version 109.24 (January 9, 1997).
Reference: [23] <author> G. Morrisett. </author> <title> Compiling with Types. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> December </month> <year> 1995. </year> <note> Tech Report CMU-CS-95-226. </note>
Reference-contexts: The term formation rules are in the form of 4; ` e : where 4 is a kind environment mapping type variables to kinds, and is the type environment mapping term variables to types. Harper and Morrisett <ref> [15, 23] </ref> have shown that type checking for predicative F ! - like calculus is decidable, and furthermore, its typing rules are consistent with the standard call-by-value operational semantics. 3.4 The Full Language In order to make FLINT as simple as possible, we let the front end deal with many higher-level <p> Using the predicative polymorphic -calculus to model the type-theoretic semantics of Standard ML was pioneered by Harper and Mitchell [13]. Their XML calculus also includes dependent types to characterize ML module constructs. Harper and Mor-risett <ref> [15, 23] </ref> later proposed to use a predicative variant of F ! (but extended with typerec) to compile ML-like polymorphism. Recently, Harper and Stone [16] gave a new type theoretic account for the entire SML'97; the internal language they use still contain a separate module calculus and translucent types.
Reference: [24] <author> G. Nadathur. </author> <title> A notation for lambda terms II: Refinements and applications. </title> <type> Technical Report CS-1994-01, </type> <institution> Duke University, Durham, NC, </institution> <month> January </month> <year> 1994. </year>
Reference-contexts: Finally, to make type reduction lazy, we use Na-dathur's suspension notations <ref> [24, 25] </ref> to represent the intermediate result of unevaluated type applications. Intuitively, a type suspension such as LT_ENV (t; i; j; e) is a quadruple consisting of a term t with two indices and an environment.
Reference: [25] <author> G. Nadathur and D. S. Wilson. </author> <title> A representation of lambda terms suitable for operations on their intensions. </title> <booktitle> In 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 341-348, </pages> <address> New York, June 1990. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Finally, to make type reduction lazy, we use Na-dathur's suspension notations <ref> [24, 25] </ref> to represent the intermediate result of unevaluated type applications. Intuitively, a type suspension such as LT_ENV (t; i; j; e) is a quadruple consisting of a term t with two indices and an environment. <p> The first index i indicates an embedding level with respect to which variable references have been determined within the term, and the second index j indicates a new embedding level <ref> [25] </ref>. The environment e determines the bindings for the type variables. (tkind), constructor (tyc), and type (lty) using SML datatype definitions.
Reference: [26] <author> G. Necula. </author> <title> Proof-carrying code. </title> <booktitle> In Twenty-Fourth Annual ACM Symp. on Principles of Prog. Languages, </booktitle> <address> New York, Jan 1997. </address> <publisher> ACM Press. </publisher>
Reference: [27] <author> G. Nelson, </author> <title> editor. Systems programming with Modula-3. </title> <publisher> Prentice Hall, </publisher> <address> Englewood Cliffs, NJ, </address> <year> 1991. </year>
Reference: [28] <author> S. L. Peyton Jones and J. Launchbury. </author> <title> Unboxed values as first class citizens in a non-strict functional language. </title> <booktitle> In The Fifth International Conference on Functional Programming Languages and Computer Architecture, </booktitle> <pages> pages 636-666, </pages> <address> New York, </address> <month> August </month> <year> 1991. </year> <note> ACM Press. </note>
Reference: [29] <author> J. H. Reppy. </author> <title> CML: A higher-order concurrent language. </title> <booktitle> In Proc. ACM SIGPLAN '91 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 293-305. </pages> <publisher> ACM Press, </publisher> <year> 1991. </year>
Reference-contexts: also includes primitives such as N-bit integers (trapping or non-trapping), N-bit words, N-bit characters (ascii or unicode), N-bit floating-point numbers, strings, boolean types, boxed reference cells, array, packed arrays, vectors, packed vectors, mono arrays and mono vectors, ML-like immutable records (nested or flat), first-class continuations, control continuations (used by CML <ref> [29] </ref>), suspensions (or thunks, to support lazy evaluations). In the long term, we plan to add type dynamic and some form of F-bounded quantification to support object-oriented languages such as Java.
Reference: [30] <author> J. H. Reppy. </author> <title> A high-performance garbage collector for Standard ML. </title> <type> Technical memorandum, </type> <institution> AT&T Bell Laboratories, </institution> <address> Murray Hill, NJ, </address> <month> January </month> <year> 1993. </year>
Reference: [31] <author> J. C. Reynolds. </author> <title> Towards a theory of type structure. </title> <booktitle> In Proceedings, Colloque sur la Programma-tion, Lecture Notes in Computer Science, </booktitle> <volume> volume 19, </volume> <pages> pages 408-425. </pages> <publisher> Springer-Verlag, </publisher> <address> Berlin, </address> <year> 1974. </year>
Reference: [32] <author> D. Rogerson. </author> <title> Inside COM: Microsoft's Component Object Model. </title> <publisher> Microsoft Press, </publisher> <year> 1997. </year>
Reference: [33] <author> A. Sabry and P. Wadler. </author> <title> A reflection on call-by-value. </title> <booktitle> In Proc. 1996 ACM SIGPLAN International Conference on Functional Programming (ICFP'96), </booktitle> <pages> pages 13-24. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1996. </year>
Reference-contexts: The usual term expressions must now satisfy new syntactic restrictions as standard A-normal forms <ref> [33] </ref>. More specifically, each function application (or type application) can only refer to values (as @v 1 v 2 ).
Reference: [34] <author> Z. Shao. </author> <title> Flexible representation analysis. </title> <booktitle> In Proc. 1997 ACM SIGPLAN International Conference on Functional Programming (ICFP'97), </booktitle> <pages> pages 85-98. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1997. </year>
Reference-contexts: Apart from the presence of polymorphism and higher-order functions, the resulting FLINT code should be very close to the low-level machine languages. After the optimizations, the back end uses flexible representation analysis <ref> [34] </ref> to compile polymor-phism and safe-for-space closure conversion to compile higher-order functions [36]; it then does the standard register allocation, instruction scheduling, and machine code generation [8]. <p> The middle-end optimizer does all of these. The lambda contraction phase is also a good place to carry out domain specific program analysis and program optimizations. 4.3 Representation Analysis One novel aspect in our back end is to use the new flexible representation analysis technique <ref> [34] </ref> to compile the polymorphic functions and func-tors. Under flexible representation analysis, recursive and mutable data objects can use unboxed representations without incurring expensive runtime cost on heavily polymorphic code.
Reference: [35] <author> Z. Shao. </author> <title> Typed cross-module compilation. </title> <type> Technical Report YALEU/DCS/RR-1126, </type> <institution> Dept. of Computer Science, Yale University, </institution> <address> New Haven, CT, </address> <month> July </month> <year> 1997. </year>
Reference-contexts: For example, the front end for ML can translate higher-order modules into the Core-FLINT-like calculus <ref> [35, 14] </ref> in a type-preserving way, thus completely eliminating the need of module constructs from the intermediate language. Similarly, type classes in Haskell can also be embedded into F ! through explicit dictionary passing. The complete FLINT language still contains many more type and term constructs than the core languages. <p> Fortunately, ML-style higher-order modules have a clean phase-distinction property; the module language is completely separate from the core language. In a companion paper <ref> [35] </ref>, we present a type-directed translation of the MacQueen-Tofte higher-order modules into the Core-FLINT like language. <p> The detailed algorithm can be found in the companion paper <ref> [35] </ref>. The fact that ML-style higher-order modules can be embedded into FLINT is a good indication of FLINT's expressive power. We are currently working on translations of other source languages such as Haskell, Java, Safe C. Translating Haskell into FLINT is not much different from translating the Core-SML language.
Reference: [36] <author> Z. Shao and A. W. Appel. </author> <title> Space-efficient closure representations. </title> <booktitle> In 1994 ACM Conference on Lisp and Functional Programming, </booktitle> <pages> pages 150-161, </pages> <address> New York, June 1994. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Apart from the presence of polymorphism and higher-order functions, the resulting FLINT code should be very close to the low-level machine languages. After the optimizations, the back end uses flexible representation analysis [34] to compile polymor-phism and safe-for-space closure conversion to compile higher-order functions <ref> [36] </ref>; it then does the standard register allocation, instruction scheduling, and machine code generation [8]. <p> [37] does not support unboxed representations on recursive and mutable objects; the type-passing approach used in TIL [38] does handle all data objects, but it involves heavy-weight runtime type analysis and code manipulations. 4.4 Closure Conversion After the polymorphism is eliminated, we use an efficient and safe-for-space closure conversion algorithm <ref> [36] </ref> to compile the higher-order functions. Our algorithm exploits the use of compile-time control and data flow information to optimize closure representations.
Reference: [37] <author> Z. Shao and A. W. Appel. </author> <title> A type-based compiler for Standard ML. </title> <booktitle> In Proc. ACM SIGPLAN '95 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 116-129. </pages> <publisher> ACM Press, </publisher> <year> 1995. </year>
Reference-contexts: Under flexible representation analysis, recursive and mutable data objects can use unboxed representations without incurring expensive runtime cost on heavily polymorphic code. In contrast, the coercion-based approach used in Gallium [19] and SML/NJ <ref> [37] </ref> does not support unboxed representations on recursive and mutable objects; the type-passing approach used in TIL [38] does handle all data objects, but it involves heavy-weight runtime type analysis and code manipulations. 4.4 Closure Conversion After the polymorphism is eliminated, we use an efficient and safe-for-space closure conversion algorithm [36] <p> Because the Java bytecode is originally designed for Java only, it does not directly support common HOT language features such as higher-order functions and polymorphic functions. Typed intermediate languages have gotten a lot of attentions in the ML community lately. Several ML compilers, e.g., Gallium [19], SML/NJ <ref> [37] </ref>, and TIL [38], all maintain explicit type information inside their intermediate languages. Our FLINT compiler is the first that handles the entire SML'97 plus MacQueen-Tofte higher-order modules. Using the predicative polymorphic -calculus to model the type-theoretic semantics of Standard ML was pioneered by Harper and Mitchell [13].
Reference: [38] <author> D. Tarditi, G. Morrisett, P. Cheng, C. Stone, R. Harper, and P. Lee. </author> <title> TIL: A type-directed optimizing compiler for ML. </title> <booktitle> In Proc. ACM SIGPLAN '96 Conf. on Prog. Lang. Design and Implementation, </booktitle> <pages> pages 181-192. </pages> <publisher> ACM Press, </publisher> <year> 1996. </year>
Reference-contexts: In contrast, the coercion-based approach used in Gallium [19] and SML/NJ [37] does not support unboxed representations on recursive and mutable objects; the type-passing approach used in TIL <ref> [38] </ref> does handle all data objects, but it involves heavy-weight runtime type analysis and code manipulations. 4.4 Closure Conversion After the polymorphism is eliminated, we use an efficient and safe-for-space closure conversion algorithm [36] to compile the higher-order functions. <p> Typed intermediate languages have gotten a lot of attentions in the ML community lately. Several ML compilers, e.g., Gallium [19], SML/NJ [37], and TIL <ref> [38] </ref>, all maintain explicit type information inside their intermediate languages. Our FLINT compiler is the first that handles the entire SML'97 plus MacQueen-Tofte higher-order modules. Using the predicative polymorphic -calculus to model the type-theoretic semantics of Standard ML was pioneered by Harper and Mitchell [13].
Reference: [39] <author> D. R. Tarditi. </author> <title> Design and Implementation of Code Optimizations for a Type-Directed Compiler for Standard ML. </title> <type> PhD thesis, </type> <institution> School of Computer Science, Carnegie Mellon University, </institution> <address> Pittsburgh, PA, </address> <month> December </month> <year> 1996. </year> <note> Tech Report CMU-CS-97-108. </note>
Reference: [40] <author> P. Wadler. </author> <title> Editorial: A HOT opportunity. </title> <journal> Journal of Functional Programming, </journal> <volume> 2(7), </volume> <year> 1997. </year>
Reference: [41] <author> D. S. Wallach, D. Balfanz, D. Dean, and E. W. Felten. </author> <title> Extensible security architectures for java. </title> <type> Technical Report CS-TR-546-97, </type> <institution> Princeton University, Department of Computer Science, Princeton, NJ, </institution> <month> April </month> <year> 1997. </year>
References-found: 41

