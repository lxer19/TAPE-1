URL: http://www.cs.yale.edu/users/liang-sheng/thesis.ps.gz
Refering-URL: http://www.cs.yale.edu/users/liang-sheng.html
Root-URL: http://www.cs.yale.edu
Title: Abstract Modular Monadic Semantics and Compilation  
Author: Sheng Liang 
Date: 1998  
Affiliation: Yale University  
Abstract: Modular monadic semantics is a high-level and modular form of denotational semantics. It is capable of capturing individual programming language features and their interactions. This thesis explores the theory and applications of modular monadic semantics, including: building blocks for individual programming features, equational reasoning with laws and axioms, modular proofs, program transformation, modular interpreters, and compiler construction. We will demonstrate that the modular monadic semantics framework makes programming languages easy to specify, reason about, and implement. 
Abstract-found: 1
Intro-found: 1
Reference: [Appel and Jim, 1989] <author> Andrew W. Appel and Trevor Jim. </author> <title> Continuation-passing, closure-passing style. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 193-302, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: FUTURE WORK 87 Monad transformers make computational stages somewhat more explicit by separating compile-time features, such as the environment, from run-time features. There have been several successful efforts (including [Kelsey and Hudak, 1989], <ref> [Appel and Jim, 1989] </ref>, and others) to build efficient compilers for higher-order languages by transforming the source language into continuation-passing style (CPS).
Reference: [Appel, 1992] <author> Andrew W. Appel. </author> <title> Compiling with Continuations. </title> <publisher> Cambridge University Press, </publisher> <year> 1992. </year>
Reference-contexts: How to implement a back-end that efficiently supports such target languages has been investigated by a number of compiler research efforts (e.g., the techniques developed for T [Kranz et al., 1986], SML/NJ <ref> [Appel, 1992] </ref>, and Haskell [Peyton Jones, 1992]). Even though we do not tackle the problem of building compiler back-ends, our work provides insights into how we may build a common back-end capable of supporting a variety of source languages. <p> The front-end has already transformed away Haskell's syntactic sugar, carried out type checking, and performed various program analysis (such as strictness analysis) and front-end optimization (such as inlining). The goal of this experiment is to connect the STG language with the SML/NJ back-end <ref> [Appel, 1992] </ref>. We chose the SML/NJ back-end because it provided efficient support for closures, tagged data structures (for implementing algebraic data types), basic control flow (if and case constructs), and garbage collection.
Reference: [Bloss et al., 1988] <author> Adrienne Bloss, Paul Hudak, and Jonathan Young. </author> <title> Code optimization for lazy evaluation. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 1(1) </volume> <pages> 147-164, </pages> <year> 1988. </year>
Reference-contexts: The STG machine only creates one intermediate closure, whereas the SML/NJ back-end creates two closures, one for each of the first two arguments. Because the SML/NJ back-end does not support updatable closures, we implement lazy evaluation using the cell mode <ref> [Bloss et al., 1988] </ref>. Figure 5.2 gives an example of how an expression (factorial of 3) is delayed and cached in the cell mode. To create a delayed computation, we allocate a two-element cell.
Reference: [Bondorf and Palsberg, 1993] <author> Anders Bondorf and Jens Palsberg. </author> <title> Compiling actions by partial evaluation. </title> <booktitle> In FPCA '93: Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pages 308-317, </pages> <address> New York, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: One application of partial evaluation [Jones et al., 1989] is to generate compilers from interpreters. A partial evaluator has been successfully applied to an action interpreter <ref> [Bondorf and Palsberg, 1993] </ref>, and similar results can be achieved with monadic interpreters [Danvy et al., 1991] as well. Staging transformations [Jrring and Scherlis, 1986] are a class of general program transformation techniques for separating a given computation into stages. 6.2.
Reference: [Cl ement et al., 1986] <author> D. Cl ement, Jo elle Despeyroux, Thierry Despeyroux, and Gilles Kahn. </author> <title> A simple applicative language: </title> <booktitle> Mini-ML. In Proceedings of the 1986 ACM Symposium on Lisp and Functional Programming, </booktitle> <pages> pages 13-27, </pages> <year> 1986. </year>
Reference-contexts: Following Wand [Wand, 1990], we define a natural semantics that translates source language variables to lexical variables in the meta-language, and we prove that it is equivalent to the standard semantics. 5.2.1 Definition of a Natural Semantics We adopt Wand's definition of a natural semantics (which differs from Kahn's notion <ref> [Cl ement et al., 1986] </ref>) to our functional sub-language. For any source language variable name v, we assume there is a corresponding variable name v in the meta-language, and is an environment that maps variable name v to v.
Reference: [Clinger and Rees, 1991] <author> William Clinger and Jonathan Rees. </author> <title> Revised 4 report on the algorithmic language Scheme. </title> <note> Available via World Wide Web as http://www-swiss.ai.mit.edu/ftpdir/scheme-reports/r4rs.ps, November 1991. </note>
Reference-contexts: Modular monadic semantics can be implemented using modern programming languages such as Haskell [Hudak et al., 1992], ML [Milner et al., 1990], or Scheme <ref> [Clinger and Rees, 1991] </ref>. The result is a modular interpreter. We have discovered that the relatively new idea of constructor classes in Gofer (and Haskell 1.3) are particularly suitable for representing some rather complex typing relationships in modular interpreters. Our work is directly applicable to semantics-directed compiler construction. <p> For this reason, callcc can be used to model a wide variety of non-local control flow, including, for example, catch/throw, error handling, coroutines, and thread context switches. Scheme <ref> [Clinger and Rees, 1991] </ref> and SML [Milner et al., 1990] incorporate callcc as a language feature.
Reference: [Danvy et al., 1991] <author> Olivier Danvy, J urgen Koslowski, and Karoline Malmkjr. </author> <title> Compiling monads. </title> <type> Technical Report CIS-92-3, </type> <institution> Kansas State University, </institution> <month> December </month> <year> 1991. </year>
Reference-contexts: One application of partial evaluation [Jones et al., 1989] is to generate compilers from interpreters. A partial evaluator has been successfully applied to an action interpreter [Bondorf and Palsberg, 1993], and similar results can be achieved with monadic interpreters <ref> [Danvy et al., 1991] </ref> as well. Staging transformations [Jrring and Scherlis, 1986] are a class of general program transformation techniques for separating a given computation into stages. 6.2. FUTURE WORK 87 Monad transformers make computational stages somewhat more explicit by separating compile-time features, such as the environment, from run-time features.
Reference: [Espinosa, 1993] <author> David Espinosa. </author> <title> Modular denotational semantics. </title> <type> Unpublished manuscript, </type> <month> December </month> <year> 1993. </year> <note> 89 90 BIBLIOGRAPHY </note>
Reference-contexts: Early work by Wadler [Wadler, 1990] showed the relationships between monads and functional programming. Recently, there has been a great deal of interest in using monads to construct modular semantics and modular interpreters [Wadler, 1992] [Jones and Duponcheel, 1993] <ref> [Espinosa, 1993] </ref> [Steele Jr., 1994]. In Chapter 2, we will present the modular monadic semantics for a wide range of programming language features. We will demonstrate how monad transformers capture individual features, and how liftings capture the interactions between different features. <p> However, implementing pseudomonads in the Haskell [Hudak et al., 1992] type system turned out to be problematic. Returning to Moggi's original ideas, Espinosa formulated a system called Semantic Lego <ref> [Espinosa, 1993] </ref> [Espinosa, 1995]. Espinosa's Scheme-based system was the first modular interpreter that incorporated monad transformers. Among his contributions, Espinosa pointed out that pseudomonads were really just a special kind of monad transformer, first suggested by Moggi as a way to leave a hole in a monad for further extension.
Reference: [Espinosa, 1994] <author> David Espinosa. </author> <title> Building interpreters by transforming stratified monads. </title> <type> Unpublished manuscript, </type> <note> ftp from alt-dorf.ai.mit.edu:pub/dae, </note> <month> June </month> <year> 1994. </year>
Reference-contexts: Related approaches to enhance modularity include composing monads [Jones and Duponcheel, 1993] and stratified monads <ref> [Espinosa, 1994] </ref>.
Reference: [Espinosa, 1995] <author> David Espinosa. </author> <title> Semantic Lego. </title> <type> PhD thesis, </type> <institution> Columbia University, </institution> <year> 1995. </year>
Reference-contexts: However, implementing pseudomonads in the Haskell [Hudak et al., 1992] type system turned out to be problematic. Returning to Moggi's original ideas, Espinosa formulated a system called Semantic Lego [Espinosa, 1993] <ref> [Espinosa, 1995] </ref>. Espinosa's Scheme-based system was the first modular interpreter that incorporated monad transformers. Among his contributions, Espinosa pointed out that pseudomonads were really just a special kind of monad transformer, first suggested by Moggi as a way to leave a hole in a monad for further extension.
Reference: [Felleisen and Hieb, 1992] <author> Matthias Felleisen and Robert Hieb. </author> <title> The revised report on the syntactic theories of sequential control and state. </title> <journal> Theoretical Computer Science, </journal> <volume> 103 </volume> <pages> 235-271, </pages> <year> 1992. </year>
Reference-contexts: The environment axioms provide an answer to the question: what constitutes an environment? We expect that useful monadic axioms can be derived for other features, following the earlier efforts on state [Hudak and Bloss, 1985] [Peyton Jones and Wadler, 1993] [Hudak, 1992], continuations [Felleisen et al., 1986] <ref> [Felleisen and Hieb, 1992] </ref> and exceptions [Spivey, 1990]. 3.3 Natural Liftings In this section, we investigate what conditions a desirable lifting must satisfy. First we will formalize how types are transformed in the lifting process.
Reference: [Felleisen et al., 1986] <author> Matthias Felleisen, Daniel P. Friedman, Eugene Kohlbecker, and Bruce Duba. </author> <title> Reasoning with continuations. </title> <booktitle> In Proceedings of the Symposium on Logic in Computer Science, </booktitle> <pages> pages 131-141, </pages> <address> Cambridge, Massachusetts, </address> <month> June </month> <year> 1986. </year> <note> IEEE. </note>
Reference-contexts: The environment axioms provide an answer to the question: what constitutes an environment? We expect that useful monadic axioms can be derived for other features, following the earlier efforts on state [Hudak and Bloss, 1985] [Peyton Jones and Wadler, 1993] [Hudak, 1992], continuations <ref> [Felleisen et al., 1986] </ref> [Felleisen and Hieb, 1992] and exceptions [Spivey, 1990]. 3.3 Natural Liftings In this section, we investigate what conditions a desirable lifting must satisfy. First we will formalize how types are transformed in the lifting process.
Reference: [Gosling et al., 1996] <author> James Gosling, Bill Joy, and Guy Steele. </author> <title> The Java TM Programming Language. The Java Series. </title> <publisher> Addison-Wesley, </publisher> <year> 1996. </year>
Reference-contexts: We can further develop our monadic semantics based compilation method into a compiler construction tool for a common back-end. 6.2.4 Concurrency Concurrency is an important feature in many modern languages such as Java TM <ref> [Gosling et al., 1996] </ref>. The monadic framework covers the properties of callcc.
Reference: [Hatcliff and Danvy, 1994] <author> John Hatcliff and Olivier Danvy. </author> <title> A generic account of continuation-passing styles. </title> <booktitle> In 21st ACM Symposium on Principles of Programming Languages (POPL '94), Portland, Oregon, </booktitle> <pages> pages 458-471, </pages> <address> New York, </address> <month> January </month> <year> 1994. </year> <note> ACM Press. </note>
Reference-contexts: The suitability of a monadic form as an intermediate form has been observed by many researchers (including, for example, [Sabry and Felleisen, 1992] and <ref> [Hatcliff and Danvy, 1994] </ref>). 6.2 Future Work 6.2.1 Theory of Programming Language Features We have used monads and monad transformers to study programming language features and their interactions. Plenty of work remains on extending the theory to handle other useful features we have not covered.
Reference: [Hudak and Bloss, 1985] <author> Paul Hudak and Adriene Bloss. </author> <title> The aggregate update problem in functional programming languages. </title> <booktitle> In Conference Record of the Twelfth ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 300-314. </pages> <institution> Association for Computing Machinery, </institution> <month> January </month> <year> 1985. </year>
Reference-contexts: The environment axioms provide an answer to the question: what constitutes an environment? We expect that useful monadic axioms can be derived for other features, following the earlier efforts on state <ref> [Hudak and Bloss, 1985] </ref> [Peyton Jones and Wadler, 1993] [Hudak, 1992], continuations [Felleisen et al., 1986] [Felleisen and Hieb, 1992] and exceptions [Spivey, 1990]. 3.3 Natural Liftings In this section, we investigate what conditions a desirable lifting must satisfy.
Reference: [Hudak et al., 1992] <editor> Paul Hudak, Simon Peyton Jones, and Philip Wadler. </editor> <title> Report on the programming language Haskell: a non-strict, purely functional language, version 1.2. </title> <type> Technical Report YALEU/DCS/RR-777, </type> <institution> Yale University Department of Computer Science, </institution> <month> March </month> <year> 1992. </year> <journal> Also in ACM SIGPLAN Notices, </journal> <volume> Vol. 27(5), </volume> <month> May </month> <year> 1992. </year>
Reference-contexts: In addition, we will show that modular monadic semantics further facilitates reasoning by allowing us to specify axioms of programming language features and to construct reusable modular proofs. Modular monadic semantics can be implemented using modern programming languages such as Haskell <ref> [Hudak et al., 1992] </ref>, ML [Milner et al., 1990], or Scheme [Clinger and Rees, 1991]. The result is a modular interpreter. We have discovered that the relatively new idea of constructor classes in Gofer (and Haskell 1.3) are particularly suitable for representing some rather complex typing relationships in modular interpreters. <p> Chapter 4 Modular Monadic Interpreters We can transform a denotational semantics description into an executable interpreter by translating the mathematical notations into corresponding programming constructs. Modern functional languages such as Haskell <ref> [Hudak et al., 1992] </ref> or SML [Milner et al., 1990] are particularly suitable because these languages offer features such as algebraic data types and higher-order functions that match well with the mathematical notations used in denotational semantics. <p> RELATED WORK 85 modular interpreters [Wadler, 1992]. Wadler [King and Wadler, 1993] discussed the issues in combining monads. Pseudomonads [Steele Jr., 1994] were proposed as a way to compose monads and thus build up an interpreter from smaller parts. However, implementing pseudomonads in the Haskell <ref> [Hudak et al., 1992] </ref> type system turned out to be problematic. Returning to Moggi's original ideas, Espinosa formulated a system called Semantic Lego [Espinosa, 1993] [Espinosa, 1995]. Espinosa's Scheme-based system was the first modular interpreter that incorporated monad transformers.
Reference: [Hudak, 1992] <author> Paul Hudak. </author> <title> Mutable abstract datatypes. </title> <institution> Research Report YALEU/DCS/RR-914, Yale University Department of Computer Science, </institution> <month> December </month> <year> 1992. </year> <note> BIBLIOGRAPHY 91 </note>
Reference-contexts: The environment axioms provide an answer to the question: what constitutes an environment? We expect that useful monadic axioms can be derived for other features, following the earlier efforts on state [Hudak and Bloss, 1985] [Peyton Jones and Wadler, 1993] <ref> [Hudak, 1992] </ref>, continuations [Felleisen et al., 1986] [Felleisen and Hieb, 1992] and exceptions [Spivey, 1990]. 3.3 Natural Liftings In this section, we investigate what conditions a desirable lifting must satisfy. First we will formalize how types are transformed in the lifting process. <p> The monadic framework has been used to specify state monad laws [Wadler, 1990], and to reason about exceptions [Spivey, 1990]. A related, but more general, framework to reason about states is mutable abstract data types (MADTs) <ref> [Hudak, 1992] </ref>. This thesis extends previous work by presenting the environment axioms [Liang 86 CHAPTER 6. RELATED WORK, FUTURE WORK AND CONCLUSION and Hudak, 1996].
Reference: [Jones and Duponcheel, 1993] <author> Mark P. Jones and Luc Duponcheel. </author> <title> Composing monads. </title> <institution> Research Report YALEU/DCS/RR-1004, Yale University Department of Computer Science, </institution> <address> New Haven, Con-necticut, </address> <month> December </month> <year> 1993. </year>
Reference-contexts: Early work by Wadler [Wadler, 1990] showed the relationships between monads and functional programming. Recently, there has been a great deal of interest in using monads to construct modular semantics and modular interpreters [Wadler, 1992] <ref> [Jones and Duponcheel, 1993] </ref> [Espinosa, 1993] [Steele Jr., 1994]. In Chapter 2, we will present the modular monadic semantics for a wide range of programming language features. We will demonstrate how monad transformers capture individual features, and how liftings capture the interactions between different features. <p> Some of these (StateT, ContT, and ErrorT) appear in an abstract form in Moggi's note [Moggi, 1990]. The environment monad is similar to the state reader by Wadler [Wadler, 1990]. The state and environment monad transformers are related to ideas found in Jones and Duponcheel's work [Jones, 1993] <ref> [Jones and Duponcheel, 1993] </ref>. 2.3. MONAD TRANSFORMERS 21 We will attach subscripts to monadic operations to distinguish between the different monads they operate on. Some monad transformers use two additional functions: map and join. <p> It is known that lists compose with a special kind of monads called commutative monads <ref> [Jones and Duponcheel, 1993] </ref>. It is not clear, however, if lists compose with arbitrary monads. Since many useful monads (e.g. state, error and continuation monads) are not commutative, we cannot define a list monad transformerone which adds the operation merge to any monad. <p> The type constructors listed in Figure 2.2 satisfy the above definition. Proposition 3.1.2 EnvT r, StateT s, ErrT, and ContT c are monad transformers. It is well known that these type constructors transform monads to monads. EnvT r is the composable reader monad presented in <ref> [Jones and Duponcheel, 1993] </ref>. The remaining three were discovered by Moggi [Moggi, 1990]. Appendix A contains detailed proofs that the corresponding lift functions are indeed monad morphisms. Monad transformers compose with each other (a property that follows immediately from the definition of monad morphisms): 36 CHAPTER 3. <p> Espinosa's work reminded the programming language communitywho had become distracted by the use of monadsthat Moggi himself, responsible in many ways for the interest in monadic programming, had actually focussed more on the importance of monad transformers. Related approaches to enhance modularity include composing monads <ref> [Jones and Duponcheel, 1993] </ref> and stratified monads [Espinosa, 1994].
Reference: [Jones et al., 1989] <author> Neil D. Jones, Peter Sestoft, and Harald Sndergaard. </author> <title> Mix: a self-applicable partial evaluator for experiments in compiler generation. </title> <journal> Lisp and Symbolic Computation, </journal> <volume> 2 </volume> <pages> 9-50, </pages> <year> 1989. </year>
Reference-contexts: A related approach [Meijer] is to combine the standard initial algebra semantics approach with aspects of Action Semantics to derive compilers from denotational semantics. One application of partial evaluation <ref> [Jones et al., 1989] </ref> is to generate compilers from interpreters. A partial evaluator has been successfully applied to an action interpreter [Bondorf and Palsberg, 1993], and similar results can be achieved with monadic interpreters [Danvy et al., 1991] as well.
Reference: [Jones, 1991] <author> Mark P. Jones. </author> <note> Introduction to gofer 2.20. Ftp from nebula.cs.yale.edu in the directory pub/haskell/gofer, Septem-ber 1991. </note>
Reference-contexts: We will use monad laws and axioms to perform equational reasoning at a higher level than in traditional denotational semantics. In Chapter 4, we will demonstrate how the formal concepts of monads and monad transformers fit nicely into the Gofer <ref> [Jones, 1991] </ref> type system. By implementing modular monadic semantics in Gofer, we obtain a modular interpreter. In Chapter 5, we will apply monadic semantics to semantics-directed compilation. <p> Although the Haskell type system can implement individual monads and monad transformers as type constructors, modular monadic semantics requires the type system to capture relationships among different monads and monad transformers. We have successfully implemented a modular monadic interpreter in Gofer <ref> [Jones, 1991] </ref>, whose constructor classes and multi-parameter type classes provide just the added power over Haskell's type classes 1 to allow precise and convenient 1 The newly defined Haskell 1.3 [Peterson and Hammond, 1996] supports constructor classes 47 48 CHAPTER 4. <p> In addition, we have shown how liftings capture the interactions between vari ous programming language features. * We have implementationed modular semantic building blocks and monad transformers in Gofer <ref> [Jones, 1991] </ref>. This is the first implementation of a full-featured modular monadic interpreter using a strongly-typed language. * We have investigated high-level monadic properties of programming language features (for example, the environment axioms).
Reference: [Jones, 1993] <author> Mark P. Jones. </author> <title> A system of constructor classes: Overloading and implicit higher-order polymorphism. </title> <booktitle> In FPCA '93: Conference on Functional Programming Languages and Computer Architecture, Copenhagen, Denmark, </booktitle> <pages> pages 52-61, </pages> <address> New York, June 1993. </address> <publisher> ACM Press. </publisher>
Reference-contexts: Some of these (StateT, ContT, and ErrorT) appear in an abstract form in Moggi's note [Moggi, 1990]. The environment monad is similar to the state reader by Wadler [Wadler, 1990]. The state and environment monad transformers are related to ideas found in Jones and Duponcheel's work <ref> [Jones, 1993] </ref> [Jones and Duponcheel, 1993]. 2.3. MONAD TRANSFORMERS 21 We will attach subscripts to monadic operations to distinguish between the different monads they operate on. Some monad transformers use two additional functions: map and join. <p> They can be similarly translated from the corresponding monadic semantics. Before discussing how to implement the monad transformers needed to construct the interpreter monad M, we introduce Gofer's constructor classes through a motivating example. 4.3 Constructor Classes Constructor classes <ref> [Jones, 1993] </ref> support abstraction of common features among type constructors. <p> where map f (Leaf x) = Leaf (f x) map f (Node l r) = Node (map f l) (map f r) Constructor classes are extremely useful for dealing with multiple instances of monads and monad transformers (which are all type constructors). 4.4 Monads We follow a well known approach <ref> [Jones, 1993] </ref> to define monads using a constructor class: class Monad m where return :: a -&gt; m a bind :: m a -&gt; (a -&gt; m b) -&gt; m b map :: (a -&gt; b) -&gt; (m a -&gt; m b) join :: m (m a) -&gt; m a map
Reference: [Jrring and Scherlis, 1986] <author> Ulrik Jrring and William Scherlis. </author> <title> Compilers and staging transformations. </title> <booktitle> In Proceedings Thirteenth ACM Symposium on Principles of Programming Languages, </booktitle> <address> St. Petersburg, Florida, </address> <pages> pages 86-96, </pages> <year> 1986. </year>
Reference-contexts: One application of partial evaluation [Jones et al., 1989] is to generate compilers from interpreters. A partial evaluator has been successfully applied to an action interpreter [Bondorf and Palsberg, 1993], and similar results can be achieved with monadic interpreters [Danvy et al., 1991] as well. Staging transformations <ref> [Jrring and Scherlis, 1986] </ref> are a class of general program transformation techniques for separating a given computation into stages. 6.2. FUTURE WORK 87 Monad transformers make computational stages somewhat more explicit by separating compile-time features, such as the environment, from run-time features.
Reference: [Kelsey and Hudak, 1989] <author> Richard Kelsey and Paul Hudak. </author> <title> Realistic compilation by program transformation. </title> <booktitle> In ACM Symposium on Principles of Programming Languages, </booktitle> <pages> pages 181-192, </pages> <month> January </month> <year> 1989. </year>
Reference-contexts: FUTURE WORK 87 Monad transformers make computational stages somewhat more explicit by separating compile-time features, such as the environment, from run-time features. There have been several successful efforts (including <ref> [Kelsey and Hudak, 1989] </ref>, [Appel and Jim, 1989], and others) to build efficient compilers for higher-order languages by transforming the source language into continuation-passing style (CPS).
Reference: [King and Wadler, 1993] <author> David J. King and Philip Wadler. </author> <title> Combining monads. </title> <editor> In John Launchbury and Patrick Sansom, editors, </editor> <booktitle> Functional Programming, Glasgow 1992, </booktitle> <pages> pages 134-143, </pages> <address> New York, 1993. </address> <publisher> Springer-Verlag. </publisher>
Reference-contexts: In general we can swap the ordering of some monad transformers (such as between StateT and EnvT), but doing so to others (such as ContT) may effect semantics. This is consistent with earlier experience in combining monads <ref> [King and Wadler, 1993] </ref>, and, in practice, provides us with an opportunity to fine tune the resulting semantics. Chapter 4 Modular Monadic Interpreters We can transform a denotational semantics description into an executable interpreter by translating the mathematical notations into corresponding programming constructs. <p> Wadler popularized Moggi's ideas in the functional programming community by showing how monads could be used in a variety of settings, including incorporating imperative features [Peyton Jones and Wadler, 1993] and building 6.1. RELATED WORK 85 modular interpreters [Wadler, 1992]. Wadler <ref> [King and Wadler, 1993] </ref> discussed the issues in combining monads. Pseudomonads [Steele Jr., 1994] were proposed as a way to compose monads and thus build up an interpreter from smaller parts. However, implementing pseudomonads in the Haskell [Hudak et al., 1992] type system turned out to be problematic.
Reference: [Kishon et al., 1991] <author> Amir Kishon, Paul Hudak, and Charles Consel. </author> <title> Monitoring semantics: A formal framework for specifying, implementing and reasoning about execution monitors. </title> <booktitle> In Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design and Implementation, </booktitle> <pages> pages 338-352, </pages> <month> June </month> <year> 1991. </year>
Reference-contexts: Labels attached to expressions cause a trace record to be invoked whenever that expression is evaluated: E [[l @ e]] = f output (enter ++l); v E [[e]]; output (leave ++l); return v g Here we see that some of the features of monitoring semantics <ref> [Kishon et al., 1991] </ref> are easily incorporated into our framework. 2.1.6 The Continuation Building Block Continuation is a powerful mechanism for modeling control flow in denotational semantics. In particular, callcc (call with current continuation) is a useful language construct.
Reference: [Kranz et al., 1986] <author> David Kranz, Richard Kelsey, Jonathan Rees, Paul Hudak, James Philbin, and Norman Adams. </author> <title> ORBIT: An optimizing compiler for Scheme. </title> <booktitle> In Proceedings SIGPLAN '86 Symposium 92 BIBLIOGRAPHY on Compiler Construction, </booktitle> <pages> pages 219-233, </pages> <month> July </month> <year> 1986. </year> <journal> SIGPLAN Notices Volume 21, </journal> <volume> Number 7. </volume>
Reference-contexts: How to implement a back-end that efficiently supports such target languages has been investigated by a number of compiler research efforts (e.g., the techniques developed for T <ref> [Kranz et al., 1986] </ref>, SML/NJ [Appel, 1992], and Haskell [Peyton Jones, 1992]). Even though we do not tackle the problem of building compiler back-ends, our work provides insights into how we may build a common back-end capable of supporting a variety of source languages.
Reference: [Lee, 1989] <author> Peter Lee. </author> <title> Realistic Compiler Generation. </title> <booktitle> Foundations of Computing. </booktitle> <publisher> MIT Press, </publisher> <year> 1989. </year>
Reference-contexts: For example, advances in denotational semantics have led to clarifications of features, to more consistent programming language design, and to new programming constructs. It has long been recognized, however, that traditional denotational semantics lacks modularity and extensibility [Mosses, 1984] <ref> [Lee, 1989] </ref>. This is regarded as a major obstacle in applying denotational semantics to realistic programming languages. In this thesis, we take advantage of a new development in programming language theorya monadic approach [Moggi, 1990] to structured denotational semantics. <p> The lack of modularity of traditional denotational semantics has long been recognized [Mosses, 1984] 4 CHAPTER 1. INTRODUCTION <ref> [Lee, 1989] </ref>. It is regarded as the most significant obstacle in applying denotational semantics to realistic languages. <p> Related Work Our work is built on a number of previous attempts to better organize modular semantics, to more effectively reason about programming languages, and to more efficiently compile higher-order programs. 6.1.1 Modular Semantics The lack of modularity of traditional denotational semantics [Stoy, 1977] has long been recognized [Mosses, 1984] <ref> [Lee, 1989] </ref>. Moggi first proposed to use monads and monad transformers to structure denota-tional semantics. Wadler popularized Moggi's ideas in the functional programming community by showing how monads could be used in a variety of settings, including incorporating imperative features [Peyton Jones and Wadler, 1993] and building 6.1. <p> The resulting compilers were inefficient. Action Semantics [Mosses, 1992] allows modular specification of programming language semantics. Action semantics and a related approach <ref> [Lee, 1989] </ref> have been successfully used to generate efficient compilers.
Reference: [Liang and Hudak, 1996] <author> Sheng Liang and Paul Hudak. </author> <title> Modular denotational semantics for compiler construction. </title> <editor> In Hanne Riis Nielson, editor, </editor> <booktitle> ESOP '96: 6th European Symposium on Programming, Linkoping, Sweden, Proceedings, </booktitle> <pages> pages 219-234, </pages> <address> New York, </address> <month> April </month> <year> 1996. </year> <note> Springer-Verlag. Lecture Notes in Computer Science 1058. </note>
Reference: [Liang et al., 1995] <author> Sheng Liang, Paul Hudak, and Mark Jones. </author> <title> Monad transformers and modular interpreters. </title> <booktitle> In 22nd ACM Symposium on Principles of Programming Languages (POPL '95), </booktitle> <address> San Fran-cisco, California, New York, </address> <month> January </month> <year> 1995. </year> <note> ACM Press. </note>
Reference-contexts: In our framework, depending on how much support the upper layers need, any set of primitive operations can be put together in a modular way using an abstraction mechanism called monad transformers [Moggi, 1990] <ref> [Liang et al., 1995] </ref>. Monad transformers provide the power needed to represent the abstract notion of programming language features, but still allow us to access low-level semantic details. <p> Related approaches to enhance modularity include composing monads [Jones and Duponcheel, 1993] and stratified monads [Espinosa, 1994]. This thesis was motivated by the above line of work, which led to the solution <ref> [Liang et al., 1995] </ref> of a number of open issues in how to lift operations through monad transformers, as well as how to implement modular interpreters in a strongly-typed language. 6.1.2 Reasoning with Monads In his original note [Moggi, 1990], Moggi raised the issue of reasoning in the monadic framework.
Reference: [Mac Lane, 1971] <author> Saunders Mac Lane. </author> <title> Categories for the Working Mathematician. Graduate Texts in Mathematics. </title> <publisher> Springer-Verlag, </publisher> <year> 1971. </year>
Reference-contexts: INTRODUCTION 1.4 Background and Organization of the Thesis This thesis explores the theory and practical applications of monads and monadic semantics, building on the previous work in this area. The concept of monads originates from category theory <ref> [Mac Lane, 1971] </ref>. The formulation of monads using a triple (bind, return, and the type constructor) is due to Kleisli. Moggi [Moggi, 1990] first proposed that monads provided a useful tool for structuring denotational semantics. Early work by Wadler [Wadler, 1990] showed the relationships between monads and functional programming.
Reference: [Meijer] <author> Erik Meijer. </author> <title> More advice on proving a compiler correct: Improving a correct compiler. </title> <note> Submitted to Journal of Functional Programming. </note>
Reference-contexts: Our work essentially attempts to formulate actions in a denotational semantics framework. Monad transformers roughly correspond to facets in action semantics, although issues such as concurrency are beyond the power of our approach. A related approach <ref> [Meijer] </ref> is to combine the standard initial algebra semantics approach with aspects of Action Semantics to derive compilers from denotational semantics. One application of partial evaluation [Jones et al., 1989] is to generate compilers from interpreters.
Reference: [Milner et al., 1990] <author> Robin Milner, Mads Tofte, and Robert Harper. </author> <title> The Definition of Standard ML. </title> <publisher> MIT Press, </publisher> <year> 1990. </year>
Reference-contexts: In addition, we will show that modular monadic semantics further facilitates reasoning by allowing us to specify axioms of programming language features and to construct reusable modular proofs. Modular monadic semantics can be implemented using modern programming languages such as Haskell [Hudak et al., 1992], ML <ref> [Milner et al., 1990] </ref>, or Scheme [Clinger and Rees, 1991]. The result is a modular interpreter. We have discovered that the relatively new idea of constructor classes in Gofer (and Haskell 1.3) are particularly suitable for representing some rather complex typing relationships in modular interpreters. <p> For this reason, callcc can be used to model a wide variety of non-local control flow, including, for example, catch/throw, error handling, coroutines, and thread context switches. Scheme [Clinger and Rees, 1991] and SML <ref> [Milner et al., 1990] </ref> incorporate callcc as a language feature. <p> Chapter 4 Modular Monadic Interpreters We can transform a denotational semantics description into an executable interpreter by translating the mathematical notations into corresponding programming constructs. Modern functional languages such as Haskell [Hudak et al., 1992] or SML <ref> [Milner et al., 1990] </ref> are particularly suitable because these languages offer features such as algebraic data types and higher-order functions that match well with the mathematical notations used in denotational semantics.
Reference: [Moggi, 1990] <author> Eugenio Moggi. </author> <title> An abstract view of programming languages. </title> <type> Technical Report ECS-LFCS-90-113, </type> <institution> Laboratory for Foundations of Computer Science, University of Edinburgh, Edinburgh, </institution> <address> Scotland, </address> <year> 1990. </year>
Reference-contexts: It has long been recognized, however, that traditional denotational semantics lacks modularity and extensibility [Mosses, 1984] [Lee, 1989]. This is regarded as a major obstacle in applying denotational semantics to realistic programming languages. In this thesis, we take advantage of a new development in programming language theorya monadic approach <ref> [Moggi, 1990] </ref> to structured denotational semantics. The resulting modular monadic semantics achieves a high level of modularity and extensibility. It is able to capture individual programming language features in reusable building blocks, and to specify programming languages by composing the necessary features. 1 2 CHAPTER 1. <p> The concept of monads originates from category theory [Mac Lane, 1971]. The formulation of monads using a triple (bind, return, and the type constructor) is due to Kleisli. Moggi <ref> [Moggi, 1990] </ref> first proposed that monads provided a useful tool for structuring denotational semantics. Early work by Wadler [Wadler, 1990] showed the relationships between monads and functional programming. <p> In our framework, depending on how much support the upper layers need, any set of primitive operations can be put together in a modular way using an abstraction mechanism called monad transformers <ref> [Moggi, 1990] </ref> [Liang et al., 1995]. Monad transformers provide the power needed to represent the abstract notion of programming language features, but still allow us to access low-level semantic details. <p> f update ( sofar:sofar ++ msg); return ()g The underscore ( ) indicates that the return value of update is ignored. 2.3 Monad Transformers To get an intuitive understanding of monad transformers, consider the merging of a state monad with an arbitrary monad, an example originally appeared in Moggi's note <ref> [Moggi, 1990] </ref>: type StateT s m a = s ! m (s; a) The type variable m represents a type constructor. We will later show that, if m is a monad, then so is StateT s m. Therefore StateT s is a monad transformer. <p> The remainder of this section introduces the monad transformers that cover all the features listed in Table 2.1. Some of these (StateT, ContT, and ErrorT) appear in an abstract form in Moggi's note <ref> [Moggi, 1990] </ref>. The environment monad is similar to the state reader by Wadler [Wadler, 1990]. The state and environment monad transformers are related to ideas found in Jones and Duponcheel's work [Jones, 1993] [Jones and Duponcheel, 1993]. 2.3. <p> For example, lifting: inEnv : r ! m a ! m a through t results in an operation with type: inEnv : r ! t m a ! t m a Moggi <ref> [Moggi, 1990] </ref> studied the problem of lifting under a categorical context. The objective was to identify liftable operations from their type signatures. Unfortunately, many useful operations such as merge, inEnv and callcc failed to meet Moggi's criteria, and were left unsolved. <p> For any monad transformer t applied to monad m, we have: 3 An example of the features we cannot model is concurrent computation in multi-threaded programs. In addition, the state monad transformer is more general than what is needed to model output. The output monad transformer <ref> [Moggi, 1990] </ref> is also able to support the output operation: type OutputT m a = m (String; a) return OutputT m x = return m (" "; x) bind OutputT m m k = f (o 1 ; a) m; (o 2 ; b) k a; return m (o 1 ++ <p> Monads must satisfy the following laws <ref> [Moggi, 1990] </ref>: fb return a; k bg = k a (left unit) fa e; return ag = e (right unit) fv 1 e 1 ; fv 2 e 2 ; e 3 gg = fv 2 fv 1 e 1 ; e 2 g; e 3 g (associativity) Intuitively, the (left <p> The type constructors Id and List introduced in Chapter 2 are well-known mon-ads (presented in, for example, [Wadler, 1990]): Proposition 3.1.1 Id and List are monads. 3.1. MONAD AND MONAD TRANSFORMERS 35 3.1.2 Monad Transformers To capture monad transformers formally, we first introduce monad morphisms <ref> [Moggi, 1990] </ref>: Definition 3.1.2 A monad morphism f between monads m and m 0 is a function of type: f : m a ! m 0 a satisfying: f: return m = return m 0 f (bind m m k) = bind m 0 (f m) (f k) Note that f <p> Proposition 3.1.2 EnvT r, StateT s, ErrT, and ContT c are monad transformers. It is well known that these type constructors transform monads to monads. EnvT r is the composable reader monad presented in [Jones and Duponcheel, 1993]. The remaining three were discovered by Moggi <ref> [Moggi, 1990] </ref>. Appendix A contains detailed proofs that the corresponding lift functions are indeed monad morphisms. Monad transformers compose with each other (a property that follows immediately from the definition of monad morphisms): 36 CHAPTER 3. <p> The easy cases (update, err and rdEnv) are covered by the following theorem by Moggi <ref> [Moggi, 1990] </ref>: Proposition 3.3.1 If function f's domain does not involve any monadic type, then: lift t f is a natural lifting of f through any monad transformer t. Since the domain type (call it t ) does not involve the monad, the lifting of t is t itself. <p> Although each of these features has been modeled using monads before, it is the first time all of them fit into a single modular framework. * We have solved a number of open problems in how to lift operations through monad transformers. We have extended Moggi's <ref> [Moggi, 1990] </ref> natural lift 83 84 CHAPTER 6. RELATED WORK, FUTURE WORK AND CONCLUSION ing condition to higher-order types, making it possible to reason about the relatively complex operations related to environment and continuation. <p> motivated by the above line of work, which led to the solution [Liang et al., 1995] of a number of open issues in how to lift operations through monad transformers, as well as how to implement modular interpreters in a strongly-typed language. 6.1.2 Reasoning with Monads In his original note <ref> [Moggi, 1990] </ref>, Moggi raised the issue of reasoning in the monadic framework. The monadic framework has been used to specify state monad laws [Wadler, 1990], and to reason about exceptions [Spivey, 1990]. A related, but more general, framework to reason about states is mutable abstract data types (MADTs) [Hudak, 1992].
Reference: [Mosses, 1984] <author> Peter D. Mosses. </author> <title> A basic abstract semantic algebra. </title> <editor> In Gilles Kahn, David B. MacQueen, and Gordon D. Plotkin, editors, </editor> <booktitle> Semantics of Data Types: International Symposium, Sophia-Antipolis, France, </booktitle> <pages> pages 87-107. </pages> <publisher> Springer-Verlag, </publisher> <month> June </month> <year> 1984. </year> <note> Lecture Notes in Computer Science 173. </note>
Reference-contexts: For example, advances in denotational semantics have led to clarifications of features, to more consistent programming language design, and to new programming constructs. It has long been recognized, however, that traditional denotational semantics lacks modularity and extensibility <ref> [Mosses, 1984] </ref> [Lee, 1989]. This is regarded as a major obstacle in applying denotational semantics to realistic programming languages. In this thesis, we take advantage of a new development in programming language theorya monadic approach [Moggi, 1990] to structured denotational semantics. <p> The lack of modularity of traditional denotational semantics has long been recognized <ref> [Mosses, 1984] </ref> 4 CHAPTER 1. INTRODUCTION [Lee, 1989]. It is regarded as the most significant obstacle in applying denotational semantics to realistic languages. <p> semantics. 6.1 Related Work Our work is built on a number of previous attempts to better organize modular semantics, to more effectively reason about programming languages, and to more efficiently compile higher-order programs. 6.1.1 Modular Semantics The lack of modularity of traditional denotational semantics [Stoy, 1977] has long been recognized <ref> [Mosses, 1984] </ref> [Lee, 1989]. Moggi first proposed to use monads and monad transformers to structure denota-tional semantics. Wadler popularized Moggi's ideas in the functional programming community by showing how monads could be used in a variety of settings, including incorporating imperative features [Peyton Jones and Wadler, 1993] and building 6.1.
Reference: [Mosses, 1992] <author> Peter D. Mosses. </author> <title> Action Semantics, </title> <booktitle> volume 26 of Cambridge Tracts in Theoretical Computer Science. </booktitle> <publisher> Cambridge University Press, </publisher> <year> 1992. </year> <note> BIBLIOGRAPHY 93 </note>
Reference-contexts: In addition, we demonstrate how these axioms, together with monad laws, can be used to reason about programs in a modular way. 6.1.3 Semantics-directed Compilation Early efforts [Wand, 1984] [Paulson, 1982] were based on traditional denotational semantics. The resulting compilers were inefficient. Action Semantics <ref> [Mosses, 1992] </ref> allows modular specification of programming language semantics. Action semantics and a related approach [Lee, 1989] have been successfully used to generate efficient compilers. While action semantics is easy to construct, extend, understand and implement, we note the following comments ([Mosses, 1992], page 5): Although the foundations of action semantics
Reference: [Partain, 1992] <author> Will Partain. </author> <title> The nofib benchmark suite of haskell programs. </title> <institution> University of Glasgow, </institution> <year> 1992. </year>
Reference-contexts: To verify the correctness of our semantics and implementation, we compiled and ran a set of Haskell programs with our system. The programs are listed in Table 5.1. Other than one (the list-based set utilities), all Haskell programs are from the nofib test suite <ref> [Partain, 1992] </ref>. They range from small toy examples to relatively large applications. We compared the result of running the same program using both the original GHC compiler and the one retargeted to SML/NJ back-end. The outputs were verified to be exactly the same.
Reference: [Paterson, 1995] <author> Ross A. Paterson, </author> <year> 1995. </year> <title> private communication. </title>
Reference-contexts: EnvT r m ) = :callcc m (k:f 0 (a:lift EnvT r (ka))) (lift EnvT r ) = :callcc m (k:lift EnvT r (f k)) (prerequisite of 3.3.2) = :callcc m (k:f k) (lift EnvT r ) = lift EnvT r (callcc m f ) (lift EnvT r ) Paterson <ref> [Paterson, 1995] </ref> showed a simple proof for the naturalness of callcc ErrT m using the free theorem [Wadler, 1989] for callcc: 8g; h; f; f 0 : callccf 0 = map g (callccf ) By specializing f 0 to k:f 00 (k g), we can transform the free theorem to: Lemma <p> Here is a counterexample discovered by Paterson <ref> [Paterson, 1995] </ref>.
Reference: [Paulson, 1982] <author> Laurence C. Paulson. </author> <title> A semantics-directed compiler generator. </title> <booktitle> In Proceedings of the Ninth ACM Symposium on Principles of Programming Languages, </booktitle> <address> Albuquerque, New Mexico, </address> <pages> pages 224-233, </pages> <year> 1982. </year>
Reference-contexts: RELATED WORK, FUTURE WORK AND CONCLUSION and Hudak, 1996]. In addition, we demonstrate how these axioms, together with monad laws, can be used to reason about programs in a modular way. 6.1.3 Semantics-directed Compilation Early efforts [Wand, 1984] <ref> [Paulson, 1982] </ref> were based on traditional denotational semantics. The resulting compilers were inefficient. Action Semantics [Mosses, 1992] allows modular specification of programming language semantics. Action semantics and a related approach [Lee, 1989] have been successfully used to generate efficient compilers.
Reference: [Peterson and Hammond, 1996] <author> John Peterson and Kevin Hammond. </author> <title> Report on the programming language Haskell: a non-strict, purely functional language, version 1.3. </title> <type> Technical Report YALEU/DCS/RR-1106, </type> <institution> Yale University Department of Computer Science, </institution> <month> May </month> <year> 1996. </year>
Reference-contexts: (E [[e 1 ]]) (i: bind (E [[e 2 ]]) (j: return (i + j))) + E : Term ! M Value E [[e 1 + e 2 ]] = f i E [[e 1 ]]; return (i + j)g This notation is similar to the do syntax in Haskell <ref> [Peterson and Hammond, 1996] </ref>, and is also somewhat similar to monad comprehensions [Wadler, 1990]. It is important to remember that, despite the imperative feel, the monadic semantics is still made up of lambdas and applications. We will use bind and its short-hand notation interchangeably, depending on whichever is more convenient. <p> We have successfully implemented a modular monadic interpreter in Gofer [Jones, 1991], whose constructor classes and multi-parameter type classes provide just the added power over Haskell's type classes 1 to allow precise and convenient 1 The newly defined Haskell 1.3 <ref> [Peterson and Hammond, 1996] </ref> supports constructor classes 47 48 CHAPTER 4. <p> Because Gofer only allows us to partially apply a data type, not a type synonym, we introduce a dummy data constructor and define StateT as an algebraic data type 3 : 3 Haskell 1.3 <ref> [Peterson and Hammond, 1996] </ref> introduces a newtype construct that can be used to avoid the run-time penalty of dummy data constructors such as StateM. 4.5.
Reference: [Peyton Jones and Wadler, 1993] <editor> Simon Peyton Jones and Philip Wadler. </editor> <title> Imperative functional programming. </title> <booktitle> In Proceedings 20th Symposium on Principles of Programming Languages, </booktitle> <pages> pages 71-84. </pages> <publisher> ACM, </publisher> <month> January </month> <year> 1993. </year>
Reference-contexts: The environment axioms provide an answer to the question: what constitutes an environment? We expect that useful monadic axioms can be derived for other features, following the earlier efforts on state [Hudak and Bloss, 1985] <ref> [Peyton Jones and Wadler, 1993] </ref> [Hudak, 1992], continuations [Felleisen et al., 1986] [Felleisen and Hieb, 1992] and exceptions [Spivey, 1990]. 3.3 Natural Liftings In this section, we investigate what conditions a desirable lifting must satisfy. First we will formalize how types are transformed in the lifting process. <p> Moggi first proposed to use monads and monad transformers to structure denota-tional semantics. Wadler popularized Moggi's ideas in the functional programming community by showing how monads could be used in a variety of settings, including incorporating imperative features <ref> [Peyton Jones and Wadler, 1993] </ref> and building 6.1. RELATED WORK 85 modular interpreters [Wadler, 1992]. Wadler [King and Wadler, 1993] discussed the issues in combining monads. Pseudomonads [Steele Jr., 1994] were proposed as a way to compose monads and thus build up an interpreter from smaller parts.
Reference: [Peyton Jones, 1992] <author> S.L. Peyton Jones. </author> <title> Implementing lazy functional languages on stock hardware: </title> <journal> The Spineless Tagless G-machine. Journal of Functional Programming, </journal> <volume> 2(2) </volume> <pages> 127-202, </pages> <month> April </month> <year> 1992. </year>
Reference-contexts: How to implement a back-end that efficiently supports such target languages has been investigated by a number of compiler research efforts (e.g., the techniques developed for T [Kranz et al., 1986], SML/NJ [Appel, 1992], and Haskell <ref> [Peyton Jones, 1992] </ref>). Even though we do not tackle the problem of building compiler back-ends, our work provides insights into how we may build a common back-end capable of supporting a variety of source languages. Writing separate back-ends for different source languages leads to duplication of efforts. <p> This is exactly the set of run-time support needed to implement monadic semantics. 5.4.1 The STG Language The STG language <ref> [Peyton Jones, 1992] </ref>, whose grammar is shown in Figure 5.1 1 , is a small purely-functional language with an operational reading as well as the usual 1 We dropped the update flag and free variable list from the lambda form because they are not used in our framework. 5.4.
Reference: [Sabry and Felleisen, 1992] <author> Amr Sabry and Matthias Felleisen. </author> <title> Reasoning about programs in continuation-passing style. </title> <booktitle> In Proceedings of the 1992 ACM Conference on LISP and Functional Programming, </booktitle> <pages> pages 288-298. </pages> <publisher> ACM Press, </publisher> <month> June </month> <year> 1992. </year>
Reference-contexts: The suitability of a monadic form as an intermediate form has been observed by many researchers (including, for example, <ref> [Sabry and Felleisen, 1992] </ref> and [Hatcliff and Danvy, 1994]). 6.2 Future Work 6.2.1 Theory of Programming Language Features We have used monads and monad transformers to study programming language features and their interactions. Plenty of work remains on extending the theory to handle other useful features we have not covered.
Reference: [Spivey, 1990] <author> Michael Spivey. </author> <title> A functional theory of exceptions. </title> <booktitle> Science of Computer Programming, </booktitle> <volume> 14(1) </volume> <pages> 25-42, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: provide an answer to the question: what constitutes an environment? We expect that useful monadic axioms can be derived for other features, following the earlier efforts on state [Hudak and Bloss, 1985] [Peyton Jones and Wadler, 1993] [Hudak, 1992], continuations [Felleisen et al., 1986] [Felleisen and Hieb, 1992] and exceptions <ref> [Spivey, 1990] </ref>. 3.3 Natural Liftings In this section, we investigate what conditions a desirable lifting must satisfy. First we will formalize how types are transformed in the lifting process. <p> The monadic framework has been used to specify state monad laws [Wadler, 1990], and to reason about exceptions <ref> [Spivey, 1990] </ref>. A related, but more general, framework to reason about states is mutable abstract data types (MADTs) [Hudak, 1992]. This thesis extends previous work by presenting the environment axioms [Liang 86 CHAPTER 6. RELATED WORK, FUTURE WORK AND CONCLUSION and Hudak, 1996].
Reference: [Steele Jr., 1994] <author> Guy L. Steele Jr. </author> <title> Building interpreters by composing mon-ads. </title> <booktitle> In Conference Record of POPL '94: 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages, Portland, Oregon, </booktitle> <pages> pages 472-492, </pages> <address> New York, </address> <month> January </month> <year> 1994. </year> <note> ACM Press. </note>
Reference-contexts: Early work by Wadler [Wadler, 1990] showed the relationships between monads and functional programming. Recently, there has been a great deal of interest in using monads to construct modular semantics and modular interpreters [Wadler, 1992] [Jones and Duponcheel, 1993] [Espinosa, 1993] <ref> [Steele Jr., 1994] </ref>. In Chapter 2, we will present the modular monadic semantics for a wide range of programming language features. We will demonstrate how monad transformers capture individual features, and how liftings capture the interactions between different features. <p> While the static type system in Haskell or SML is capable of implementing traditional denotational semantics, implementing monadic modular semantics in a strongly typed language has proved to be a challenge. For example, Steele <ref> [Steele Jr., 1994] </ref> reported numerous difficulties when he built a modular monadic interpreter in Haskell. Although the Haskell type system can implement individual monads and monad transformers as type constructors, modular monadic semantics requires the type system to capture relationships among different monads and monad transformers. <p> We define additionally a class InterpC to characterize the term types that we wish to interpret: 2 Most of the typing problems Steele <ref> [Steele Jr., 1994] </ref> encountered disappear with the use of our extensible union types; in particular, there is no need for Steele's towers of data types. 4.2. <p> RELATED WORK 85 modular interpreters [Wadler, 1992]. Wadler [King and Wadler, 1993] discussed the issues in combining monads. Pseudomonads <ref> [Steele Jr., 1994] </ref> were proposed as a way to compose monads and thus build up an interpreter from smaller parts. However, implementing pseudomonads in the Haskell [Hudak et al., 1992] type system turned out to be problematic.
Reference: [Stoy, 1977] <author> Joseph Stoy. </author> <title> Denotational Semantics: The Scott-Strachey Approach to Programming Language Theory. </title> <publisher> MIT Press, </publisher> <year> 1977. </year> <note> 94 BIBLIOGRAPHY </note>
Reference-contexts: Introduction 1.1 Overview Denotational semantics <ref> [Stoy, 1977] </ref> is among the most important developments in programming language theory. It gives a precise mathematical description of programming languages, useful in designing and implementing languages as well as reasoning about programs. <p> prac tical use of modular monadic semantics. 6.1 Related Work Our work is built on a number of previous attempts to better organize modular semantics, to more effectively reason about programming languages, and to more efficiently compile higher-order programs. 6.1.1 Modular Semantics The lack of modularity of traditional denotational semantics <ref> [Stoy, 1977] </ref> has long been recognized [Mosses, 1984] [Lee, 1989]. Moggi first proposed to use monads and monad transformers to structure denota-tional semantics.
Reference: [Tolmach and Appel, 1990] <author> Andrew P. Tolmach and Andrew W. Appel. </author> <title> Debugging standard ML without reverse engineering. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <address> Nice, France, </address> <month> June </month> <year> 1990. </year>
Reference-contexts: The former is the usual semantics for callcc, and the latter is useful in Tolmach and Appel's approach to debugging <ref> [Tolmach and Appel, 1990] </ref>. callcc StateT s m : ((a ! s ! m (s; b)) ! s ! m (s; a)) ! s ! m (s; a) callcc StateT s m f = s 0 :callcc m (k:f (a:s 1 :k (s 1 ; a)) s 0 ) The above
Reference: [Wadler, 1989] <editor> Philip L. Wadler. </editor> <booktitle> Theorems for free! In Fourth Symposium on Functional Programming Languages and Computer Architecture. ACM, </booktitle> <month> September </month> <year> 1989. </year> <institution> London. </institution>
Reference-contexts: = :callcc m (k:lift EnvT r (f k)) (prerequisite of 3.3.2) = :callcc m (k:f k) (lift EnvT r ) = lift EnvT r (callcc m f ) (lift EnvT r ) Paterson [Paterson, 1995] showed a simple proof for the naturalness of callcc ErrT m using the free theorem <ref> [Wadler, 1989] </ref> for callcc: 8g; h; f; f 0 : callccf 0 = map g (callccf ) By specializing f 0 to k:f 00 (k g), we can transform the free theorem to: Lemma 3.3.3 8g; h; f; f 00 : callcc (k:f 00 (k g)) = map g (callccf )
Reference: [Wadler, 1990] <author> Philip L. Wadler. </author> <title> Comprehending monads. </title> <booktitle> In Proceedings of the 1990 ACM Conference on Lisp and Functional Programming, </booktitle> <year> 1990. </year>
Reference-contexts: The concept of monads originates from category theory [Mac Lane, 1971]. The formulation of monads using a triple (bind, return, and the type constructor) is due to Kleisli. Moggi [Moggi, 1990] first proposed that monads provided a useful tool for structuring denotational semantics. Early work by Wadler <ref> [Wadler, 1990] </ref> showed the relationships between monads and functional programming. Recently, there has been a great deal of interest in using monads to construct modular semantics and modular interpreters [Wadler, 1992] [Jones and Duponcheel, 1993] [Espinosa, 1993] [Steele Jr., 1994]. <p> (i + j))) + E : Term ! M Value E [[e 1 + e 2 ]] = f i E [[e 1 ]]; return (i + j)g This notation is similar to the do syntax in Haskell [Peterson and Hammond, 1996], and is also somewhat similar to monad comprehensions <ref> [Wadler, 1990] </ref>. It is important to remember that, despite the imperative feel, the monadic semantics is still made up of lambdas and applications. We will use bind and its short-hand notation interchangeably, depending on whichever is more convenient. <p> The remainder of this section introduces the monad transformers that cover all the features listed in Table 2.1. Some of these (StateT, ContT, and ErrorT) appear in an abstract form in Moggi's note [Moggi, 1990]. The environment monad is similar to the state reader by Wadler <ref> [Wadler, 1990] </ref>. The state and environment monad transformers are related to ideas found in Jones and Duponcheel's work [Jones, 1993] [Jones and Duponcheel, 1993]. 2.3. MONAD TRANSFORMERS 21 We will attach subscripts to monadic operations to distinguish between the different monads they operate on. <p> In applying this law, we must make sure that there is no unwanted name capture. The type constructors Id and List introduced in Chapter 2 are well-known mon-ads (presented in, for example, <ref> [Wadler, 1990] </ref>): Proposition 3.1.1 Id and List are monads. 3.1. <p> The monadic framework has been used to specify state monad laws <ref> [Wadler, 1990] </ref>, and to reason about exceptions [Spivey, 1990]. A related, but more general, framework to reason about states is mutable abstract data types (MADTs) [Hudak, 1992]. This thesis extends previous work by presenting the environment axioms [Liang 86 CHAPTER 6. RELATED WORK, FUTURE WORK AND CONCLUSION and Hudak, 1996].
Reference: [Wadler, 1992] <editor> Philip Wadler. </editor> <booktitle> The essence of functional programming. In Conference Record of the Nineteenth Annual ACM Symposium on Principles of Programming Languages, </booktitle> <address> Albuquerque, New Mexico, </address> <pages> pages 1-14, </pages> <month> January </month> <year> 1992. </year>
Reference-contexts: Moggi [Moggi, 1990] first proposed that monads provided a useful tool for structuring denotational semantics. Early work by Wadler [Wadler, 1990] showed the relationships between monads and functional programming. Recently, there has been a great deal of interest in using monads to construct modular semantics and modular interpreters <ref> [Wadler, 1992] </ref> [Jones and Duponcheel, 1993] [Espinosa, 1993] [Steele Jr., 1994]. In Chapter 2, we will present the modular monadic semantics for a wide range of programming language features. We will demonstrate how monad transformers capture individual features, and how liftings capture the interactions between different features. <p> MODULAR MONADIC SEMANTICS which is the standard state monad found, for example, in Wadler's work <ref> [Wadler, 1992] </ref>. We will formally define monad transformers in Section 3.1.2. For now we note that a monad transformer t has a number of capabilities: First, it transforms any monad m to monad t m. <p> Wadler popularized Moggi's ideas in the functional programming community by showing how monads could be used in a variety of settings, including incorporating imperative features [Peyton Jones and Wadler, 1993] and building 6.1. RELATED WORK 85 modular interpreters <ref> [Wadler, 1992] </ref>. Wadler [King and Wadler, 1993] discussed the issues in combining monads. Pseudomonads [Steele Jr., 1994] were proposed as a way to compose monads and thus build up an interpreter from smaller parts.
Reference: [Wand, 1984] <author> Mitchell Wand. </author> <title> A semantic prototyping system. </title> <booktitle> SIGPLAN Notices, ACM Symposium on Compiler Construction, </booktitle> <volume> 19(6) </volume> <pages> 213-221, </pages> <year> 1984. </year>
Reference-contexts: RELATED WORK, FUTURE WORK AND CONCLUSION and Hudak, 1996]. In addition, we demonstrate how these axioms, together with monad laws, can be used to reason about programs in a modular way. 6.1.3 Semantics-directed Compilation Early efforts <ref> [Wand, 1984] </ref> [Paulson, 1982] were based on traditional denotational semantics. The resulting compilers were inefficient. Action Semantics [Mosses, 1992] allows modular specification of programming language semantics. Action semantics and a related approach [Lee, 1989] have been successfully used to generate efficient compilers.
Reference: [Wand, 1990] <author> Mitchell Wand. </author> <title> A short proof of the lexical addressing algorithm. </title> <journal> Information Processing Letters, </journal> <volume> 35 </volume> <pages> 1-5, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: It turns out that we can indeed prove such a general result by using monad laws and environment axioms. Following Wand <ref> [Wand, 1990] </ref>, we define a natural semantics that translates source language variables to lexical variables in the meta-language, and we prove that it is equivalent to the standard semantics. 5.2.1 Definition of a Natural Semantics We adopt Wand's definition of a natural semantics (which differs from Kahn's notion [Cl ement et <p> The natural semantics uses the environment of the meta-language for variables in the source language. 5.2.2 Correspondence between Natural and Standard Semantics The next theorem, a variation of Wand's <ref> [Wand, 1990] </ref>, states that the standard semantics and natural semantics are equivalent, and thus guarantees that it is safe to implement function calls in the source language using the meta-language environment. <p> For example, Wand <ref> [Wand, 1990] </ref> pointed out that he could change to a continuation-based semantics, and prove the theorem, but only by modifying the proofs accordingly. Modular monadic semantics, on the other hand, offers highly modularized proofs and more general results.
Reference: [Yale Haskell Group, 1994] <institution> The Yale Haskell Group. </institution> <note> The Yale Haskell users manual. Version Y2.2, </note> <month> September </month> <year> 1994. </year>
Reference-contexts: The standard entry point expects all arguments to be passed in the cell mode. 5.4. AN EXPERIMENT: RETARGETING A HASKELL COMPILER 73 Optimized and standard entry points have been used in other Haskell compilation systems, such as previous versions of the Yale Haskell Compiler <ref> [Yale Haskell Group, 1994] </ref>. We build the standard entry from the optimized entry point using the semantic function stdEntry, which will be defined later. Note that the meta language fixed point operator fix defines v and v as recursive functions.
References-found: 52

