URL: http://www.cs.gatech.edu/grads/p/Jeff.Pittges/ds6.ps
Refering-URL: http://www.cs.gatech.edu/grads/p/Jeff.Pittges/pittges.html
Root-URL: 
Title: Maintaining Instance-Based Constraints for Semantic Query Optimization  
Author: Jeff Pittges 
Keyword: Metadata View Graph, Instance-Based Constraints, Semantic Query Optimization, Constraint Discovery, Metadata Maintenance.  
Address: Atlanta, Georgia 30332-0280  
Affiliation: College of Computing Georgia Institute of Technology  
Email: pittges@cc.gatech.edu  
Phone: (404) 853-9381  
Web: http://www.cc.gatech.edu/grads/p/Jeff.Pittges/pittges.html  
Date: May 3, 1995  
Abstract: Semantic Query Optimization has traditionally relied upon scheme-based integrity constraints that are valid for all instances of a database. Instance-based constraints, which are only valid for certain states of a database, contain more information than scheme-based constraints because they are specific to the current contents of the database. This makes instance-based constraints more useful to semantic query optimization. However, instance-based constraints are highly sensitive to any changes made to the database and must therefore be updated and validated before they can be applied. A Metadata View Graph (MVG) is a metadatabase that stores instance-based constraints, along with statistical and structural metadata, for logical views of the database. Constraints at this level are even more useful to semantic query optimization because they are specifically tailored to the intermediate results of a query. This paper reviews existing methods for constraint discovery, describes how constraints are stored in the Metadata View Graph at compile-time, and describes how the MVG Framework retrieves and maintains instance-based constraints at run-time. The paper then analyzes how to apply updates to instance-based constraints in order to refresh them. 
Abstract-found: 1
Intro-found: 1
Reference: [BLT86] <author> J. Blakeley, P. Larson, and F. Tompa. </author> <title> Efficiently updating materialized views. </title> <editor> In C. Zaniolo, editor, </editor> <booktitle> Proceedings of the 1986 ACM SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 61-71, </pages> <address> Washington, D.C., </address> <month> May </month> <year> 1986. </year>
Reference-contexts: However, only a subset of the updates will apply to a view node based on the definition of the node (e.g., gpa 3.5). Therefore, the updates must be filtered to remove the irrelevant updates (i.e., those updates that do not apply to the view node being updated) <ref> [BLT86] </ref>. An example is provided below. Consider the Student base relation and the view node shown in Figure 5.
Reference: [CG94] <author> Richard L. Cole and Goetz Graefe. </author> <title> Optimization of dynamic query evaluation plans. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 150-160, </pages> <address> Minneapolis, Minnesota, </address> <month> May </month> <year> 1994. </year> <month> 19 </month>
Reference-contexts: The remaining nodes represent logical views. A view node is defined by the links connecting the node to the base relations. Figure 3 illustrates an example View Network along with a semantic network and lexicon. The QEP Network stores two types of query execution plans, dynamic plans <ref> [GW89, CG94] </ref> and semantic plans. A semantic plan is a query execution plan that is semantically equivalent to the original query. Semantic plans are generated during semantic query optimization and depend on integrity constraints and instance-based semantic constraints. A dynamic plan links several query execution plans together with choose-plan operators.
Reference: [CGM90] <author> S. Chakravarthy, J. Grant, and J. Minker. </author> <title> Logic based approach to semantic query optimization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 15(2) </volume> <pages> 162-207, </pages> <month> June </month> <year> 1990. </year>
Reference-contexts: 1 Introduction Semantic query optimization <ref> [HZ80, Kin81, SO89, CGM90, SSD92, HK93] </ref> uses transformation rules to reformulate a query into a semantically equivalent query that is more efficient to execute. Traditionally, transformation rules have been derived exclusively from scheme-based integrity constraints that are valid for all instances of a database.
Reference: [Fre87] <author> J.C. Freytag. </author> <title> A rule-based view of query optimization. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 173-180, </pages> <address> San Francisco, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: Although we envision a set of rule-based optimizers <ref> [Fre87, GD87, GM93] </ref>, the actual implementation is irrelevant to our work on Metadata View Graphs. 2.1 Metadata View Graphs A Metadata View Graph (MVG) is a collection of networks, as shown in Figure 2, for organizing and storing metadata (i.e., a metadatabase).
Reference: [GD87] <author> G. Graefe and D. DeWitt. </author> <title> The exodus optimizer generator. </title> <booktitle> In Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <pages> pages 160-171, </pages> <address> San Francisco, </address> <month> May </month> <year> 1987. </year>
Reference-contexts: Although we envision a set of rule-based optimizers <ref> [Fre87, GD87, GM93] </ref>, the actual implementation is irrelevant to our work on Metadata View Graphs. 2.1 Metadata View Graphs A Metadata View Graph (MVG) is a collection of networks, as shown in Figure 2, for organizing and storing metadata (i.e., a metadatabase).
Reference: [GM93] <author> G. Graefe and W.J. McKenna. </author> <title> The volcano optimizer generator: Extensibility and efficient search. </title> <booktitle> In Proceedings of the IEEE Conference on Data Engineering, </booktitle> <pages> pages 209-228, </pages> <address> Vienna, </address> <month> April </month> <year> 1993. </year>
Reference-contexts: Although we envision a set of rule-based optimizers <ref> [Fre87, GD87, GM93] </ref>, the actual implementation is irrelevant to our work on Metadata View Graphs. 2.1 Metadata View Graphs A Metadata View Graph (MVG) is a collection of networks, as shown in Figure 2, for organizing and storing metadata (i.e., a metadatabase).
Reference: [GW89] <author> G. Graefe and K. Ward. </author> <title> Dynamic query evaluation plans. </title> <booktitle> In Proceedings of the 1989 ACM-SIGMOD International Conference on the Management of Data, </booktitle> <pages> pages 358-366, </pages> <address> Portland, Oregon, </address> <year> 1989. </year>
Reference-contexts: The remaining nodes represent logical views. A view node is defined by the links connecting the node to the base relations. Figure 3 illustrates an example View Network along with a semantic network and lexicon. The QEP Network stores two types of query execution plans, dynamic plans <ref> [GW89, CG94] </ref> and semantic plans. A semantic plan is a query execution plan that is semantically equivalent to the original query. Semantic plans are generated during semantic query optimization and depend on integrity constraints and instance-based semantic constraints. A dynamic plan links several query execution plans together with choose-plan operators.
Reference: [HK93] <author> C. Hsu and C.A. Knoblock. </author> <title> Reformulating query plans for multidatabase systems. </title> <booktitle> In Proceedings of the Second International Conference on Information and Knowledge Management, </booktitle> <address> Washington, DC, </address> <year> 1993. </year>
Reference-contexts: 1 Introduction Semantic query optimization <ref> [HZ80, Kin81, SO89, CGM90, SSD92, HK93] </ref> uses transformation rules to reformulate a query into a semantically equivalent query that is more efficient to execute. Traditionally, transformation rules have been derived exclusively from scheme-based integrity constraints that are valid for all instances of a database.
Reference: [HK94] <author> Chun-Nan Hsu and Craig Knoblock. </author> <title> Rule induction for semantic query optimization. </title> <booktitle> Machine Learning, </booktitle> <pages> pages 1-10, </pages> <year> 1994. </year>
Reference-contexts: Unfortunately, scheme-based constraints are typically so general that they are of little use. For example, an integrity constraint may require an employee's salary to be greater than zero. Recently, a number of researchers <ref> [YS89, SSS92, SHKC93, HK94] </ref> have proposed methods for discovering instance-based constraints (also referred to as dynamic constraints in [YS89] and derived constraints in [SSS92]) which are only valid for particular instances of the database. <p> The disadvantage of this strategy is that a query will only benefit from the constraints that have been discovered if the query is similar to a previous query. Reverse Engineering Method After a query has been executed, <ref> [YS89, HK94] </ref> inspect the query result and attempt to discover relationships with other queries. For example, if the (intermediate) results of two queries are identical, then there must be some constraints relating the two queries.
Reference: [HZ80] <author> M. Hammer and S.B. Zdonik. </author> <title> Knowledge-based query processing. </title> <booktitle> In Proceedings of the Sixth International Conference on Very Large Data Bases, </booktitle> <pages> pages 137-147, </pages> <address> Montreal, </address> <month> October </month> <year> 1980. </year>
Reference-contexts: 1 Introduction Semantic query optimization <ref> [HZ80, Kin81, SO89, CGM90, SSD92, HK93] </ref> uses transformation rules to reformulate a query into a semantically equivalent query that is more efficient to execute. Traditionally, transformation rules have been derived exclusively from scheme-based integrity constraints that are valid for all instances of a database.
Reference: [Kin81] <author> J. King. Quist: </author> <title> A system for semantic query optimization in relational databases. </title> <booktitle> In Proceedings of the Seventh International Conference on Very Large Data Bases, </booktitle> <pages> pages 510-517, </pages> <year> 1981. </year>
Reference-contexts: 1 Introduction Semantic query optimization <ref> [HZ80, Kin81, SO89, CGM90, SSD92, HK93] </ref> uses transformation rules to reformulate a query into a semantically equivalent query that is more efficient to execute. Traditionally, transformation rules have been derived exclusively from scheme-based integrity constraints that are valid for all instances of a database.
Reference: [PMN95] <author> J. Pittges, L. Mark, and S. Navathe. </author> <title> Metadata view graphs: A framework for query optimization and metadata management. </title> <journal> ACM Transactions on Information Systems, </journal> <note> 1995. Unpublished submitted, </note> <month> Nov. </month> <year> 1994. </year>
Reference-contexts: The last section summarizes the contributions of this paper and describes future tasks for this research. 2 The MVG Framework The Metadata View Graph Framework <ref> [PMN95] </ref> supports the integration of various approaches to query optimization. As shown in Figure 1, the framework consists of an optimizer and a metadatabase. The MVG Framework has been developed with two objectives in mind: (1) improve query optimization, and (2) provide for a highly extensible query optimizer.
Reference: [Rou82] <author> N. Roussopoulos. </author> <title> The logical access path scheme of a database. </title> <journal> IEEE Transactions on Software Engineering, </journal> <volume> SE-8(6):563-573, </volume> <month> November </month> <year> 1982. </year>
Reference-contexts: For example, two nodes representing student and advisor could be connected by the links advised-by and advisor-of. The lexicon and semantic network are not relevant to the research presented in this paper. 4 The View Network is an extension of Roussopoulos' Logical Access Path schema <ref> [Rou82] </ref>. The View Network stores semantic, statistical, and structural metadata that is useful to the query optimizer. The view nodes in the network, v 1 through v 14 , represent logical views (intermediate results) and store metadata specific to the particular data set.
Reference: [SHKC93] <author> S. Shekhar, B. Hamidzadeh, A. Kohli, and M. Coyle. </author> <title> Learning transformation rules for semantic query optimization: A data-driven approach. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 5(6) </volume> <pages> 950-964, </pages> <year> 1993. </year>
Reference-contexts: Unfortunately, scheme-based constraints are typically so general that they are of little use. For example, an integrity constraint may require an employee's salary to be greater than zero. Recently, a number of researchers <ref> [YS89, SSS92, SHKC93, HK94] </ref> have proposed methods for discovering instance-based constraints (also referred to as dynamic constraints in [YS89] and derived constraints in [SSS92]) which are only valid for particular instances of the database. <p> This is a type of query-driven approach that requires two similar queries before any constraints are discovered. In addition, this method requires that the results of previous queries be stored and matched against future queries. Data Driven Methods <ref> [SHKC93] </ref> has proposed a data-driven approach that uses grid files to inspect combinations of attribute values for a given data set. The zeros in the grid file indicate constraints. The advantage of this approach is that constraints can be found regardless of the query history.
Reference: [SO87] <author> S.T. Shenoy and Z.M. Ozsoyoglu. </author> <title> A system for semantic query optimization. </title> <booktitle> Proceedings of the ACM SIGMOD International Conference on Management of Data, </booktitle> <volume> 16(3) </volume> <pages> 181-195, </pages> <month> December </month> <year> 1987. </year> <month> 20 </month>
Reference-contexts: Therefore, when given a query involving graduate students, the semantic query optimizer could use the salary constraint for graduate students to reformulate the query. In addition, capturing instance-based constraints for views of the database allows the query context to influence the optimization process during semantic query optimization. The profitability <ref> [SO87] </ref> of a rule can be adjusted for each view. Therefore, although the same rule may appear in several views, the rule can be applied differently based on the query context represented by each view.
Reference: [SO89] <author> S.T. Shenoy and Z.M. Ozsoyoglu. </author> <title> Design and implementation of a semantic query optimizer. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(3) </volume> <pages> 344-361, </pages> <year> 1989. </year>
Reference-contexts: 1 Introduction Semantic query optimization <ref> [HZ80, Kin81, SO89, CGM90, SSD92, HK93] </ref> uses transformation rules to reformulate a query into a semantically equivalent query that is more efficient to execute. Traditionally, transformation rules have been derived exclusively from scheme-based integrity constraints that are valid for all instances of a database.
Reference: [SSD92] <author> Shashi Shekhar, Jaideep Srivastava, and Soumitra Dutta. </author> <title> A formal model of trade-off between optimization and execution costs in semantic query optimization. </title> <journal> Data and Knowledge Engineering, </journal> <volume> 8 </volume> <pages> 131-151, </pages> <year> 1992. </year>
Reference-contexts: 1 Introduction Semantic query optimization <ref> [HZ80, Kin81, SO89, CGM90, SSD92, HK93] </ref> uses transformation rules to reformulate a query into a semantically equivalent query that is more efficient to execute. Traditionally, transformation rules have been derived exclusively from scheme-based integrity constraints that are valid for all instances of a database.
Reference: [SSS92] <author> M. Siegel, E. Sciore, and S. Salveter. </author> <title> A method for automatic rule derivation to support semantic query optimization. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 17(4) </volume> <pages> 563-600, </pages> <month> December </month> <year> 1992. </year>
Reference-contexts: Unfortunately, scheme-based constraints are typically so general that they are of little use. For example, an integrity constraint may require an employee's salary to be greater than zero. Recently, a number of researchers <ref> [YS89, SSS92, SHKC93, HK94] </ref> have proposed methods for discovering instance-based constraints (also referred to as dynamic constraints in [YS89] and derived constraints in [SSS92]) which are only valid for particular instances of the database. <p> For example, an integrity constraint may require an employee's salary to be greater than zero. Recently, a number of researchers [YS89, SSS92, SHKC93, HK94] have proposed methods for discovering instance-based constraints (also referred to as dynamic constraints in [YS89] and derived constraints in <ref> [SSS92] </ref>) which are only valid for particular instances of the database. Instance-based constraints contain more information than scheme-based constraints because they represent the actual contents of the database. <p> Query-driven methods use a top-down process to search for constraints that would have been useful for previous queries. Data-driven methods use a bottom-up process to search (random) data sets for constraints. Metadata View Graphs provide a framework for integrating the top-down and bottom-up processes. Query Driven Methods <ref> [SSS92] </ref> presents a query-driven method for discovering constraints. Given a query, the semantic query optimizer identifies the template transformation rules that would have been useful to the optimizer, and the system discovers constraints that fit the rule templates.
Reference: [YS89] <author> C. Yu and W. Sun. </author> <title> Automatic knowledge acquisition and maintenance for semantic query optimization. </title> <journal> IEEE Transactions on Knowledge and Data Engineering, </journal> <volume> 1(3) </volume> <pages> 362-375, </pages> <month> September </month> <year> 1989. </year> <month> 21 </month>
Reference-contexts: Unfortunately, scheme-based constraints are typically so general that they are of little use. For example, an integrity constraint may require an employee's salary to be greater than zero. Recently, a number of researchers <ref> [YS89, SSS92, SHKC93, HK94] </ref> have proposed methods for discovering instance-based constraints (also referred to as dynamic constraints in [YS89] and derived constraints in [SSS92]) which are only valid for particular instances of the database. <p> For example, an integrity constraint may require an employee's salary to be greater than zero. Recently, a number of researchers [YS89, SSS92, SHKC93, HK94] have proposed methods for discovering instance-based constraints (also referred to as dynamic constraints in <ref> [YS89] </ref> and derived constraints in [SSS92]) which are only valid for particular instances of the database. Instance-based constraints contain more information than scheme-based constraints because they represent the actual contents of the database. <p> The disadvantage of this strategy is that a query will only benefit from the constraints that have been discovered if the query is similar to a previous query. Reverse Engineering Method After a query has been executed, <ref> [YS89, HK94] </ref> inspect the query result and attempt to discover relationships with other queries. For example, if the (intermediate) results of two queries are identical, then there must be some constraints relating the two queries.
References-found: 19

