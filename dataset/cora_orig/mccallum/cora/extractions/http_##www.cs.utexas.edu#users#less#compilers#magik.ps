URL: http://www.cs.utexas.edu/users/less/compilers/magik.ps
Refering-URL: http://www.cs.utexas.edu/users/less/compiler.html
Root-URL: 
Email: engler@lcs.mit.edu  
Title: Incorporating application semantics and control into compilation  
Author: Dawson R. Engler 
Address: Cambridge, MA 02139, U.S.A  
Affiliation: M.I.T. Laboratory for Computer Science  
Abstract: Programmers have traditionally been passive users of compilers, rather than active exploiters of their transformational abilities. This paper presents MAGIK, a system that allows programmers to easily and modularly incorporate application-specific extensions into the compilation process. The MAGIK system gives programmers two significant capabilities. First, it provides mechanisms that implementors can use to incorporate application semantics into compilation, thereby enabling both optimizations and semantic checking impossible by other means. Second, since extensions are invoked during the translation from source to machine code, code transformations (such as software fault isolation [14]) can be performed with full access to the symbol and data flow information available to the compiler proper, allowing them both to exploit source semantics and to have their transformations (automatically) optimized as any other code. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> S. P. Amarasinghe, J. M. Anderson, M. S. Lam, and A. W. Lim. </author> <title> An overview of the SUIF compiler for scalable parallel machines. </title> <booktitle> In Proceedings of the 6th Workshop on Languages and Compilers for Parallel Computing, </booktitle> <address> Portland, OR, </address> <month> August </month> <year> 1993. </year>
Reference-contexts: In contrast, duplicating the functionality of ATOM for even a single architecture would require significantly more work (especially on an architecture such as the x86). There are many compilers designed to support easy addition of optimizations (e.g., SUIF <ref> [1] </ref>). These system could have been used to implement MAGIK; lcc was chosen because of the author's familiarity with it. To the best of our knowledge, none of these compilers have been used explicitly for extending the optimizer with user-level semantics or transformations. <p> The main implementation limitation of the MAGIK system is that since lcc provides no global optimization framework optimizers are given only weak data flow information. We are investigating methods of removing this limitation (e.g., by using the SUIF compiler system <ref> [1] </ref>). An operational overview of the extension process is as follows: 1. Programmers implement extensions using the MAGIK libraries; these extensions are compiled to object code. The location of this code is either specified to MAGIK using command-line flags or by embedding the location in source files.
Reference: [2] <author> D. R. Engler, W. C. Hsieh, and M. F. Kaashoek. </author> <title> `C: A language for high-level, efficient, and machine-independent dynamic code generation. </title> <booktitle> In Proceedings of the 23th Annual Symposium on Principles of Programming Languages, </booktitle> <pages> pages 131-144, </pages> <address> St. Pe-tersburg, FL, </address> <year> 1995. </year>
Reference-contexts: Four main limitations are discussed. First, constructing large pieces of code is tedious. This would naturally be remedied with language support. A promising avenue is to use the `C language <ref> [2] </ref> (designed to construct code dynamically) as a sugary method of dynamically constructing MAGIK IR. `C solves most of the semantic issues dealing with variable binding, and code construction, leaving us with the fairly straightforward task of modifying it to dynamically emit MAGIK IR rather than executable code.
Reference: [3] <author> C. W. Fraser and D. R. Hanson. </author> <title> A retargetable C compiler: design and implementation. </title> <publisher> Benjamin/Cummings Publishing Co., </publisher> <address> Redwood City, CA, </address> <year> 1995. </year>
Reference-contexts: Extensions are given access to MAGIK's intermediate representation (IR) through a set of interfaces that allow them to easily create, delete, and augment IR at compile time. Both this IR and MAGIK are built on top of the lcc compiler <ref> [3] </ref>, which is used to compile the source language (ANSI C). The control MAGIK gives to programmers enables a broad class of optimization and code transformations. This paper presents ten such extensions and sketches of many more. This paper concentrates on two abilities provided by MAGIK. <p> Higher-level interfaces are discussed in Section 4 and Section 5. We expect MAGIK to evolve with further experience. To aid iterative design, the current implementation has emphasized simplicity at all levels. MAGIK is built on top of the lcc retargetable ANSI C compiler <ref> [3] </ref>, and uses its IR language as its fundamental interface [4] (higher-level interfaces are Type C name V void C signed char UC unsigned char S signed short US unsigned short I int U unsigned L long UL unsigned long F float D double P void * Table 1: MAGIK types
Reference: [4] <author> C.W. Fraser and D.R. Hanson. </author> <title> A code generation interface for ANSI C. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 21(9) </volume> <pages> 963-988, </pages> <month> September </month> <year> 1991. </year>
Reference-contexts: We expect MAGIK to evolve with further experience. To aid iterative design, the current implementation has emphasized simplicity at all levels. MAGIK is built on top of the lcc retargetable ANSI C compiler [3], and uses its IR language as its fundamental interface <ref> [4] </ref> (higher-level interfaces are Type C name V void C signed char UC unsigned char S signed short US unsigned short I int U unsigned L long UL unsigned long F float D double P void * Table 1: MAGIK types (superset of lcc's types). crafted on top of this).
Reference: [5] <author> W. Wilson Ho and Ronald A. Olsson. </author> <title> An approach to genuine dynamic linking. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 24(4) </volume> <pages> 375-390, </pages> <month> April </month> <year> 1991. </year>
Reference-contexts: For instance, header files can specify an extension to optimize the interfaces they define. 2. MAGIK compiles high-level source (ANSI C) to its internal IR in the traditional manner. As MAGIK encounters extension location directives (either as compiler flags or embedded in source) it uses the dld dynamic linker <ref> [5] </ref> to dynamically link the named extensions into the compiler proper. 3. At every function MAGIK encounters it invokes all code extensions, beginning with transformer extensions. At this point the extensions are free to augment, modify and delete parts of the IR.
Reference: [6] <author> Clinton L. Jeffery and Ralph E. Griswold. </author> <title> A framework for execution monitoring in Icon. </title> <journal> SoftwarePractice and Experience, </journal> <volume> 24(11) </volume> <pages> 1025-1049, </pages> <month> November </month> <year> 1994. </year>
Reference-contexts: Checks can be inserted to check for the aliasing of pointers to determine what optimizations would be profitable. It can also be used to support graphical performance monitoring in the spirit of Jeffery and Griswold <ref> [6] </ref> by automatically inserting display calls around interface uses. Other Uses There are many other uses for extensible compilation. For example, many uses of Atom can also be done using MAGIK (the tradeoff is less generality for more information and optimization).
Reference: [7] <author> Gregor Kiczales, Jim des Rivieres, and Daniel G. Bobrow. </author> <title> The Art of the Metaobject Protocol. </title> <publisher> MIT Press, </publisher> <year> 1991. </year>
Reference-contexts: To the best of our knowledge, none of these compilers have been used explicitly for extending the optimizer with user-level semantics or transformations. MAGIK can be viewed as an Open System in the spirit of Kiczale's work <ref> [7] </ref>. Of course, programmers have long performed interface optimizations by hand. The advantages of automated optimization are well known. 3 System Overview MAGIK provides a framework to extend compilation. User extensions are implemented as dynamically-linked functions. User extensions come in two classes: code extensions and data structure extensions.
Reference: [8] <author> Adam Kolawa and Arthur Hicken. Insure++: </author> <title> A tool to support total quality software. </title> <address> http://www.parasoft.com/insure/papers / tech.htm. </address>
Reference-contexts: Section 6 presents further examples of how to use extensible compilation, Section 7 discusses issues in the current system and directions for future work and Section 8 concludes. 2 Related Work Examples of including application-level information into compilation are compiler-directed prefetching and management of I/O [9] and ParaSoft's Insure++ <ref> [8] </ref>, which can check for Unix system call errors (similar to the MAGIK checker shown in Figure 2). Using a MAGIK-based approach, systems such as these could be built without compiler modifications. We compare MAGIK to macro systems, semantic-based op-timizers, extensible compilers, and object code modifiers.
Reference: [9] <author> Todd C. Mowry, Angela K. Demke, and Orran Krieger. </author> <title> Automatic compiler-inserted i/o prefetching for out-of-core applications. </title> <booktitle> In Proceedings of the Second Symposium on Operating Systems Design and Implementation, </booktitle> <year> 1996. </year>
Reference-contexts: Section 6 presents further examples of how to use extensible compilation, Section 7 discusses issues in the current system and directions for future work and Section 8 concludes. 2 Related Work Examples of including application-level information into compilation are compiler-directed prefetching and management of I/O <ref> [9] </ref> and ParaSoft's Insure++ [8], which can check for Unix system call errors (similar to the MAGIK checker shown in Figure 2). Using a MAGIK-based approach, systems such as these could be built without compiler modifications. We compare MAGIK to macro systems, semantic-based op-timizers, extensible compilers, and object code modifiers.
Reference: [10] <author> A. Srivastava and D.W. Wall. </author> <title> A practical system for intermodule code optimization at link-time. </title> <journal> Journal of Programming Languages, </journal> <month> March </month> <year> 1992. </year>
Reference-contexts: Further practical experience is needed to determine if MAGIK's added power is worth this cost. MAGIK follows in the footsteps of the Atom object code modification system [11] (foreshadowed by the object code modifiers of Wall [15] and Srivastava and Wall <ref> [10] </ref>), which provides users with the ability to modify object code in a clean, simple manner. Atom was one of the first tools to give programmers ready access to the transformational abilities encased in compilers.
Reference: [11] <author> Amitabh Srivastava and Alan Eustace. </author> <title> Atom a system for building customized program analysis tools. </title> <booktitle> In Proceedings of the SIGPLAN '94 Conference on Programming Language Design and Implementation, </booktitle> <year> 1994. </year>
Reference-contexts: Using this ability, programmers can instrument code, augment it (e.g., by introducing software fault isolation code [14] or garbage collection reference counters) or enforce invariants about it (e.g., that no pointer casts are allowed). Unlike object code modifiers such as ATOM <ref> [11] </ref>, MAGIK clients are tightly integrated with the source compiler. Performing transformations during the translation from high-level source language to machine code has two important characteristics. First, it provides access to the full semantics of the high-level language, information that source transformers can exploit (or require) during code transformation. <p> The cost of this power is that MAGIK more difficult to use. Further practical experience is needed to determine if MAGIK's added power is worth this cost. MAGIK follows in the footsteps of the Atom object code modification system <ref> [11] </ref> (foreshadowed by the object code modifiers of Wall [15] and Srivastava and Wall [10]), which provides users with the ability to modify object code in a clean, simple manner. Atom was one of the first tools to give programmers ready access to the transformational abilities encased in compilers.
Reference: [12] <author> Mark T. Vandevoorde. </author> <title> Exploiting Specifications to Improve Program Performance. </title> <type> PhD thesis, </type> <institution> M.I.T., </institution> <year> 1994. </year>
Reference-contexts: Macro systems such as Weise and Crew's recent work [16] are restricted to fairly localized code transformations, while MAGIK extensions can perform global transformations across many interface calls, using symbol table and flow graph information provided by the compiler. Mark Vandevoorde and John Guttag <ref> [12, 13] </ref> describe a system that provides programmers with a safe way to impart some classes of semantic information to the optimizer. User-level specifications for a restricted functional language are consumed by a theorem prover that optimizes based on the specific situation in which function calls are used. <p> We are investigating the representation of code templates used for matching via language support: here to a modification of the `C language seems promising. Third, the system is manual, even for tasks that could be done automatically (e.g., in the spirit of Vandevoorde and Gut-tag <ref> [13, 12] </ref>). As we determine which of these tasks are important and common, automation will be added. Finally, lcc, while simple and easy to modify, is a poor optimizer.
Reference: [13] <author> Mark T. Vandevoorde and John V. Guttag. </author> <title> Using specialized procedures and specification-based analysis to reduce the runtime costs of modularity. </title> <booktitle> In Proceedings of the 1994 ACM/SIGSOFT Foundations of Software Engineering Conference, </booktitle> <year> 1994. </year>
Reference-contexts: Macro systems such as Weise and Crew's recent work [16] are restricted to fairly localized code transformations, while MAGIK extensions can perform global transformations across many interface calls, using symbol table and flow graph information provided by the compiler. Mark Vandevoorde and John Guttag <ref> [12, 13] </ref> describe a system that provides programmers with a safe way to impart some classes of semantic information to the optimizer. User-level specifications for a restricted functional language are consumed by a theorem prover that optimizes based on the specific situation in which function calls are used. <p> We are investigating the representation of code templates used for matching via language support: here to a modification of the `C language seems promising. Third, the system is manual, even for tasks that could be done automatically (e.g., in the spirit of Vandevoorde and Gut-tag <ref> [13, 12] </ref>). As we determine which of these tasks are important and common, automation will be added. Finally, lcc, while simple and easy to modify, is a poor optimizer.
Reference: [14] <author> R. Wahbe, S. Lucco, T. Anderson, and S. Graham. </author> <title> Efficient software-based fault isolation. </title> <booktitle> In Proceedings of the Fourteenth ACM Symposium on Operating Systems Principles, </booktitle> <pages> pages 203-216, </pages> <month> December </month> <year> 1993. </year>
Reference-contexts: The second main ability MAGIK provides is an easy, modular way to do general code transformations with full access to source information. Using this ability, programmers can instrument code, augment it (e.g., by introducing software fault isolation code <ref> [14] </ref> or garbage collection reference counters) or enforce invariants about it (e.g., that no pointer casts are allowed). Unlike object code modifiers such as ATOM [11], MAGIK clients are tightly integrated with the source compiler. <p> Code transformations The ability to augment code is powerful. Using MAGIK's interfaces, applications can implement a vast set of code transformations such as the insertion of reference counting, software address translation (as described in Section 5), or providing protection via software fault isolation <ref> [14] </ref>. An interesting optimization is to encode the expected result of interface calls in an extension. These annotations allow the extension to rearrange code so that the conditional bodies of unexpected cases are moved off of the commonly executed path, thereby improving both instruction prefetching queue and instruction cache utilization.
Reference: [15] <author> D.W. Wall. </author> <title> Systems for late code modification. CODE 91 Workshop on Code Generation, </title> <year> 1991. </year>
Reference-contexts: The cost of this power is that MAGIK more difficult to use. Further practical experience is needed to determine if MAGIK's added power is worth this cost. MAGIK follows in the footsteps of the Atom object code modification system [11] (foreshadowed by the object code modifiers of Wall <ref> [15] </ref> and Srivastava and Wall [10]), which provides users with the ability to modify object code in a clean, simple manner. Atom was one of the first tools to give programmers ready access to the transformational abilities encased in compilers. <p> In contrast, object code have to both work without much source-level information and cannot bootstrap existing compiler optimizers <ref> [15] </ref>. An important practical difference between MAGIK and object code modifiers is that MAGIK is significantly easier to implement. The system described in this paper took the author less than a month to implement and it runs on all targets that the base compiler supports (x86, Mips, Sparc).

References-found: 15

