URL: http://www.cc.gatech.edu/systems/papers/PlaleTR97.ps
Refering-URL: http://www.cs.gatech.edu/people/home/beth/
Root-URL: 
Email: fbeth,schwang@cc.gatech.edu  
Title: Language issues in hazard detection using queries  
Author: Beth Plale Karsten Schwan 
Keyword: software safety, safety-critical systems, on-line monitoring, continuous distributed systems, query optimization  
Address: Atlanta, Georgia 30332  
Affiliation: College of Computing Georgia Institute of Technology  
Pubnum: GIT-CC-97-36  
Abstract: Safety-critical systems are pervading all areas of our lives. Accompanying the growth is an increasing level of awareness of the potential dangers involved. As a result, there has been recent realization among researchers that it is important to consider entire systems and their safety characteristics, going beyond individual embedded or real-time system components. This new focus presents an opportunity for a new approach to software safety, one that can accommodate heterogeneous distributed systems that may contain COTS components and may consist of components not all of which were designed to be used in safety-critical settings. In response to this need, we have developed a software hazard detection tool that we argue increases the safety level of continuous safety critical systems. In this paper we discuss the tool's language and code generation. The appendix contains the language syntax and a full sample of the generated code. 
Abstract-found: 1
Intro-found: 1
Reference: [1] <author> Tucker Balch and Ronald Arkin. </author> <title> Communication in reactive multiagent robot systems. </title> <booktitle> Autonomous Robots, </booktitle> <volume> 1(1) </volume> <pages> 27-52, </pages> <year> 1994. </year>
Reference-contexts: The run-time architecture and implementation is discussed in Section 5. The paper concludes in Section 6 with a discussion of future work. 2 An autonomous robotics application The sample application used in our work is a multiagent reactive robotic system simulation <ref> [1] </ref> where a robot performs one of three tasks: forage, consume, and graze. During forage, a robot wanders around 3 looking for attractors. Upon encountering an attractor, it moves toward the attractor, attaches itself, and returns the object to a specified home base.
Reference: [2] <author> Kenneth Birman. </author> <title> Keynote speech. </title> <booktitle> 6th IEEE Int'l Symposium on High Performance Distributed Computing (HPDC-6), </booktitle> <year> 1997. </year>
Reference-contexts: The implication of this growth is that an increasing number of software components that were never intended to be safety-critical are used in safety critical settings <ref> [2] </ref>, as illustrated by an emergency room physician accessing a remotely located patient record for information essential to an 1 accurate diagnosis. A delay in responding to the request could potentially endanger the patient. Similar ex-amples exist for transportation systems, financial systems, and electronic, telephone and telecommunications networks.
Reference: [3] <author> Jan Chomicki. </author> <title> Efficient checking of temporal integrity constraints using bounded history encoding. </title> <journal> ACM Transactions on Database Systems, </journal> <volume> 20(2), </volume> <month> June </month> <year> 1995. </year> <month> 17 </month>
Reference-contexts: The language we use is a relational query language incorporating features of the active database rule language Starburst [21] for its meta statements, and a subset of the relational temporal query language ATSQL2 [20] for specifying constraint conditions. We have extended ATSQL2 in a minor way as discussed in <ref> [3] </ref> to allow for the specification of real-time properties. The user specifies desired active behavior with rules. These rules are triggered by the occurrence of an event.
Reference: [4] <author> Ingeman J. Cox and Narian H. Gehani. </author> <title> Exception handling in robotics. </title> <journal> Computer, </journal> <volume> 22(3) </volume> <pages> 43-49, </pages> <month> March </month> <year> 1989. </year>
Reference-contexts: We provide the ACTIVATE and DEACTIVATE statements largely as a means for managing constraint conflict. The activate and deactivate actions may also be useful for loosely hierarchical error recovery <ref> [4] </ref>. For example, when a robot encounters an obstacle in its path, its first response could be to wait some amount of time in hopes that the obstacle will move. If this simple error recovery fails, its second response would be to determine a new route.
Reference: [5] <author> Greg Eisenhauer. </author> <title> Portable self-describing binary data streams. </title> <type> Technical Report GIT-CC-94-45, </type> <institution> College of Computing, Georgia Institute of Technology, </institution> <year> 1994. </year> <note> http://www.cc.gatech.edu/tech reports. </note>
Reference-contexts: Falcon [8], running as one or more separate threads, extracts event data from the buffer and sends it to the analysis tool in a binary encoded format, PBIO <ref> [5] </ref>. Events arrive at DataExchange [6], a communication library serving primarily in this context as an event handler. DataExchange decodes events using PBIO before passing them on to the dispatcher. The dispatcher, as explained below, then passes events to those constraints requiring them.
Reference: [6] <author> Greg Eisenhauer, Beth (Plale) Schroeder, and Karsten Schwan. DataExchange: </author> <title> High performance communication in distributed laboratories. </title> <booktitle> In Proceedings Ninth IASTED Int'l Conference on Parallel and Distributed Computing Systems, </booktitle> <month> October </month> <year> 1997. </year>
Reference-contexts: Falcon [8], running as one or more separate threads, extracts event data from the buffer and sends it to the analysis tool in a binary encoded format, PBIO [5]. Events arrive at DataExchange <ref> [6] </ref>, a communication library serving primarily in this context as an event handler. DataExchange decodes events using PBIO before passing them on to the dispatcher. The dispatcher, as explained below, then passes events to those constraints requiring them.
Reference: [7] <author> Ramez Elmasri and Shamkant B. Navathe. </author> <title> Fundamentals of Database Systems. </title> <publisher> Addison-Wesley, </publisher> <address> 2 edition, </address> <year> 1994. </year>
Reference-contexts: The latter we include as dictated by the needs of Cnet. Cost data is commonly used in relational databases during query plan selection to estimate the I/O cost of the query. I/O costs include access cost to secondary storage, storage cost, cost of storing intermediate files <ref> [7] </ref>. For Cnet's application, we do not care about I/O costs and instead formulate cost functions that are useful during query optimization. The compiler applies optimization techniques after the query is parsed, a parse tree built, and an attribute list built for each node in the tree.
Reference: [8] <author> Weiming Gu, Greg Eisenhauer, Eileen Kraemer, Karsten Schwan, John Stasko, Jeffrey Vetter, and Nirupama Mallavarupu. </author> <title> Falcon: On-line monitoring and steering of large-scale parallel programs. </title> <booktitle> In Proceedings of FRONTIERS'95, </booktitle> <month> February </month> <year> 1995. </year>
Reference-contexts: Partial event ordering could be applied to the event stream before events reached the dispatcher. A partial ordering tool has been developed at Georgia Tech as part of Falcon <ref> [8] </ref> and could be adapted to our environment with minimal effort. Optimization techniques reduce the need for larger buffers by applying select operations early to reduce the number of events reaching Cartesian product. <p> The dispatcher is responsible for event handling. We describe each in some detail below. 5.1 Monitoring Infrastructure Cnet communicates with an application via a monitoring and communication infrastructure shown in points, a thread invokes sensors that write event data to a shared buffer. Falcon <ref> [8] </ref>, running as one or more separate threads, extracts event data from the buffer and sends it to the analysis tool in a binary encoded format, PBIO [5]. Events arrive at DataExchange [6], a communication library serving primarily in this context as an event handler.
Reference: [9] <author> Y. Huang and C. M. R. Kintala. </author> <title> Software implemented fault tolerance: Technologies and experience. </title> <booktitle> In Proceedings of 23rd Intl. Symposium on Fault-Tolerant Computing, </booktitle> <pages> pages 2-9, </pages> <month> June </month> <year> 1993. </year>
Reference-contexts: A negative implication though is that a constraint violation will never occur for a hazard condition that manifests itself as the inability of a sensor to generate its event data. To deal with such conditions, one could employ a technique such as watchdog timers <ref> [9] </ref> to detect the unanticipated absence of sensor sources. We describe the algorithm in the context of Figure 15. The net is implemented as a DAG with multiple entry points.
Reference: [10] <author> C. S. Jensen, J. Clifford, R. Elmasri, S. K. Gadia, P. Hayes, and S. Jajodia [eds]. </author> <title> A glossary of temporal database concepts. </title> <journal> ACM SIGMOD Record, </journal> <volume> 23(1) </volume> <pages> 52-64, </pages> <month> mar </month> <year> 1994. </year>
Reference-contexts: Transaction time, on the other hand, is the time at which a tuple or set of tuples entered the database [17]. Transaction time provides a history of all past states of the database and is useful as a record of corrections or modifications to past database states. Valid-time databases <ref> [10] </ref>, on the other hand, support valid time but not transaction time. It has been determined in [18] that for purposes of monitoring, a valid time database is sufficient.
Reference: [11] <author> Herman Kopetz and Paulo Verissimo. </author> <title> Real-time and dependability concepts. In Sape Mullender, editor, Distributed Systems. </title> <publisher> Addison-Wesley, </publisher> <address> 2 edition, </address> <year> 1993. </year>
Reference-contexts: Moreover, unlike real-time systems, continuous safety-critical systems are time dependent but only some of their components may have real-time constraints. The remainder of the system does not have the strict guarantees required of a real-time system, and its effort is considered to be best-effort as opposed to guaranteed-response <ref> [11] </ref>.
Reference: [12] <author> Joh Kuhl, Douglas Evans, Yiannis Papelis, Richard Romano, and Ginger Watson. </author> <title> The Iowa Driving Simulator: An immersive research environment. </title> <journal> Computer, </journal> <volume> 28(7) </volume> <pages> 35-41, </pages> <month> July </month> <year> 1995. </year>
Reference-contexts: Future work includes expanding cost data and cost function heuristics to better utilize the dynamic flexibility built into the implementation, and the application of the analysis tool to a virtual environment. For instance, in the Iowa Driving Simulator (IDS) <ref> [12] </ref> a fully immersive ground-vehicle simulator can place a driver in a highly realistic driving environment. Hazard conditions in such an environment are the same as in real-life but without the attendant risk of harm or loss.
Reference: [13] <author> Leslie Lamport. </author> <title> Synchronizing time servers. </title> <type> Technical Report 18, </type> <institution> Digital Systems Research Center, </institution> <address> Palo Alto, CA, </address> <month> June </month> <year> 1987. </year>
Reference-contexts: If the former, it is likely that two events that 'occurred simultaneously' from an external user point of view, will fail on the join condition. To compensate for clock skew present in distributed systems, we introduce the notion of a safety-margin <ref> [13] </ref>, an * value that relaxes the definition of temporal equality. Safety-margin is a parameter to the system at startup. To summarize, in adapting the operators to an on-line environment we have introduced three parameters: Cartesian product buffer size, safety margin, and a bounding parameter.
Reference: [14] <author> John McLean and Constance Heitmeyer. </author> <title> High assurance computer systems: A research agenda, safety track report. </title> <booktitle> In America in the Age of Information, National Science and Technology Council Committee on Information and Communications Forum, </booktitle> <year> 1995. </year> <month> 18 </month>
Reference-contexts: Similarly, loss of long-distance service can cause serious disruption of business activities and an ensuing loss of revenue <ref> [14] </ref>.
Reference: [15] <author> Beth Plale and Karsten Schwan. </author> <title> Dynamic optimization in on-line detection of safety constraint viola-tions. </title> <note> In Submitted for publication, </note> <year> 1998. </year>
Reference-contexts: The second phase pushes projects down the tree in an effort to discard attributes needed by subsequent operations. Phase three considers cost data and is discussed in detail in <ref> [15] </ref>. Code generation is performed in the final phase. Figures 7, 8, and 9 depict the algorithms used during phase ones through three, respectively. At each node in the parse tree (until a leaf is reached), there exists a parent and a child node.
Reference: [16] <author> Anuj Puri and Pravin Varaiya. </author> <title> Driving safely in smart cars. </title> <month> June </month> <year> 1995. </year>
Reference-contexts: A delay in responding to the request could potentially endanger the patient. Similar ex-amples exist for transportation systems, financial systems, and electronic, telephone and telecommunications networks. Consider the Automated Vehicle/Highway System (AVHS) <ref> [16] </ref>, a transportation system in which car-like vehicles travel in strictly controlled platoons so as to minimize the distance between each vehicle. One obvious safety-critical issue is crash prevention, particularly when vehicles change lanes or merge on or off the road.
Reference: [17] <author> R. T. Snodgrass and I. Ahn. </author> <title> Temporal databases. </title> <journal> IEEE Computer, </journal> <volume> 19(9) </volume> <pages> 35-42, </pages> <month> September </month> <year> 1986. </year>
Reference-contexts: Valid time is the time known and maintained by the application. It can be a physical time, logical time, or both. Transaction time, on the other hand, is the time at which a tuple or set of tuples entered the database <ref> [17] </ref>. Transaction time provides a history of all past states of the database and is useful as a record of corrections or modifications to past database states. Valid-time databases [10], on the other hand, support valid time but not transaction time.
Reference: [18] <author> Richard Snodgrass. </author> <title> A relational approach to monitoring complex systems. </title> <journal> IEEE Transactions on Computers, </journal> <volume> 6(2) </volume> <pages> 156-196, </pages> <month> May </month> <year> 1988. </year>
Reference-contexts: Transaction time provides a history of all past states of the database and is useful as a record of corrections or modifications to past database states. Valid-time databases [10], on the other hand, support valid time but not transaction time. It has been determined in <ref> [18] </ref> that for purposes of monitoring, a valid time database is sufficient. The reason for this is apparent when one considers that in an on-line environment, events flow through a collection of constraints and, if not retained by one or more constraints, will be discarded. <p> The inner-most operation, Cartesian product is performed first, followed by the select operations from inner to outer, and concluding with projection. This relational query has a graphical representation as an abstract syntax tree as is shown in Figure 6. According to <ref> [18] </ref>, constraints specifiable with a subset of ATSQL2 (the subset of which our language is a proper subset), have a corresponding relational algebraic form involving the relational operations selection 9 ( F ), projection ( d 1 ;d 2 ;:::;d m ), Cartesian product (fi), and intersection ("). <p> To implement the PRECEDES operator fully requires infinite storage; an unrealistic option. We adopt the solution taken in <ref> [18] </ref> by introducing a bounding parameter to limit the life of an event participating in a select operation (and in the process to limit the semantics of the PRECEDES operator as well). <p> The implicit condition makes the problem more tractable by allowing representation with finite buffer space. But what is a reasonable buffer size? This depends strongly upon the temporal ordering of the two input streams and on their relative synchrony <ref> [18] </ref>. For two event streams, each with an imposed partial order and containing an event for every logical timestep, the storage requirements are minimal. But in the absence of one or the other, a suitable buffer size cannot be determined.
Reference: [19] <author> Richard T. Snodgrass, </author> <title> editor. The TSQL2 Temporal Query Language. </title> <publisher> Kluwer Academic Publishers, </publisher> <year> 1995. </year>
Reference-contexts: Constraint-condition specifies the condition to be checked when the rule is triggered by an incoming event. The condition is specified with the temporal query language ATSQL2. ATSQL2 is a superset of SQL, a variant of TSQL2 <ref> [19] </ref> and is currently being proposed for incorporation into SQL3 [20]. The syntax of the constraint condition is given in Section 3.1. Action-list specifies a list of actions to be executed when the constraint condition evaluates to true. Its syntax is given in Section 3.2.
Reference: [20] <author> Richard T. Snodgrass, Michael H. Bohlen, Christian S. Jensen, and Andreas Steiner. </author> <title> Adding valid time to SQL/temporal. </title> <editor> In ISO/IEC JTC1/SC21/WG3 DBL MAD-146r2, </editor> <month> November </month> <year> 1996. </year>
Reference-contexts: The language we use is a relational query language incorporating features of the active database rule language Starburst [21] for its meta statements, and a subset of the relational temporal query language ATSQL2 <ref> [20] </ref> for specifying constraint conditions. We have extended ATSQL2 in a minor way as discussed in [3] to allow for the specification of real-time properties. The user specifies desired active behavior with rules. These rules are triggered by the occurrence of an event. <p> Constraint-condition specifies the condition to be checked when the rule is triggered by an incoming event. The condition is specified with the temporal query language ATSQL2. ATSQL2 is a superset of SQL, a variant of TSQL2 [19] and is currently being proposed for incorporation into SQL3 <ref> [20] </ref>. The syntax of the constraint condition is given in Section 3.1. Action-list specifies a list of actions to be executed when the constraint condition evaluates to true. Its syntax is given in Section 3.2. <p> There is no loss of generality in expressing an ATSQL2 query in relational algebraic form since for the set of statements we support, there is an equivalent representation in relational algebra <ref> [20] </ref>. As an example, the relational algebraic form of the constraint given in Figure 2 is shown as: ( d:idSelfr:rad ( r:rad&gt;=200 ( r:id=d:idSelf ( d:dist&lt;10 (RobotRadEv fi RobotDistEv))))) involving the relational operations selection ( F ), projection ( d 1 ;d 2 ;:::;d m ), and Cartesian product (fi).
Reference: [21] <author> Jennifer Widom and Stefano Ceri, </author> <title> editors. Active Database Systems. </title> <publisher> Morgan Kaufmann, </publisher> <year> 1996. </year> <month> 19 </month>
Reference-contexts: The language we use is a relational query language incorporating features of the active database rule language Starburst <ref> [21] </ref> for its meta statements, and a subset of the relational temporal query language ATSQL2 [20] for specifying constraint conditions. We have extended ATSQL2 in a minor way as discussed in [3] to allow for the specification of real-time properties. The user specifies desired active behavior with rules. <p> For example, a rule in an active database system may state that whenever an employee's bonus is increased by more than 100, that employee's rank is increased by 1. The rule would be triggered by the event of an update to the employee's bonus. Starburst <ref> [21] </ref> provides a rich set of semantics for specifying and managing rules, for prioritizing rules, and for inducing a partial ordering on the set of defined rules. Our language adopts the create rule, alter rule, drop rule, activate rule, and deactivate rule.
References-found: 21

