URL: http://www.cs.ucsb.edu/oocsb/self/papers/oopsla89.ps.Z
Refering-URL: http://www.cs.ucsb.edu/oocsb/self/papers/implementation.html
Root-URL: http://www.cs.ucsb.edu
Email: (craig@self.stanford.edu)  (ungar@self.stanford.edu)  (ehl@parcplace.com)  
Title: An Efficient Implementation of SELF, a Dynamically-Typed Object-Oriented Language Based on Prototypes  
Author: CRAIG CHAMBERS DAVID UNGAR ELGIN LEE 
Address: 94305  2500 Garcia Avenue, Mountain View, CA 94043.  Plymouth Street, Mountain View, CA 94043.  
Affiliation: Computer Systems Laboratory, Stanford University, Stanford, California  Apple Computer, and Sun Microsystems.  Sun Microsystems,  
Date: 4, 3, 1991  
Note: To be published in: LISP AND SYMBOLIC COMPUTATION: An International Journal,  1991 Kluwer Academic Publishers Manufactured in The Netherlands  *This work has been generously supported by National Science Foundation Presidential Young Investigator Grant #CCR-8657631, and by IBM, Texas Instruments, NCR, Tandem Computers,  Authors present address:  Authors present address: ParcPlace Systems, 1550  
Abstract: We have developed and implemented techniques that double the performance of dynamically-typed object-oriented languages. Our SELF implementation runs twice as fast as the fastest Smalltalk implementation, despite SELFs lack of classes and explicit variables. To compensate for the absence of classes, our system uses implementation-level maps to transparently group objects cloned from the same prototype, providing data type information and eliminating the apparent space overhead for prototype-based systems. To compensate for dynamic typing, user-defined control structures, and the lack of explicit variables, our system dynamically compiles multiple versions of a source method, each customized according to its receivers map. Within each version the type of the receiver is fixed, and thus the compiler can statically bind and inline all messages sent to self. Message splitting and type prediction extract and preserve even more static type information, allowing the compiler to inline many other messages. Inlining dramatically improves performance and eliminates the need to hard-wire low-level methods such as +, ==, and ifTrue:. Despite inlining and other optimizations, our system still supports interactive programming environments. The system traverses internal dependency lists to invalidate all compiled methods affected by a programming change. The debugger reconstructs inlined stack frames from compiler-generated debugging information, making inlining invisible to the SELF programmer. This paper was originally published in OOPSLA 89 Conference Proceedings (SIGPLAN Notices, 25, 10 (1989) 49-70). 
Abstract-found: 1
Intro-found: 1
Reference: 1. <author> Atkinson, R. G. </author> <title> Hurricane: An Optimizing Compiler for Smalltalk. </title> <booktitle> In OOP-SLA 86 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 21, </volume> <month> 11 </month> <year> (1986) </year> <month> 151-158. </month>
Reference-contexts: We hope that our second-generation system under construction (and described in section 7) will achieve even better levels of performance. The main obstacle to generating efficient code from Smalltalk programs, as many people have noted before <ref> [1, 2, 14] </ref>, is that very little static type information is available in the Smalltalk source. Only literal constants have a known class at compile-time; without detailed analysis, no other types are known. <p> Even if the Smalltalk programmer were willing to sacrifice many of the benefits of his exploratory programming environment and annotate his programs with static type declarations, designing an adequate type system for Smalltalk would be hard <ref> [1, 14] </ref>; the more exible the type system, the smaller the performance improvement possible and the smaller the reward for including type declarations in the first place. SELF programs are even harder to compile efficiently than Smalltalk programs. <p> We are not aware of any other implementations of dynamically-typed object-oriented languages that approach this level of efficiency. Other researchers have attempted to speed Smalltalk systems by adding type declarations to Smalltalk programs. Atkinsons Hurricane compiler compiles a subset of Smalltalk annotated with type declarations <ref> [1] </ref>. He reports a performance improvement of a factor of 2 for his Hurricane compiler over the Deutsch-Schiffman system on a 68020-based Sun-3; our initial SELF system already achieves the same performance improvement over the Deutsch-Schiffman system without type declarations.
Reference: 2. <author> Ballard, M. B., Maier, D., and Wirfs-Brock, A. QUICKTALK: </author> <title> A Smalltalk-80 Dialect for Defining Primitive Methods. </title> <booktitle> In OOPSLA 86 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 21, </volume> <month> 11 </month> <year> (1986) </year> <month> 140-150. </month>
Reference-contexts: We hope that our second-generation system under construction (and described in section 7) will achieve even better levels of performance. The main obstacle to generating efficient code from Smalltalk programs, as many people have noted before <ref> [1, 2, 14] </ref>, is that very little static type information is available in the Smalltalk source. Only literal constants have a known class at compile-time; without detailed analysis, no other types are known.
Reference: 3. <author> Bobrow, D. G., DeMichiel, L. G., Gabriel, R. P., Keene, S. E., Kiczales, G., and Moon, D. A. </author> <title> Common Lisp Object System Specification. </title> <journal> Published as SIGPLAN Notices, </journal> <volume> 23, </volume> <month> 9 </month> <year> (1988). </year>
Reference-contexts: In addition, we have implemented other optimizations that enable SELF to run twice as fast as the fastest Smalltalk system. These same techniques could improve implementations of class-based object-oriented languages such as Smalltalk, Flavors [20], CLOS <ref> [3] </ref>, C++ [27], Trellis/Owl [23], and Eiffel [19]. This paper describes our implementation for SELF, which has been running for over a year. First we review SELFs object and execution model in section 2.
Reference: 4. <author> Borning, A. H. </author> <title> Classes Versus Prototypes in Object-Oriented Languages. </title> <booktitle> In Proceedings of the ACM/IEEE Fall Joint Computer Conference (1986) 36-40. </booktitle>
Reference-contexts: Hereafter when we write Smalltalk we will be referring to the Smalltalk-80 system or language. 2 To illustrate how unusual this is, note that some well-respected authorities have gone so far as to require that object-oriented languages provide classes [32]. Other prototype models are discussed in <ref> [4, 15, 17, 26] </ref>. AN EFFICIENT IMPLEMENTATION OF SELF 59 2 Overview of SELF SELF was initially designed by the second author and Randall B. Smith at Xerox PARC. The subsequent design evolution and implementation were undertaken beginning in mid-1987 by the authors at Stanford University.
Reference: 5. <author> Borning, A. H., and Ingalls, D. H. H. </author> <title> A type declaration and inference system for Smalltalk. </title> <booktitle> In Conference Record of the Ninth Annual Symposium on Foundations of Computer Science (1982) 133-139. </booktitle>
Reference-contexts: Only literal constants have a known class at compile-time; without detailed analysis, no other types are known. Type infer-encing is difficult for Smalltalk programs, especially when the compiler is using the inferred types to improve performance <ref> [5, 8, 28] </ref>.
Reference: 6. <author> Chambers, C., and Ungar, D. </author> <title> Customization: Optimizing Compiler Technology for SELF, a Dynamically-Typed Object-Oriented Programming Language. </title> <booktitle> In Proceedings of the SIGPLAN 89 Conference on Programming Language Design and Implementation. Published as SIGPLAN Notices, </booktitle> <volume> 24, </volume> <month> 7 </month> <year> (1989) </year> <month> 146-160. </month> <note> 94 CHAMBERS, UNGAR, AND LEE </note>
Reference-contexts: First we review SELFs object and execution model in section 2. Then we describe SELFs object storage system in section 3, introducing maps and segregation and presenting object formats. Section 4 explains our byte-coded representation for source code. Section 5 reviews the compiler techniques, originally published in <ref> [6] </ref>. Section 6 explains how these optimizations can coexist with an exploratory programming environment that supports incremental recompilation and source-level debugging. Section 7 compares the performance of SELF to the fastest available Smalltalk system and an optimizing C compiler. <p> Instead our compilation techniques achieve better performance without compromising the languages conceptual simplicity and elegance, preserving the message passing model for all messages. 72 CHAMBERS, UNGAR, AND LEE 5 The Compiler The SELF compiler is a significant part of our efficient implementation <ref> [6] </ref>. It is similar to the Deutsch-Schiffman translator described in [11] (and implemented in the ParcPlace Smalltalk-80 system) in that it supports dynamic translation of byte-coded methods into machine code transparently on demand at run-time, and it uses an inline caching technique to reduce the cost of non-polymorphic message sends. <p> The next few subsections summarize our new compilation techniques; a more detailed discussion may be found in <ref> [6, 7] </ref>. 5.1 Customized Compilation The Deutsch-Schiffman Smalltalk-80 system compiles a single machine code method for a given source code method. Since many classes may inherit the same method the Smalltalk-80 compiler cannot know the exact class of the receiver.
Reference: 7. <author> Chambers, C., and Ungar, D. </author> <title> Iterative Type Analysis and Extended Message Splitting: Optimizing Dynamically-Typed Object-Oriented Programs. </title> <booktitle> In Proceedings of the ACM SIGPLAN 90 Conference on Programming Language Design and Implementation. Published as SIGPLAN Notices, </booktitle> <volume> 25, </volume> <month> 6 </month> <year> (1990) </year> <month> 150-162. </month> <note> Also to be published in Lisp and Symbolic Computation, 4, 3 (1991). </note>
Reference-contexts: The next few subsections summarize our new compilation techniques; a more detailed discussion may be found in <ref> [6, 7] </ref>. 5.1 Customized Compilation The Deutsch-Schiffman Smalltalk-80 system compiles a single machine code method for a given source code method. Since many classes may inherit the same method the Smalltalk-80 compiler cannot know the exact class of the receiver. <p> See <ref> [7] </ref>. 7 A Dorado is a measure of the performance of Smalltalk implementations.
Reference: 8. <author> Curtis, P. </author> <title> Type inferencing in Smalltalk. </title> <type> Personal communication (1989). </type>
Reference-contexts: However, although the Deutsch-Schiffman system is the fastest Smalltalk system <ref> (as of July 1989) </ref>, it still runs about 10 times slower than optimized C. <p> Only literal constants have a known class at compile-time; without detailed analysis, no other types are known. Type infer-encing is difficult for Smalltalk programs, especially when the compiler is using the inferred types to improve performance <ref> [5, 8, 28] </ref>. <p> As of this writing <ref> (July 1989) </ref>, we have completely rewritten the object storage system and unified the run-time/compile-time message lookup system. We have implemented the core of the second-generation compiler, and it now compiles and executes about half of our SELF code.
Reference: 9. <author> Deutsch, L. P. </author> <title> The Dorado Smalltalk-80 Implementation: Hardware Architectures Impact on Software Architecture. </title> <editor> In Krasner, G., editor, </editor> <title> Smalltalk-80: Bits of History, Words of Advice, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1983) 113-126. </address>
Reference-contexts: See [7]. 7 A Dorado is a measure of the performance of Smalltalk implementations. One Dorado is defined as the performance of an early Smalltalk implementation in microcode on the 70ns Xerox Dorado <ref> [9] </ref>; until recently it was the fastest available Smalltalk implementation. 88 CHAMBERS, UNGAR, AND LEE Raw Running Times Smalltalk SELF SELF-OO C (real ms) (cpu ms) (cpu ms) (cpu ms) perm 1559 660 420 120 towers 2130 900 560 190 queens 859 520 470 100 intmm 1490 970 (970) 160 puzzle
Reference: 10. <author> Deutsch, L. P. </author> <title> Richards benchmark. </title> <type> Personal communication (1988). </type>
Reference-contexts: We compare transliterations from C into Smalltalk and SELF of the Stanford integer benchmarks [13] and the Richards operating system simulation benchmark <ref> [10] </ref>, as well as the following small benchmarks, adapted from Smalltalk-80 systems [18]: sumToTest = ( 1 sumTo: 10000 ). sumTo: arg = ( | total &lt;- 0 | to: arg Do: [ | :index | total: total + index. ]. total ). recurseTest = ( 14 recurse ). recurse =
Reference: 11. <author> Deutsch, L. P., and Schiffman, A. M. </author> <title> Efficient Implementation of the Small-talk-80 System. </title> <booktitle> In Proceedings of the 11th Annual ACM Symposium on the Principles of Programming Languages (1984) 297-302. </booktitle>
Reference-contexts: For the simple cartesian point example, s is 5 (x, x:, y, y:, and parent) and a is 2 (x and y), leading to a total space cost to represent all point objects of 4n + 33 words. Published accounts of Smalltalk-80 systems <ref> [11, 29] </ref> indicate that these systems use at least two extra words per object: one for its class pointer and another for either its address or its hash code and ags. <p> It is similar to the Deutsch-Schiffman translator described in <ref> [11] </ref> (and implemented in the ParcPlace Smalltalk-80 system) in that it supports dynamic translation of byte-coded methods into machine code transparently on demand at run-time, and it uses an inline caching technique to reduce the cost of non-polymorphic message sends. <p> Calls to primitive operations are normally implemented using a simple procedure call to an external function in the virtual machine. However, like most other high-performance systems, including some Smalltalk systems <ref> [11, 12] </ref>, our SELF compiler replaces calls of certain common primitives, such as integer arithmetic, comparisons, and array accesses, with their hard-wired definitions. This significantly improves performance since some of these primitives can be implemented in two or three machine instructions if the overhead of the procedure call is removed.
Reference: 12. <author> Goldberg, A., and Robson, D. </author> <title> Smalltalk-80: The Language and Its Implementation. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1983). </address>
Reference-contexts: 1 Introduction SELF [32] is a dynamically-typed object-oriented language inspired by the Smalltalk-80 1 language <ref> [12] </ref>. Like Smalltalk, SELF has no type declarations, allowing programmers to rapidly build and modify systems without interference from out-of-date type declarations. <p> This small number results from both the simplicity and elegance of the SELF language and the lack of elaborate space-saving encodings. Smalltalk-80 defines a much larger set of byte codes <ref> [12] </ref>, tuned to minimize space and maximize interpretation speed, and includes byte codes to fetch and store local, instance, class, pool, and global variables and shortcut byte codes for common-case operations such as loading constants like nil, true, and 0. <p> Calls to primitive operations are normally implemented using a simple procedure call to an external function in the virtual machine. However, like most other high-performance systems, including some Smalltalk systems <ref> [11, 12] </ref>, our SELF compiler replaces calls of certain common primitives, such as integer arithmetic, comparisons, and array accesses, with their hard-wired definitions. This significantly improves performance since some of these primitives can be implemented in two or three machine instructions if the overhead of the procedure call is removed.
Reference: 13. <author> Hennessy, J. </author> <title> Stanford integer benchmarks. </title> <type> Personal communication (1988). </type>
Reference-contexts: We compare transliterations from C into Smalltalk and SELF of the Stanford integer benchmarks <ref> [13] </ref> and the Richards operating system simulation benchmark [10], as well as the following small benchmarks, adapted from Smalltalk-80 systems [18]: sumToTest = ( 1 sumTo: 10000 ). sumTo: arg = ( | total &lt;- 0 | to: arg Do: [ | :index | total: total + index. ]. total ).
Reference: 14. <author> Johnson, R. E., Graver, J. O., and Zurawski, L. W. </author> <title> TS: An Optimizing Compiler for Smalltalk. </title> <booktitle> In OOPSLA 88 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 23, </volume> <month> 11 </month> <year> (1988) </year> <month> 18-26. </month>
Reference-contexts: We hope that our second-generation system under construction (and described in section 7) will achieve even better levels of performance. The main obstacle to generating efficient code from Smalltalk programs, as many people have noted before <ref> [1, 2, 14] </ref>, is that very little static type information is available in the Smalltalk source. Only literal constants have a known class at compile-time; without detailed analysis, no other types are known. <p> Even if the Smalltalk programmer were willing to sacrifice many of the benefits of his exploratory programming environment and annotate his programs with static type declarations, designing an adequate type system for Smalltalk would be hard <ref> [1, 14] </ref>; the more exible the type system, the smaller the performance improvement possible and the smaller the reward for including type declarations in the first place. SELF programs are even harder to compile efficiently than Smalltalk programs. <p> Johnsons TS Typed Smalltalk system type-checks and compiles Smalltalk-80 programs fully annotated with type declarations <ref> [14] </ref>. He reports a performance improvement of a factor of between 5 and 10 over the Tektronix Smalltalk-80 interpreter on a 68020-based Tektronix 4405.
Reference: 15. <author> LaLonde, W. R., Thomas, D. A., and Pugh, J. R. </author> <title> An Exemplar Based Small-talk. </title> <booktitle> In OOPSLA 86 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 21, </volume> <month> 11 </month> <year> (1986) </year> <month> 322-330. </month>
Reference-contexts: Hereafter when we write Smalltalk we will be referring to the Smalltalk-80 system or language. 2 To illustrate how unusual this is, note that some well-respected authorities have gone so far as to require that object-oriented languages provide classes [32]. Other prototype models are discussed in <ref> [4, 15, 17, 26] </ref>. AN EFFICIENT IMPLEMENTATION OF SELF 59 2 Overview of SELF SELF was initially designed by the second author and Randall B. Smith at Xerox PARC. The subsequent design evolution and implementation were undertaken beginning in mid-1987 by the authors at Stanford University.
Reference: 16. <author> Lee, E. </author> <title> Object Storage and Inheritance for SELF, a Prototype-Based Object-Oriented Programming Language. </title> <type> Engineers thesis, </type> <institution> Stanford University (1988). </institution>
Reference-contexts: It creates new objects and reclaims the resources consumed by inaccessible objects. An ideal memory system would squeeze as many objects into as little memory as possible, for high performance at low cost. An earlier version of our SELF memory system was documented in <ref> [16] </ref>. Much of our memory system design exploits technology proven in existing high-performance Smalltalk systems. For minimal overhead in the common case, our SELF system represents object references using direct tagged pointers, rather than indirectly through an object table. <p> We computed the MiMS rating of our first-generation SELF system for the Richards benchmark on the SPARC-based Sun-4/260 to be 3.3 MiMS, or a message executed every 300ns <ref> [16] </ref>. The efficiency of an object-oriented system is inversely proportional to the number of instructions executed per message sent. The cycle time on the Sun-4/260 is 60ns [21], giving our SELF system a cost per message of about 5 cycles.
Reference: 17. <author> Lieberman, H. </author> <title> Using Prototypical Objects to Implement Shared Behavior in Object-Oriented Systems. </title> <booktitle> In OOPSLA 86 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 21, </volume> <month> 11 </month> <year> (1986) </year> <month> 214-223. </month>
Reference-contexts: Hereafter when we write Smalltalk we will be referring to the Smalltalk-80 system or language. 2 To illustrate how unusual this is, note that some well-respected authorities have gone so far as to require that object-oriented languages provide classes [32]. Other prototype models are discussed in <ref> [4, 15, 17, 26] </ref>. AN EFFICIENT IMPLEMENTATION OF SELF 59 2 Overview of SELF SELF was initially designed by the second author and Randall B. Smith at Xerox PARC. The subsequent design evolution and implementation were undertaken beginning in mid-1987 by the authors at Stanford University.
Reference: 18. <author> McCall, K. </author> <title> The Smalltalk-80 Benchmarks. </title> <editor> In Krasner, G., editor, </editor> <title> Smalltalk-80: Bits of History, Words of Advice, </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1983) 153-174. </address>
Reference-contexts: We compare transliterations from C into Smalltalk and SELF of the Stanford integer benchmarks [13] and the Richards operating system simulation benchmark [10], as well as the following small benchmarks, adapted from Smalltalk-80 systems <ref> [18] </ref>: sumToTest = ( 1 sumTo: 10000 ). sumTo: arg = ( | total &lt;- 0 | to: arg Do: [ | :index | total: total + index. ]. total ). recurseTest = ( 14 recurse ). recurse = ( = 0 ifFalse: [ (- 1) recurse. (- 1) recurse. ]
Reference: 19. <author> Meyer, B. </author> <title> Genericity versus Inheritance. </title> <booktitle> In OOPSLA 86 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 21, </volume> <month> 11 </month> <year> (1986) </year> <month> 391-405. </month>
Reference-contexts: In addition, we have implemented other optimizations that enable SELF to run twice as fast as the fastest Smalltalk system. These same techniques could improve implementations of class-based object-oriented languages such as Smalltalk, Flavors [20], CLOS [3], C++ [27], Trellis/Owl [23], and Eiffel <ref> [19] </ref>. This paper describes our implementation for SELF, which has been running for over a year. First we review SELFs object and execution model in section 2. Then we describe SELFs object storage system in section 3, introducing maps and segregation and presenting object formats.
Reference: 20. <author> Moon, D. A. </author> <title> Object-Oriented Programming with Flavors. </title> <booktitle> In OOPSLA 86 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 21, </volume> <month> 11 </month> <year> (1986) </year> <month> 1-16. </month> <title> AN EFFICIENT IMPLEMENTATION OF SELF 95 </title>
Reference-contexts: In addition, we have implemented other optimizations that enable SELF to run twice as fast as the fastest Smalltalk system. These same techniques could improve implementations of class-based object-oriented languages such as Smalltalk, Flavors <ref> [20] </ref>, CLOS [3], C++ [27], Trellis/Owl [23], and Eiffel [19]. This paper describes our implementation for SELF, which has been running for over a year. First we review SELFs object and execution model in section 2.
Reference: 21. <author> Namjoo, M., Agrawal, A., Jackson, D. C., and Quach, L. </author> <title> CMOS Gate Array Implementation of the SPARC Architecture. </title> <booktitle> In COMPCON 88 Conference Proceedings (1988) 10-13. </booktitle>
Reference-contexts: The efficiency of an object-oriented system is inversely proportional to the number of instructions executed per message sent. The cycle time on the Sun-4/260 is 60ns <ref> [21] </ref>, giving our SELF system a cost per message of about 5 cycles. Since the SPARC has been clocked at 1.6 cycles per instruction [21] (accounting for cache misses and multicycle instructions), this would give our SELF system an efficiency rating of around 3 instructions per message sent. <p> The cycle time on the Sun-4/260 is 60ns <ref> [21] </ref>, giving our SELF system a cost per message of about 5 cycles. Since the SPARC has been clocked at 1.6 cycles per instruction [21] (accounting for cache misses and multicycle instructions), this would give our SELF system an efficiency rating of around 3 instructions per message sent. We are not aware of any other implementations of dynamically-typed object-oriented languages that approach this level of efficiency.
Reference: 22. <institution> ParcPlace Systems. </institution> <note> ParcPlace Newsletter (Winter 1988), 1, 2 (1988). </note>
Reference-contexts: We compare the performance of our first-generation SELF implementation with a fast Smalltalk implementation and the standard Sun optimizing C compiler on a Sun-4/260 workstation. 6 The fastest Smalltalk system currently available (excluding graphics performance) is the ParcPlace V2.4 b2 Smalltalk-80 virtual machine, rated at about 4 Dorados 7 <ref> [22] </ref>; this system includes the Deutsch-Schiffman techniques described earlier.
Reference: 23. <author> Schaffert, C., Cooper, T., Bullis, B., Kilian, M., and Wilpolt, C. </author> <title> An Introduction to Trellis/Owl. </title> <booktitle> In OOPSLA 86 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 21, </volume> <month> 11 </month> <year> (1986) </year> <month> 9-16. </month>
Reference-contexts: In addition, we have implemented other optimizations that enable SELF to run twice as fast as the fastest Smalltalk system. These same techniques could improve implementations of class-based object-oriented languages such as Smalltalk, Flavors [20], CLOS [3], C++ [27], Trellis/Owl <ref> [23] </ref>, and Eiffel [19]. This paper describes our implementation for SELF, which has been running for over a year. First we review SELFs object and execution model in section 2. Then we describe SELFs object storage system in section 3, introducing maps and segregation and presenting object formats.
Reference: 24. <author> Steele, G. L., Jr. </author> <title> LAMBDA: The Ultimate Declarative. </title> <type> AI Memo 379, </type> <institution> MIT Artificial Intelligence Laboratory (1976). </institution>
Reference-contexts: 1 Introduction SELF [32] is a dynamically-typed object-oriented language inspired by the Smalltalk-80 1 language [12]. Like Smalltalk, SELF has no type declarations, allowing programmers to rapidly build and modify systems without interference from out-of-date type declarations. Also, SELF provides blocks (lexically-scoped function objects akin to closures <ref> [24, 25] </ref>) so that SELF programmers may define their own control structures; even the standard control structures for iteration and boolean selection are constructed out of blocks.
Reference: 25. <author> Steele, G. L., Jr., and Sussman, G. J. </author> <title> LAMBDA: The Ultimate Imperative. </title> <type> AI Memo 353, </type> <institution> MIT Artificial Intelligence Laboratory (1976). </institution>
Reference-contexts: 1 Introduction SELF [32] is a dynamically-typed object-oriented language inspired by the Smalltalk-80 1 language [12]. Like Smalltalk, SELF has no type declarations, allowing programmers to rapidly build and modify systems without interference from out-of-date type declarations. Also, SELF provides blocks (lexically-scoped function objects akin to closures <ref> [24, 25] </ref>) so that SELF programmers may define their own control structures; even the standard control structures for iteration and boolean selection are constructed out of blocks.
Reference: 26. <author> Stein, L. A. </author> <title> Delegation Is Inheritance. </title> <booktitle> In OOPSLA 87 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 22, </volume> <month> 12 </month> <year> (1987) </year> <month> 138-146. </month>
Reference-contexts: Hereafter when we write Smalltalk we will be referring to the Smalltalk-80 system or language. 2 To illustrate how unusual this is, note that some well-respected authorities have gone so far as to require that object-oriented languages provide classes [32]. Other prototype models are discussed in <ref> [4, 15, 17, 26] </ref>. AN EFFICIENT IMPLEMENTATION OF SELF 59 2 Overview of SELF SELF was initially designed by the second author and Randall B. Smith at Xerox PARC. The subsequent design evolution and implementation were undertaken beginning in mid-1987 by the authors at Stanford University.
Reference: 27. <author> Stroustrup, B. </author> <title> The C++ Programming Language. </title> <publisher> Addison-Wesley, </publisher> <address> Reading, MA (1986). </address>
Reference-contexts: In addition, we have implemented other optimizations that enable SELF to run twice as fast as the fastest Smalltalk system. These same techniques could improve implementations of class-based object-oriented languages such as Smalltalk, Flavors [20], CLOS [3], C++ <ref> [27] </ref>, Trellis/Owl [23], and Eiffel [19]. This paper describes our implementation for SELF, which has been running for over a year. First we review SELFs object and execution model in section 2. Then we describe SELFs object storage system in section 3, introducing maps and segregation and presenting object formats.
Reference: 28. <author> Suzuki, N. </author> <title> Inferring Types in Smalltalk. </title> <booktitle> In 8th Annual ACM Symposium on Principles of Programming Languages (1981) 187-199. </booktitle>
Reference-contexts: Only literal constants have a known class at compile-time; without detailed analysis, no other types are known. Type infer-encing is difficult for Smalltalk programs, especially when the compiler is using the inferred types to improve performance <ref> [5, 8, 28] </ref>.
Reference: 29. <author> Ungar, D. M. </author> <title> The Design and Evaluation of a High-Performance Smalltalk System. </title> <type> Ph.D. thesis, </type> <institution> the University of California at Berkeley (1986). Published by the MIT Press, </institution> <address> Cambridge, MA (1987). </address>
Reference-contexts: For minimal overhead in the common case, our SELF system represents object references using direct tagged pointers, rather than indirectly through an object table. Allocation and garbage collection in our SELF system uses Generation Scavenging with demographic feedback-mediated tenuring <ref> [29, 30] </ref>, augmented with a traditional mark-and-sweep collector to reclaim tenured garbage. <p> For the simple cartesian point example, s is 5 (x, x:, y, y:, and parent) and a is 2 (x and y), leading to a total space cost to represent all point objects of 4n + 33 words. Published accounts of Smalltalk-80 systems <ref> [11, 29] </ref> indicate that these systems use at least two extra words per object: one for its class pointer and another for either its address or its hash code and ags.
Reference: 30. <author> Ungar, D., and Jackson, F. </author> <title> Tenuring Policies for Generation-Based Storage Reclamation. </title> <booktitle> In OOPSLA 88 Conference Proceedings. Published as SIGP-LAN Notices, </booktitle> <volume> 23, </volume> <month> 11 </month> <year> (1988) </year> <month> 1-17. </month>
Reference-contexts: For minimal overhead in the common case, our SELF system represents object references using direct tagged pointers, rather than indirectly through an object table. Allocation and garbage collection in our SELF system uses Generation Scavenging with demographic feedback-mediated tenuring <ref> [29, 30] </ref>, augmented with a traditional mark-and-sweep collector to reclaim tenured garbage.
Reference: 31. <author> Ungar, D., and Smith, R. B. </author> <title> SELF: The Power of Simplicity. </title> <booktitle> In OOPSLA 87 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 22, </volume> <month> 12 </month> <year> (1987) </year> <month> 227-241. </month> <note> Also to be published in Lisp and Symbolic Computation, 4, 3 (1991). </note>
Reference: 32. <author> Wegner, P. </author> <title> Dimensions of Object-Based Language Design. </title> <booktitle> In OOPSLA 87 Conference Proceedings. Published as SIGPLAN Notices, </booktitle> <volume> 22, </volume> <month> 12 </month> <year> (1987) </year> <month> 168-182. 96 </month>
Reference-contexts: 1 Introduction SELF <ref> [32] </ref> is a dynamically-typed object-oriented language inspired by the Smalltalk-80 1 language [12]. Like Smalltalk, SELF has no type declarations, allowing programmers to rapidly build and modify systems without interference from out-of-date type declarations. <p> Hereafter when we write Smalltalk we will be referring to the Smalltalk-80 system or language. 2 To illustrate how unusual this is, note that some well-respected authorities have gone so far as to require that object-oriented languages provide classes <ref> [32] </ref>. Other prototype models are discussed in [4, 15, 17, 26]. AN EFFICIENT IMPLEMENTATION OF SELF 59 2 Overview of SELF SELF was initially designed by the second author and Randall B. Smith at Xerox PARC.
References-found: 32

